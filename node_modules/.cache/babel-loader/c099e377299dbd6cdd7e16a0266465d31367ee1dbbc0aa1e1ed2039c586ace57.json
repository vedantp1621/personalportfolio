{"ast":null,"code":"import TextureNode from '../accessors/TextureNode.js';\nimport { nodeObject, vec2 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { viewportTopLeft } from '../display/ViewportNode.js';\nimport { Matrix4, Vector2, Vector3, Vector4, Object3D, Plane, RenderTarget, HalfFloatType, LinearMipMapLinearFilter } from 'three';\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3(0, 0, -1);\nconst clipPlane = new Vector4();\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\nconst _size = new Vector2();\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = vec2(viewportTopLeft.x.oneMinus(), viewportTopLeft.y);\nlet _inReflector = false;\nclass ReflectorNode extends TextureNode {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(_defaultRT.texture, _defaultUV);\n    const {\n      target = new Object3D(),\n      resolution = 1,\n      generateMipmaps = false,\n      bounces = true\n    } = parameters;\n\n    //\n\n    this.target = target;\n    this.resolution = resolution;\n    this.generateMipmaps = generateMipmaps;\n    this.bounces = bounces;\n    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n    this.virtualCameras = new WeakMap();\n    this.renderTargets = new WeakMap();\n  }\n  _updateResolution(renderTarget, renderer) {\n    const resolution = this.resolution;\n    renderer.getDrawingBufferSize(_size);\n    renderTarget.setSize(Math.round(_size.width * resolution), Math.round(_size.height * resolution));\n  }\n  setup(builder) {\n    this._updateResolution(_defaultRT, builder.renderer);\n    return super.setup(builder);\n  }\n  getTextureNode() {\n    return this.textureNode;\n  }\n  getVirtualCamera(camera) {\n    let virtualCamera = this.virtualCameras.get(camera);\n    if (virtualCamera === undefined) {\n      virtualCamera = camera.clone();\n      this.virtualCameras.set(camera, virtualCamera);\n    }\n    return virtualCamera;\n  }\n  getRenderTarget(camera) {\n    let renderTarget = this.renderTargets.get(camera);\n    if (renderTarget === undefined) {\n      renderTarget = new RenderTarget(0, 0, {\n        type: HalfFloatType\n      });\n      if (this.generateMipmaps === true) {\n        renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n        renderTarget.texture.generateMipmaps = true;\n      }\n      this.renderTargets.set(camera, renderTarget);\n    }\n    return renderTarget;\n  }\n  updateBefore(frame) {\n    if (this.bounces === false && _inReflector) return false;\n    _inReflector = true;\n    const {\n      scene,\n      camera,\n      renderer,\n      material\n    } = frame;\n    const {\n      target\n    } = this;\n    const virtualCamera = this.getVirtualCamera(camera);\n    const renderTarget = this.getRenderTarget(virtualCamera);\n    renderer.getDrawingBufferSize(_size);\n    this._updateResolution(renderTarget, renderer);\n\n    //\n\n    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);\n    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    _rotationMatrix.extractRotation(target.matrixWorld);\n    _normal.set(0, 0, 1);\n    _normal.applyMatrix4(_rotationMatrix);\n    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);\n\n    // Avoid rendering when reflector is facing away\n\n    if (_view.dot(_normal) > 0) return;\n    _view.reflect(_normal).negate();\n    _view.add(_reflectorWorldPosition);\n    _rotationMatrix.extractRotation(camera.matrixWorld);\n    _lookAtPosition.set(0, 0, -1);\n    _lookAtPosition.applyMatrix4(_rotationMatrix);\n    _lookAtPosition.add(_cameraWorldPosition);\n    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);\n    _target.reflect(_normal).negate();\n    _target.add(_reflectorWorldPosition);\n\n    //\n\n    virtualCamera.coordinateSystem = camera.coordinateSystem;\n    virtualCamera.position.copy(_view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(_rotationMatrix);\n    virtualCamera.up.reflect(_normal);\n    virtualCamera.lookAt(_target);\n    virtualCamera.near = camera.near;\n    virtualCamera.far = camera.far;\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);\n    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);\n    const projectionMatrix = virtualCamera.projectionMatrix;\n    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    _q.z = -1.0;\n    _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n    // Calculate the scaled plane vector\n    clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));\n    const clipBias = 0;\n\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w;\n\n    //\n\n    this.value = renderTarget.texture;\n    material.visible = false;\n    const currentRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, virtualCamera);\n    renderer.setRenderTarget(currentRenderTarget);\n    material.visible = true;\n    _inReflector = false;\n  }\n}\nexport const reflector = parameters => nodeObject(new ReflectorNode(parameters));\nexport default ReflectorNode;","map":{"version":3,"names":["TextureNode","nodeObject","vec2","NodeUpdateType","viewportTopLeft","Matrix4","Vector2","Vector3","Vector4","Object3D","Plane","RenderTarget","HalfFloatType","LinearMipMapLinearFilter","_reflectorPlane","_normal","_reflectorWorldPosition","_cameraWorldPosition","_rotationMatrix","_lookAtPosition","clipPlane","_view","_target","_q","_size","_defaultRT","_defaultUV","x","oneMinus","y","_inReflector","ReflectorNode","constructor","parameters","arguments","length","undefined","texture","target","resolution","generateMipmaps","bounces","updateBeforeType","RENDER","FRAME","virtualCameras","WeakMap","renderTargets","_updateResolution","renderTarget","renderer","getDrawingBufferSize","setSize","Math","round","width","height","setup","builder","getTextureNode","textureNode","getVirtualCamera","camera","virtualCamera","get","clone","set","getRenderTarget","type","minFilter","updateBefore","frame","scene","material","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","dot","reflect","negate","add","coordinateSystem","position","copy","up","lookAt","near","far","updateMatrixWorld","projectionMatrix","setFromNormalAndCoplanarPoint","matrixWorldInverse","normal","z","constant","sign","elements","w","multiplyScalar","clipBias","value","visible","currentRenderTarget","setRenderTarget","render","reflector"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/utils/ReflectorNode.js"],"sourcesContent":["import TextureNode from '../accessors/TextureNode.js';\nimport { nodeObject, vec2 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { viewportTopLeft } from '../display/ViewportNode.js';\nimport { Matrix4, Vector2, Vector3, Vector4, Object3D, Plane, RenderTarget, HalfFloatType, LinearMipMapLinearFilter } from 'three';\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = vec2( viewportTopLeft.x.oneMinus(), viewportTopLeft.y );\n\nlet _inReflector = false;\n\nclass ReflectorNode extends TextureNode {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( _defaultRT.texture, _defaultUV );\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true\n\t\t} = parameters;\n\n\t\t//\n\n\t\tthis.target = target;\n\t\tthis.resolution = resolution;\n\t\tthis.generateMipmaps = generateMipmaps;\n\t\tthis.bounces = bounces;\n\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\tthis.virtualCameras = new WeakMap();\n\t\tthis.renderTargets = new WeakMap();\n\n\n\t}\n\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\trenderTarget.setSize( Math.round( _size.width * resolution ), Math.round( _size.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgetTextureNode() {\n\n\t\treturn this.textureNode;\n\n\t}\n\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t    renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t    renderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return false;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( _view.dot( _normal ) > 0 ) return;\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.value = renderTarget.texture;\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t}\n\n}\n\nexport const reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\nexport default ReflectorNode;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}