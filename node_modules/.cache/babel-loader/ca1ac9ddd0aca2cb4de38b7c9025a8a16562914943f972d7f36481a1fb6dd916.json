{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec2, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { loop } from '../utils/LoopNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { threshold } from './ColorAdjustmentNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texturePass } from './PassNode.js';\nimport { Vector2, RenderTarget } from 'three';\nimport QuadMesh from '../../objects/QuadMesh.js';\nconst quadMesh = new QuadMesh();\nclass AnamorphicNode extends TempNode {\n  constructor(textureNode, tresholdNode, scaleNode, samples) {\n    super('vec4');\n    this.textureNode = textureNode;\n    this.tresholdNode = tresholdNode;\n    this.scaleNode = scaleNode;\n    this.colorNode = vec3(0.1, 0.0, 1.0);\n    this.samples = samples;\n    this.resolution = new Vector2(1, 1);\n    this._renderTarget = new RenderTarget();\n    this._renderTarget.texture.name = 'anamorphic';\n    this._invSize = uniform(new Vector2());\n    this._textureNode = texturePass(this, this._renderTarget.texture);\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  getTextureNode() {\n    return this._textureNode;\n  }\n  setSize(width, height) {\n    this._invSize.value.set(1 / width, 1 / height);\n    width = Math.max(Math.round(width * this.resolution.x), 1);\n    height = Math.max(Math.round(height * this.resolution.y), 1);\n    this._renderTarget.setSize(width, height);\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const textureNode = this.textureNode;\n    const map = textureNode.value;\n    this._renderTarget.texture.type = map.type;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentTexture = textureNode.value;\n    quadMesh.material = this._material;\n    this.setSize(map.image.width, map.image.height);\n\n    // render\n\n    renderer.setRenderTarget(this._renderTarget);\n    quadMesh.render(renderer);\n\n    // restore\n\n    renderer.setRenderTarget(currentRenderTarget);\n    textureNode.value = currentTexture;\n  }\n  setup(builder) {\n    const textureNode = this.textureNode;\n    if (textureNode.isTextureNode !== true) {\n      console.error('AnamorphNode requires a TextureNode.');\n      return vec4();\n    }\n\n    //\n\n    const uvNode = textureNode.uvNode || uv();\n    const sampleTexture = uv => textureNode.cache().context({\n      getUV: () => uv,\n      forceUVContext: true\n    });\n    const anamorph = tslFn(() => {\n      const samples = this.samples;\n      const halfSamples = Math.floor(samples / 2);\n      const total = vec3(0).toVar();\n      loop({\n        start: -halfSamples,\n        end: halfSamples\n      }, _ref => {\n        let {\n          i\n        } = _ref;\n        const softness = float(i).abs().div(halfSamples).oneMinus();\n        const uv = vec2(uvNode.x.add(this._invSize.x.mul(i).mul(this.scaleNode)), uvNode.y);\n        const color = sampleTexture(uv);\n        const pass = threshold(color, this.tresholdNode).mul(softness);\n        total.addAssign(pass);\n      });\n      return total.mul(this.colorNode);\n    });\n\n    //\n\n    const material = this._material || (this._material = builder.createNodeMaterial());\n    material.fragmentNode = anamorph();\n\n    //\n\n    const properties = builder.getNodeProperties(this);\n    properties.textureNode = textureNode;\n\n    //\n\n    return this._textureNode;\n  }\n}\nexport const anamorphic = function (node) {\n  let threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;\n  let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n  let samples = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;\n  return nodeObject(new AnamorphicNode(nodeObject(node), nodeObject(threshold), nodeObject(scale), samples));\n};\naddNodeElement('anamorphic', anamorphic);\nexport default AnamorphicNode;","map":{"version":3,"names":["TempNode","nodeObject","addNodeElement","tslFn","float","vec2","vec3","vec4","loop","uniform","NodeUpdateType","threshold","uv","texturePass","Vector2","RenderTarget","QuadMesh","quadMesh","AnamorphicNode","constructor","textureNode","tresholdNode","scaleNode","samples","colorNode","resolution","_renderTarget","texture","name","_invSize","_textureNode","updateBeforeType","RENDER","getTextureNode","setSize","width","height","value","set","Math","max","round","x","y","updateBefore","frame","renderer","map","type","currentRenderTarget","getRenderTarget","currentTexture","material","_material","image","setRenderTarget","render","setup","builder","isTextureNode","console","error","uvNode","sampleTexture","cache","context","getUV","forceUVContext","anamorph","halfSamples","floor","total","toVar","start","end","_ref","i","softness","abs","div","oneMinus","add","mul","color","pass","addAssign","createNodeMaterial","fragmentNode","properties","getNodeProperties","anamorphic","node","arguments","length","undefined","scale"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/AnamorphicNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec2, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { loop } from '../utils/LoopNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { threshold } from './ColorAdjustmentNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texturePass } from './PassNode.js';\nimport { Vector2, RenderTarget } from 'three';\nimport QuadMesh from '../../objects/QuadMesh.js';\n\nconst quadMesh = new QuadMesh();\n\nclass AnamorphicNode extends TempNode {\n\n\tconstructor( textureNode, tresholdNode, scaleNode, samples ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.tresholdNode = tresholdNode;\n\t\tthis.scaleNode = scaleNode;\n\t\tthis.colorNode = vec3( 0.1, 0.0, 1.0 );\n\t\tthis.samples = samples;\n\t\tthis.resolution = new Vector2( 1, 1 );\n\n\t\tthis._renderTarget = new RenderTarget();\n\t\tthis._renderTarget.texture.name = 'anamorphic';\n\n\t\tthis._invSize = uniform( new Vector2() );\n\n\t\tthis._textureNode = texturePass( this, this._renderTarget.texture );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\n\t\twidth = Math.max( Math.round( width * this.resolution.x ), 1 );\n\t\theight = Math.max( Math.round( height * this.resolution.y ), 1 );\n\n\t\tthis._renderTarget.setSize( width, height );\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tthis._renderTarget.texture.type = map.type;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentTexture = textureNode.value;\n\n\t\tquadMesh.material = this._material;\n\n\t\tthis.setSize( map.image.width, map.image.height );\n\n\t\t// render\n\n\t\trenderer.setRenderTarget( this._renderTarget );\n\n\t\tquadMesh.render( renderer );\n\n\t\t// restore\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\ttextureNode.value = currentTexture;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\n\t\tif ( textureNode.isTextureNode !== true ) {\n\n\t\t\tconsole.error( 'AnamorphNode requires a TextureNode.' );\n\n\t\t\treturn vec4();\n\n\t\t}\n\n\t\t//\n\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst sampleTexture = ( uv ) => textureNode.cache().context( { getUV: () => uv, forceUVContext: true } );\n\n\t\tconst anamorph = tslFn( () => {\n\n\t\t\tconst samples = this.samples;\n\t\t\tconst halfSamples = Math.floor( samples / 2 );\n\n\t\t\tconst total = vec3( 0 ).toVar();\n\n\t\t\tloop( { start: - halfSamples, end: halfSamples }, ( { i } ) => {\n\n\t\t\t\tconst softness = float( i ).abs().div( halfSamples ).oneMinus();\n\n\t\t\t\tconst uv = vec2( uvNode.x.add( this._invSize.x.mul( i ).mul( this.scaleNode ) ), uvNode.y );\n\t\t\t\tconst color = sampleTexture( uv );\n\t\t\t\tconst pass = threshold( color, this.tresholdNode ).mul( softness );\n\n\t\t\t\ttotal.addAssign( pass );\n\n\t\t\t} );\n\n\t\t\treturn total.mul( this.colorNode );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst material = this._material || ( this._material = builder.createNodeMaterial() );\n\t\tmaterial.fragmentNode = anamorph();\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n}\n\nexport const anamorphic = ( node, threshold = .9, scale = 3, samples = 32 ) => nodeObject( new AnamorphicNode( nodeObject( node ), nodeObject( threshold ), nodeObject( scale ), samples ) );\n\naddNodeElement( 'anamorphic', anamorphic );\n\nexport default AnamorphicNode;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}