{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { nodeImmutable, nodeProxy } from '../shadernode/ShaderNode.js';\nimport { cameraNear, cameraFar } from '../accessors/CameraNode.js';\nimport { positionView } from '../accessors/PositionNode.js';\nimport { viewportDepthTexture } from './ViewportDepthTextureNode.js';\nclass ViewportDepthNode extends Node {\n  constructor(scope) {\n    let valueNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super('float');\n    this.scope = scope;\n    this.valueNode = valueNode;\n    this.isViewportDepthNode = true;\n  }\n  generate(builder) {\n    const {\n      scope\n    } = this;\n    if (scope === ViewportDepthNode.DEPTH_PIXEL) {\n      return builder.getFragDepth();\n    }\n    return super.generate(builder);\n  }\n  setup( /*builder*/\n  ) {\n    const {\n      scope\n    } = this;\n    let node = null;\n    if (scope === ViewportDepthNode.DEPTH) {\n      node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);\n    } else if (scope === ViewportDepthNode.DEPTH_TEXTURE) {\n      const texture = this.valueNode || viewportDepthTexture();\n      const viewZ = perspectiveDepthToViewZ(texture, cameraNear, cameraFar);\n      node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n    } else if (scope === ViewportDepthNode.DEPTH_PIXEL) {\n      if (this.valueNode !== null) {\n        node = depthPixelBase().assign(this.valueNode);\n      }\n    }\n    return node;\n  }\n}\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n// -near maps to 0; -far maps to 1\nexport const viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));\n\n// maps orthographic depth in [ 0, 1 ] to viewZ\nexport const orthographicDepthToViewZ = (depth, near, far) => near.sub(far).mul(depth).sub(near);\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\n// -near maps to 0; -far maps to 1\nexport const viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(near.sub(far).mul(viewZ));\n\n// maps perspective depth in [ 0, 1 ] to viewZ\nexport const perspectiveDepthToViewZ = (depth, near, far) => near.mul(far).div(far.sub(near).mul(depth).sub(far));\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.DEPTH_TEXTURE = 'depthTexture';\nViewportDepthNode.DEPTH_PIXEL = 'depthPixel';\nexport default ViewportDepthNode;\nconst depthPixelBase = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);\nexport const depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);\nexport const depthTexture = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_TEXTURE);\nexport const depthPixel = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);\ndepthPixel.assign = value => depthPixelBase(value);\naddNodeClass('ViewportDepthNode', ViewportDepthNode);","map":{"version":3,"names":["Node","addNodeClass","nodeImmutable","nodeProxy","cameraNear","cameraFar","positionView","viewportDepthTexture","ViewportDepthNode","constructor","scope","valueNode","arguments","length","undefined","isViewportDepthNode","generate","builder","DEPTH_PIXEL","getFragDepth","setup","node","DEPTH","viewZToOrthographicDepth","z","DEPTH_TEXTURE","texture","viewZ","perspectiveDepthToViewZ","depthPixelBase","assign","near","far","add","div","sub","orthographicDepthToViewZ","depth","mul","viewZToPerspectiveDepth","depthTexture","depthPixel","value"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/ViewportDepthNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { nodeImmutable, nodeProxy } from '../shadernode/ShaderNode.js';\nimport { cameraNear, cameraFar } from '../accessors/CameraNode.js';\nimport { positionView } from '../accessors/PositionNode.js';\nimport { viewportDepthTexture } from './ViewportDepthTextureNode.js';\n\nclass ViewportDepthNode extends Node {\n\n\tconstructor( scope, valueNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\tthis.scope = scope;\n\t\tthis.valueNode = valueNode;\n\n\t\tthis.isViewportDepthNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_PIXEL ) {\n\n\t\t\treturn builder.getFragDepth();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst { scope } = this;\n\n\t\tlet node = null;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH ) {\n\n\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH_TEXTURE ) {\n\n\t\t\tconst texture = this.valueNode || viewportDepthTexture();\n\n\t\t\tconst viewZ = perspectiveDepthToViewZ( texture, cameraNear, cameraFar );\n\t\t\tnode = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH_PIXEL ) {\n\n\t\t\tif ( this.valueNode !== null ) {\n\n \t\t\t\tnode = depthPixelBase().assign( this.valueNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n// -near maps to 0; -far maps to 1\nexport const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );\n\n// maps orthographic depth in [ 0, 1 ] to viewZ\nexport const orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );\n\n// NOTE: https://twitter.com/gonnavis/status/1377183786949959682\n\n// -near maps to 0; -far maps to 1\nexport const viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( near.sub( far ).mul( viewZ ) );\n\n// maps perspective depth in [ 0, 1 ] to viewZ\nexport const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );\n\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.DEPTH_TEXTURE = 'depthTexture';\nViewportDepthNode.DEPTH_PIXEL = 'depthPixel';\n\nexport default ViewportDepthNode;\n\nconst depthPixelBase = nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL );\n\nexport const depth = nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );\nexport const depthTexture = nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_TEXTURE );\nexport const depthPixel = nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL );\n\ndepthPixel.assign = ( value ) => depthPixelBase( value );\n\naddNodeClass( 'ViewportDepthNode', ViewportDepthNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}