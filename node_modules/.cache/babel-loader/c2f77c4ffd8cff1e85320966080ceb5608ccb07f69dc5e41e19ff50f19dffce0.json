{"ast":null,"code":"import InputNode from './InputNode.js';\nimport { objectGroup } from './UniformGroupNode.js';\nimport { addNodeClass } from './Node.js';\nimport { nodeObject, getConstNodeType } from '../shadernode/ShaderNode.js';\nclass UniformNode extends InputNode {\n  constructor(value) {\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(value, nodeType);\n    this.isUniformNode = true;\n    this.groupNode = objectGroup;\n  }\n  setGroup(group) {\n    this.groupNode = group;\n    return this;\n  }\n  getGroup() {\n    return this.groupNode;\n  }\n  getUniformHash(builder) {\n    return this.getHash(builder);\n  }\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const hash = this.getUniformHash(builder);\n    let sharedNode = builder.getNodeFromHash(hash);\n    if (sharedNode === undefined) {\n      builder.setHashNode(this, hash);\n      sharedNode = this;\n    }\n    const sharedNodeType = sharedNode.getInputType(builder);\n    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, builder.context.label);\n    const propertyName = builder.getPropertyName(nodeUniform);\n    if (builder.context.label !== undefined) delete builder.context.label;\n    return builder.format(propertyName, type, output);\n  }\n}\nexport default UniformNode;\nexport const uniform = (arg1, arg2) => {\n  const nodeType = getConstNodeType(arg2 || arg1);\n\n  // @TODO: get ConstNode from .traverse() in the future\n  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;\n  return nodeObject(new UniformNode(value, nodeType));\n};\naddNodeClass('UniformNode', UniformNode);","map":{"version":3,"names":["InputNode","objectGroup","addNodeClass","nodeObject","getConstNodeType","UniformNode","constructor","value","nodeType","arguments","length","undefined","isUniformNode","groupNode","setGroup","group","getGroup","getUniformHash","builder","getHash","generate","output","type","getNodeType","hash","sharedNode","getNodeFromHash","setHashNode","sharedNodeType","getInputType","nodeUniform","getUniformFromNode","shaderStage","context","label","propertyName","getPropertyName","format","uniform","arg1","arg2","isNode","node"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/core/UniformNode.js"],"sourcesContent":["import InputNode from './InputNode.js';\nimport { objectGroup } from './UniformGroupNode.js';\nimport { addNodeClass } from './Node.js';\nimport { nodeObject, getConstNodeType } from '../shadernode/ShaderNode.js';\n\nclass UniformNode extends InputNode {\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\tthis.isUniformNode = true;\n\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, builder.context.label );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.label !== undefined ) delete builder.context.label;\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\nexport default UniformNode;\n\nexport const uniform = ( arg1, arg2 ) => {\n\n\tconst nodeType = getConstNodeType( arg2 || arg1 );\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tconst value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\naddNodeClass( 'UniformNode', UniformNode );\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,gBAAgB;AACtC,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,YAAY,QAAQ,WAAW;AACxC,SAASC,UAAU,EAAEC,gBAAgB,QAAQ,6BAA6B;AAE1E,MAAMC,WAAW,SAASL,SAAS,CAAC;EAEnCM,WAAWA,CAAEC,KAAK,EAAoB;IAAA,IAAlBC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAElC,KAAK,CAAEF,KAAK,EAAEC,QAAS,CAAC;IAExB,IAAI,CAACI,aAAa,GAAG,IAAI;IAEzB,IAAI,CAACC,SAAS,GAAGZ,WAAW;EAE7B;EAEAa,QAAQA,CAAEC,KAAK,EAAG;IAEjB,IAAI,CAACF,SAAS,GAAGE,KAAK;IAEtB,OAAO,IAAI;EAEZ;EAEAC,QAAQA,CAAA,EAAG;IAEV,OAAO,IAAI,CAACH,SAAS;EAEtB;EAEAI,cAAcA,CAAEC,OAAO,EAAG;IAEzB,OAAO,IAAI,CAACC,OAAO,CAAED,OAAQ,CAAC;EAE/B;EAEAE,QAAQA,CAAEF,OAAO,EAAEG,MAAM,EAAG;IAE3B,MAAMC,IAAI,GAAG,IAAI,CAACC,WAAW,CAAEL,OAAQ,CAAC;IAExC,MAAMM,IAAI,GAAG,IAAI,CAACP,cAAc,CAAEC,OAAQ,CAAC;IAE3C,IAAIO,UAAU,GAAGP,OAAO,CAACQ,eAAe,CAAEF,IAAK,CAAC;IAEhD,IAAKC,UAAU,KAAKd,SAAS,EAAG;MAE/BO,OAAO,CAACS,WAAW,CAAE,IAAI,EAAEH,IAAK,CAAC;MAEjCC,UAAU,GAAG,IAAI;IAElB;IAEA,MAAMG,cAAc,GAAGH,UAAU,CAACI,YAAY,CAAEX,OAAQ,CAAC;IAEzD,MAAMY,WAAW,GAAGZ,OAAO,CAACa,kBAAkB,CAAEN,UAAU,EAAEG,cAAc,EAAEV,OAAO,CAACc,WAAW,EAAEd,OAAO,CAACe,OAAO,CAACC,KAAM,CAAC;IACxH,MAAMC,YAAY,GAAGjB,OAAO,CAACkB,eAAe,CAAEN,WAAY,CAAC;IAE3D,IAAKZ,OAAO,CAACe,OAAO,CAACC,KAAK,KAAKvB,SAAS,EAAG,OAAOO,OAAO,CAACe,OAAO,CAACC,KAAK;IAEvE,OAAOhB,OAAO,CAACmB,MAAM,CAAEF,YAAY,EAAEb,IAAI,EAAED,MAAO,CAAC;EAEpD;AAED;AAEA,eAAehB,WAAW;AAE1B,OAAO,MAAMiC,OAAO,GAAGA,CAAEC,IAAI,EAAEC,IAAI,KAAM;EAExC,MAAMhC,QAAQ,GAAGJ,gBAAgB,CAAEoC,IAAI,IAAID,IAAK,CAAC;;EAEjD;EACA,MAAMhC,KAAK,GAAKgC,IAAI,IAAIA,IAAI,CAACE,MAAM,KAAK,IAAI,GAAOF,IAAI,CAACG,IAAI,IAAIH,IAAI,CAACG,IAAI,CAACnC,KAAK,IAAMgC,IAAI,CAAChC,KAAK,GAAGgC,IAAI;EAEtG,OAAOpC,UAAU,CAAE,IAAIE,WAAW,CAAEE,KAAK,EAAEC,QAAS,CAAE,CAAC;AAExD,CAAC;AAEDN,YAAY,CAAE,aAAa,EAAEG,WAAY,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}