{"ast":null,"code":"import { Material, ShaderMaterial, NoColorSpace, LinearSRGBColorSpace } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { output, diffuseColor } from '../core/PropertyNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive, materialNormal } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { positionLocal, positionView } from '../accessors/PositionNode.js';\nimport { skinning } from '../accessors/SkinningNode.js';\nimport { morph } from '../accessors/MorphNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsNode } from '../lighting/LightsNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport { lightingContext } from '../lighting/LightingContextNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nimport { depthPixel } from '../display/ViewportDepthNode.js';\nimport { cameraLogDepth } from '../accessors/CameraNode.js';\nconst NodeMaterials = new Map();\nclass NodeMaterial extends ShaderMaterial {\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.type = this.constructor.type;\n    this.forceSinglePass = false;\n    this.fog = true;\n    this.lights = true;\n    this.normals = true;\n    this.colorSpaced = true;\n    this.lightsNode = null;\n    this.envNode = null;\n    this.colorNode = null;\n    this.normalNode = null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    this.positionNode = null;\n    this.depthNode = null;\n    this.shadowNode = null;\n    this.outputNode = null;\n    this.fragmentNode = null;\n    this.vertexNode = null;\n  }\n  customProgramCacheKey() {\n    return this.type + getCacheKey(this);\n  }\n  build(builder) {\n    this.setup(builder);\n  }\n  setup(builder) {\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    let resultNode;\n    if (this.fragmentNode === null) {\n      if (this.depthWrite === true) this.setupDepth(builder);\n      if (this.normals === true) this.setupNormal(builder);\n      this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      const outgoingLightNode = this.setupLighting(builder);\n      resultNode = this.setupOutput(builder, vec4(outgoingLightNode, diffuseColor.a));\n\n      // OUTPUT NODE\n\n      output.assign(resultNode);\n\n      //\n\n      if (this.outputNode !== null) resultNode = this.outputNode;\n    } else {\n      resultNode = this.setupOutput(builder, this.fragmentNode);\n    }\n    builder.stack.outputNode = resultNode;\n    builder.addFlow('fragment', builder.removeStack());\n  }\n  setupDepth(builder) {\n    const {\n      renderer\n    } = builder;\n\n    // Depth\n\n    let depthNode = this.depthNode;\n    if (depthNode === null && renderer.logarithmicDepthBuffer === true) {\n      const fragDepth = modelViewProjection().w.add(1);\n      depthNode = fragDepth.log2().mul(cameraLogDepth).mul(0.5);\n    }\n    if (depthNode !== null) {\n      depthPixel.assign(depthNode).append();\n    }\n  }\n  setupPosition(builder) {\n    const {\n      object\n    } = builder;\n    const geometry = object.geometry;\n    builder.addStack();\n\n    // Vertex\n\n    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      morph(object).append();\n    }\n    if (object.isSkinnedMesh === true) {\n      skinning(object).append();\n    }\n    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable('instance') === true) {\n      instance(object).append();\n    }\n    if (this.positionNode !== null) {\n      positionLocal.assign(this.positionNode);\n    }\n    const mvp = modelViewProjection();\n    builder.context.vertex = builder.removeStack();\n    builder.context.mvp = mvp;\n    return mvp;\n  }\n  setupDiffuseColor(_ref) {\n    let {\n      geometry\n    } = _ref;\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color', 'vec3')), colorNode.a);\n    }\n\n    // COLOR\n\n    diffuseColor.assign(colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode !== null || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;\n      diffuseColor.a.lessThanEqual(alphaTestNode).discard();\n    }\n  }\n  setupVariants( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupNormal() {\n    // NORMAL VIEW\n\n    if (this.flatShading === true) {\n      const normalNode = positionView.dFdx().cross(positionView.dFdy()).normalize();\n      transformedNormalView.assign(normalNode);\n    } else {\n      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;\n      transformedNormalView.assign(normalNode);\n    }\n  }\n  getEnvNode(builder) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);\n    } else if (builder.environmentNode) {\n      node = builder.environmentNode;\n    }\n    return node;\n  }\n  setupLights(builder) {\n    const envNode = this.getEnvNode(builder);\n\n    //\n\n    const materialLightsNode = [];\n    if (envNode) {\n      materialLightsNode.push(new EnvironmentNode(envNode));\n    }\n    if (builder.material.aoMap) {\n      materialLightsNode.push(new AONode(texture(builder.material.aoMap)));\n    }\n    let lightsN = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsN = lightsNode([...lightsN.lightNodes, ...materialLightsNode]);\n    }\n    return lightsN;\n  }\n  setupLightingModel( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.setupLights(builder) : null;\n    let outgoingLightNode = diffuseColor.rgb;\n    if (lightsNode && lightsNode.hasLight !== false) {\n      const lightingModel = this.setupLightingModel(builder);\n      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));\n    }\n    return outgoingLightNode;\n  }\n  setupOutput(builder, outputNode) {\n    const renderer = builder.renderer;\n\n    // TONE MAPPING\n\n    const toneMappingNode = builder.toneMappingNode;\n    if (this.toneMapped === true && toneMappingNode) {\n      outputNode = vec4(toneMappingNode.context({\n        color: outputNode.rgb\n      }), outputNode.a);\n    }\n\n    // FOG\n\n    if (this.fog === true) {\n      const fogNode = builder.fogNode;\n      if (fogNode) outputNode = vec4(fogNode.mixAssign(outputNode.rgb), outputNode.a);\n    }\n\n    // ENCODING\n\n    if (this.colorSpaced === true) {\n      const outputColorSpace = renderer.currentColorSpace;\n      if (outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace) {\n        outputNode = outputNode.linearToColorSpace(outputColorSpace);\n      }\n    }\n    return outputNode;\n  }\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    Object.assign(this.defines, material.defines);\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode = source.normalNode;\n    this.opacityNode = source.opacityNode;\n    this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.positionNode = source.positionNode;\n    this.depthNode = source.depthNode;\n    this.shadowNode = source.shadowNode;\n    this.outputNode = source.outputNode;\n    this.fragmentNode = source.fragmentNode;\n    this.vertexNode = source.vertexNode;\n    return super.copy(source);\n  }\n  static fromMaterial(material) {\n    if (material.isNodeMaterial === true) {\n      // is already a node material\n\n      return material;\n    }\n    const type = material.type.replace('Material', 'NodeMaterial');\n    const nodeMaterial = createNodeMaterialFromType(type);\n    if (nodeMaterial === undefined) {\n      throw new Error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n    }\n    for (const key in material) {\n      nodeMaterial[key] = material[key];\n    }\n    return nodeMaterial;\n  }\n}\nexport default NodeMaterial;\nexport function addNodeMaterial(type, nodeMaterial) {\n  if (typeof nodeMaterial !== 'function' || !type) throw new Error(`Node material ${type} is not a class`);\n  if (NodeMaterials.has(type)) {\n    console.warn(`Redefinition of node material ${type}`);\n    return;\n  }\n  NodeMaterials.set(type, nodeMaterial);\n  nodeMaterial.type = type;\n}\nexport function createNodeMaterialFromType(type) {\n  const Material = NodeMaterials.get(type);\n  if (Material !== undefined) {\n    return new Material();\n  }\n}\naddNodeMaterial('NodeMaterial', NodeMaterial);","map":{"version":3,"names":["Material","ShaderMaterial","NoColorSpace","LinearSRGBColorSpace","getNodeChildren","getCacheKey","attribute","output","diffuseColor","materialAlphaTest","materialColor","materialOpacity","materialEmissive","materialNormal","modelViewProjection","transformedNormalView","instance","positionLocal","positionView","skinning","morph","texture","cubeTexture","lightsNode","mix","float","vec3","vec4","AONode","lightingContext","EnvironmentNode","depthPixel","cameraLogDepth","NodeMaterials","Map","NodeMaterial","constructor","isNodeMaterial","type","forceSinglePass","fog","lights","normals","colorSpaced","envNode","colorNode","normalNode","opacityNode","backdropNode","backdropAlphaNode","alphaTestNode","positionNode","depthNode","shadowNode","outputNode","fragmentNode","vertexNode","customProgramCacheKey","build","builder","setup","addStack","stack","setupPosition","addFlow","removeStack","resultNode","depthWrite","setupDepth","setupNormal","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","setupOutput","a","assign","renderer","logarithmicDepthBuffer","fragDepth","w","add","log2","mul","append","object","geometry","morphAttributes","position","normal","color","isSkinnedMesh","instanceMatrix","isInstancedBufferAttribute","isAvailable","mvp","context","vertex","_ref","vertexColors","hasAttribute","xyz","alphaTest","lessThanEqual","discard","flatShading","dFdx","cross","dFdy","normalize","getEnvNode","node","envMap","isCubeTexture","environmentNode","setupLights","materialLightsNode","push","material","aoMap","lightsN","length","lightNodes","setupLightingModel","emissiveNode","rgb","hasLight","lightingModel","isNode","emissive","isColor","toneMappingNode","toneMapped","fogNode","mixAssign","outputColorSpace","currentColorSpace","linearToColorSpace","setDefaultValues","property","value","undefined","clone","Object","defines","descriptors","getOwnPropertyDescriptors","prototype","key","getOwnPropertyDescriptor","get","defineProperty","toJSON","meta","isRoot","textures","images","nodes","data","call","nodeChildren","inputNodes","childNode","uuid","extractFromCache","cache","values","metadata","copy","source","fromMaterial","replace","nodeMaterial","createNodeMaterialFromType","Error","addNodeMaterial","has","console","warn","set"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js"],"sourcesContent":["import { Material, ShaderMaterial, NoColorSpace, LinearSRGBColorSpace } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { output, diffuseColor } from '../core/PropertyNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive, materialNormal } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { positionLocal, positionView } from '../accessors/PositionNode.js';\nimport { skinning } from '../accessors/SkinningNode.js';\nimport { morph } from '../accessors/MorphNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsNode } from '../lighting/LightsNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport { lightingContext } from '../lighting/LightingContextNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nimport { depthPixel } from '../display/ViewportDepthNode.js';\nimport { cameraLogDepth } from '../accessors/CameraNode.js';\n\nconst NodeMaterials = new Map();\n\nclass NodeMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isNodeMaterial = true;\n\n\t\tthis.type = this.constructor.type;\n\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\t\tthis.normals = true;\n\n\t\tthis.colorSpaced = true;\n\n\t\tthis.lightsNode = null;\n\t\tthis.envNode = null;\n\n\t\tthis.colorNode = null;\n\t\tthis.normalNode = null;\n\t\tthis.opacityNode = null;\n\t\tthis.backdropNode = null;\n\t\tthis.backdropAlphaNode = null;\n\t\tthis.alphaTestNode = null;\n\n\t\tthis.positionNode = null;\n\n\t\tthis.depthNode = null;\n\t\tthis.shadowNode = null;\n\n\t\tthis.outputNode = null;\n\n\t\tthis.fragmentNode = null;\n\t\tthis.vertexNode = null;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey( this );\n\n\t}\n\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.vertexNode || this.setupPosition( builder );\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tif ( this.depthWrite === true ) this.setupDepth( builder );\n\n\t\t\tif ( this.normals === true ) this.setupNormal( builder );\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tresultNode = this.setupOutput( builder, vec4( outgoingLightNode, diffuseColor.a ) );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tif ( this.outputNode !== null ) resultNode = this.outputNode;\n\n\t\t} else {\n\n\t\t\tresultNode = this.setupOutput( builder, this.fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t}\n\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null && renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\tconst fragDepth = modelViewProjection().w.add( 1 );\n\n\t\t\tdepthNode = fragDepth.log2().mul( cameraLogDepth ).mul( 0.5 );\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepthPixel.assign( depthNode ).append();\n\n\t\t}\n\n\t}\n\n\tsetupPosition( builder ) {\n\n\t\tconst { object } = builder;\n\t\tconst geometry = object.geometry;\n\n\t\tbuilder.addStack();\n\n\t\t// Vertex\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorph( object ).append();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinning( object ).append();\n\n\t\t}\n\n\t\tif ( ( object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) && builder.isAvailable( 'instance' ) === true ) {\n\n\t\t\tinstance( object ).append();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( this.positionNode );\n\n\t\t}\n\n\t\tconst mvp = modelViewProjection();\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\t\tbuilder.context.mvp = mvp;\n\n\t\treturn mvp;\n\n\t}\n\n\tsetupDiffuseColor( { geometry } ) {\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t}\n\n\t}\n\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupNormal() {\n\n\t\t// NORMAL VIEW\n\n\t\tif ( this.flatShading === true ) {\n\n\t\t\tconst normalNode = positionView.dFdx().cross( positionView.dFdy() ).normalize();\n\n\t\t\ttransformedNormalView.assign( normalNode );\n\n\t\t} else {\n\n\t\t\tconst normalNode = this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t\t\ttransformedNormalView.assign( normalNode );\n\n\t\t}\n\n\t}\n\n\tgetEnvNode( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? cubeTexture( this.envMap ) : texture( this.envMap );\n\n\t\t} else if ( builder.environmentNode ) {\n\n\t\t\tnode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tsetupLights( builder ) {\n\n\t\tconst envNode = this.getEnvNode( builder );\n\n\t\t//\n\n\t\tconst materialLightsNode = [];\n\n\t\tif ( envNode ) {\n\n\t\t\tmaterialLightsNode.push( new EnvironmentNode( envNode ) );\n\n\t\t}\n\n\t\tif ( builder.material.aoMap ) {\n\n\t\t\tmaterialLightsNode.push( new AONode( texture( builder.material.aoMap ) ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = lightsNode( [ ...lightsN.lightNodes, ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = diffuseColor.rgb;\n\n\t\tif ( lightsNode && lightsNode.hasLight !== false ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder );\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\tsetupOutput( builder, outputNode ) {\n\n\t\tconst renderer = builder.renderer;\n\n\t\t// TONE MAPPING\n\n\t\tconst toneMappingNode = builder.toneMappingNode;\n\n\t\tif ( this.toneMapped === true && toneMappingNode ) {\n\n\t\t\toutputNode = vec4( toneMappingNode.context( { color: outputNode.rgb } ), outputNode.a );\n\n\t\t}\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\tconst fogNode = builder.fogNode;\n\n\t\t\tif ( fogNode ) outputNode = vec4( fogNode.mixAssign( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\t// ENCODING\n\n\t\tif ( this.colorSpaced === true ) {\n\n\t\t\tconst outputColorSpace = renderer.currentColorSpace;\n\n\t\t\tif ( outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace ) {\n\n\t\t\t\toutputNode = outputNode.linearToColorSpace( outputColorSpace );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tObject.assign( this.defines, material.defines );\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.positionNode = source.positionNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.shadowNode = source.shadowNode;\n\n\t\tthis.outputNode = source.outputNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\tstatic fromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial === true ) { // is already a node material\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tconst type = material.type.replace( 'Material', 'NodeMaterial' );\n\n\t\tconst nodeMaterial = createNodeMaterialFromType( type );\n\n\t\tif ( nodeMaterial === undefined ) {\n\n\t\t\tthrow new Error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t}\n\n\t\tfor ( const key in material ) {\n\n\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n}\n\nexport default NodeMaterial;\n\nexport function addNodeMaterial( type, nodeMaterial ) {\n\n\tif ( typeof nodeMaterial !== 'function' || ! type ) throw new Error( `Node material ${ type } is not a class` );\n\tif ( NodeMaterials.has( type ) ) {\n\n\t\tconsole.warn( `Redefinition of node material ${ type }` );\n\t\treturn;\n\n\t}\n\n\tNodeMaterials.set( type, nodeMaterial );\n\tnodeMaterial.type = type;\n\n}\n\nexport function createNodeMaterialFromType( type ) {\n\n\tconst Material = NodeMaterials.get( type );\n\n\tif ( Material !== undefined ) {\n\n\t\treturn new Material();\n\n\t}\n\n}\n\naddNodeMaterial( 'NodeMaterial', NodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}