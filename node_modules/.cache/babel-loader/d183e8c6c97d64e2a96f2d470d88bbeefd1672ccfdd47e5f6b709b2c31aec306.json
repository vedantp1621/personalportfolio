{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, tslFn, nodeObject, nodeProxy, vec4 } from '../shadernode/ShaderNode.js';\nimport { LinearSRGBColorSpace, SRGBColorSpace } from 'three';\nconst sRGBToLinearShader = tslFn(inputs => {\n  const {\n    value\n  } = inputs;\n  const {\n    rgb\n  } = value;\n  const a = rgb.mul(0.9478672986).add(0.0521327014).pow(2.4);\n  const b = rgb.mul(0.0773993808);\n  const factor = rgb.lessThanEqual(0.04045);\n  const rgbResult = mix(a, b, factor);\n  return vec4(rgbResult, value.a);\n});\nconst LinearTosRGBShader = tslFn(inputs => {\n  const {\n    value\n  } = inputs;\n  const {\n    rgb\n  } = value;\n  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);\n  const b = rgb.mul(12.92);\n  const factor = rgb.lessThanEqual(0.0031308);\n  const rgbResult = mix(a, b, factor);\n  return vec4(rgbResult, value.a);\n});\nconst getColorSpaceMethod = colorSpace => {\n  let method = null;\n  if (colorSpace === LinearSRGBColorSpace) {\n    method = 'Linear';\n  } else if (colorSpace === SRGBColorSpace) {\n    method = 'sRGB';\n  }\n  return method;\n};\nconst getMethod = (source, target) => {\n  return getColorSpaceMethod(source) + 'To' + getColorSpaceMethod(target);\n};\nclass ColorSpaceNode extends TempNode {\n  constructor(method, node) {\n    super('vec4');\n    this.method = method;\n    this.node = node;\n  }\n  setup() {\n    const {\n      method,\n      node\n    } = this;\n    if (method === ColorSpaceNode.LINEAR_TO_LINEAR) return node;\n    return Methods[method]({\n      value: node\n    });\n  }\n}\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.LINEAR_TO_sRGB = 'LinearTosRGB';\nColorSpaceNode.sRGB_TO_LINEAR = 'sRGBToLinear';\nconst Methods = {\n  [ColorSpaceNode.LINEAR_TO_sRGB]: LinearTosRGBShader,\n  [ColorSpaceNode.sRGB_TO_LINEAR]: sRGBToLinearShader\n};\nexport default ColorSpaceNode;\nexport const linearToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(LinearSRGBColorSpace, colorSpace), nodeObject(node)));\nexport const colorSpaceToLinear = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(colorSpace, LinearSRGBColorSpace), nodeObject(node)));\nexport const linearTosRGB = nodeProxy(ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB);\nexport const sRGBToLinear = nodeProxy(ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR);\naddNodeElement('linearTosRGB', linearTosRGB);\naddNodeElement('sRGBToLinear', sRGBToLinear);\naddNodeElement('linearToColorSpace', linearToColorSpace);\naddNodeElement('colorSpaceToLinear', colorSpaceToLinear);\naddNodeClass('ColorSpaceNode', ColorSpaceNode);","map":{"version":3,"names":["TempNode","mix","addNodeClass","addNodeElement","tslFn","nodeObject","nodeProxy","vec4","LinearSRGBColorSpace","SRGBColorSpace","sRGBToLinearShader","inputs","value","rgb","a","mul","add","pow","b","factor","lessThanEqual","rgbResult","LinearTosRGBShader","sub","getColorSpaceMethod","colorSpace","method","getMethod","source","target","ColorSpaceNode","constructor","node","setup","LINEAR_TO_LINEAR","Methods","LINEAR_TO_sRGB","sRGB_TO_LINEAR","linearToColorSpace","colorSpaceToLinear","linearTosRGB","sRGBToLinear"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, tslFn, nodeObject, nodeProxy, vec4 } from '../shadernode/ShaderNode.js';\n\nimport { LinearSRGBColorSpace, SRGBColorSpace } from 'three';\n\nconst sRGBToLinearShader = tslFn( ( inputs ) => {\n\n\tconst { value } = inputs;\n\tconst { rgb } = value;\n\n\tconst a = rgb.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );\n\tconst b = rgb.mul( 0.0773993808 );\n\tconst factor = rgb.lessThanEqual( 0.04045 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn vec4( rgbResult, value.a );\n\n} );\n\nconst LinearTosRGBShader = tslFn( ( inputs ) => {\n\n\tconst { value } = inputs;\n\tconst { rgb } = value;\n\n\tconst a = rgb.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\n\tconst b = rgb.mul( 12.92 );\n\tconst factor = rgb.lessThanEqual( 0.0031308 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn vec4( rgbResult, value.a );\n\n} );\n\nconst getColorSpaceMethod = ( colorSpace ) => {\n\n\tlet method = null;\n\n\tif ( colorSpace === LinearSRGBColorSpace ) {\n\n\t\tmethod = 'Linear';\n\n\t} else if ( colorSpace === SRGBColorSpace ) {\n\n\t\tmethod = 'sRGB';\n\n\t}\n\n\treturn method;\n\n};\n\nconst getMethod = ( source, target ) => {\n\n\treturn getColorSpaceMethod( source ) + 'To' + getColorSpaceMethod( target );\n\n};\n\nclass ColorSpaceNode extends TempNode {\n\n\tconstructor( method, node ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.method = method;\n\t\tthis.node = node;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { method, node } = this;\n\n\t\tif ( method === ColorSpaceNode.LINEAR_TO_LINEAR )\n\t\t\treturn node;\n\n\t\treturn Methods[ method ]( { value: node } );\n\n\t}\n\n}\n\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.LINEAR_TO_sRGB = 'LinearTosRGB';\nColorSpaceNode.sRGB_TO_LINEAR = 'sRGBToLinear';\n\nconst Methods = {\n\t[ ColorSpaceNode.LINEAR_TO_sRGB ]: LinearTosRGBShader,\n\t[ ColorSpaceNode.sRGB_TO_LINEAR ]: sRGBToLinearShader\n};\n\nexport default ColorSpaceNode;\n\nexport const linearToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( getMethod( LinearSRGBColorSpace, colorSpace ), nodeObject( node ) ) );\nexport const colorSpaceToLinear = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( getMethod( colorSpace, LinearSRGBColorSpace ), nodeObject( node ) ) );\n\nexport const linearTosRGB = nodeProxy( ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB );\nexport const sRGBToLinear = nodeProxy( ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR );\n\naddNodeElement( 'linearTosRGB', linearTosRGB );\naddNodeElement( 'sRGBToLinear', sRGBToLinear );\naddNodeElement( 'linearToColorSpace', linearToColorSpace );\naddNodeElement( 'colorSpaceToLinear', colorSpaceToLinear );\n\naddNodeClass( 'ColorSpaceNode', ColorSpaceNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}