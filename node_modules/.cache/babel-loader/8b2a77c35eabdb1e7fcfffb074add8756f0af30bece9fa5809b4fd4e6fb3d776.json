{"ast":null,"code":"import Node from '../core/Node.js';\nimport AnalyticLightNode from './AnalyticLightNode.js';\nimport { nodeObject, nodeProxy, vec3 } from '../shadernode/ShaderNode.js';\nconst LightNodes = new WeakMap();\nconst sortLights = lights => {\n  return lights.sort((a, b) => a.id - b.id);\n};\nclass LightsNode extends Node {\n  constructor() {\n    let lightNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super('vec3');\n    this.totalDiffuseNode = vec3().temp('totalDiffuse');\n    this.totalSpecularNode = vec3().temp('totalSpecular');\n    this.outgoingLightNode = vec3().temp('outgoingLight');\n    this.lightNodes = lightNodes;\n    this._hash = null;\n  }\n  get hasLight() {\n    return this.lightNodes.length > 0;\n  }\n  getHash() {\n    if (this._hash === null) {\n      const hash = [];\n      for (const lightNode of this.lightNodes) {\n        hash.push(lightNode.getHash());\n      }\n      this._hash = 'lights-' + hash.join(',');\n    }\n    return this._hash;\n  }\n  setup(builder) {\n    const context = builder.context;\n    const lightingModel = context.lightingModel;\n    let outgoingLightNode = this.outgoingLightNode;\n    if (lightingModel) {\n      const {\n        lightNodes,\n        totalDiffuseNode,\n        totalSpecularNode\n      } = this;\n      context.outgoingLight = outgoingLightNode;\n      const stack = builder.addStack();\n\n      //\n\n      lightingModel.start(context, stack, builder);\n\n      // lights\n\n      for (const lightNode of lightNodes) {\n        lightNode.build(builder);\n      }\n\n      //\n\n      lightingModel.indirectDiffuse(context, stack, builder);\n      lightingModel.indirectSpecular(context, stack, builder);\n      lightingModel.ambientOcclusion(context, stack, builder);\n\n      //\n\n      const {\n        backdrop,\n        backdropAlpha\n      } = context;\n      const {\n        directDiffuse,\n        directSpecular,\n        indirectDiffuse,\n        indirectSpecular\n      } = context.reflectedLight;\n      let totalDiffuse = directDiffuse.add(indirectDiffuse);\n      if (backdrop !== null) {\n        totalDiffuse = vec3(backdropAlpha !== null ? backdropAlpha.mix(totalDiffuse, backdrop) : backdrop);\n      }\n      totalDiffuseNode.assign(totalDiffuse);\n      totalSpecularNode.assign(directSpecular.add(indirectSpecular));\n      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));\n\n      //\n\n      lightingModel.finish(context, stack, builder);\n\n      //\n\n      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());\n    }\n    return outgoingLightNode;\n  }\n  _getLightNodeById(id) {\n    for (const lightNode of this.lightNodes) {\n      if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {\n        return lightNode;\n      }\n    }\n    return null;\n  }\n  fromLights() {\n    let lights = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const lightNodes = [];\n    lights = sortLights(lights);\n    for (const light of lights) {\n      let lightNode = this._getLightNodeById(light.id);\n      if (lightNode === null) {\n        const lightClass = light.constructor;\n        const lightNodeClass = LightNodes.has(lightClass) ? LightNodes.get(lightClass) : AnalyticLightNode;\n        lightNode = nodeObject(new lightNodeClass(light));\n      }\n      lightNodes.push(lightNode);\n    }\n    this.lightNodes = lightNodes;\n    this._hash = null;\n    return this;\n  }\n}\nexport default LightsNode;\nexport const lights = lights => nodeObject(new LightsNode().fromLights(lights));\nexport const lightsNode = nodeProxy(LightsNode);\nexport function addLightNode(lightClass, lightNodeClass) {\n  if (LightNodes.has(lightClass)) {\n    console.warn(`Redefinition of light node ${lightNodeClass.type}`);\n    return;\n  }\n  if (typeof lightClass !== 'function') throw new Error(`Light ${lightClass.name} is not a class`);\n  if (typeof lightNodeClass !== 'function' || !lightNodeClass.type) throw new Error(`Light node ${lightNodeClass.type} is not a class`);\n  LightNodes.set(lightClass, lightNodeClass);\n}","map":{"version":3,"names":["Node","AnalyticLightNode","nodeObject","nodeProxy","vec3","LightNodes","WeakMap","sortLights","lights","sort","a","b","id","LightsNode","constructor","lightNodes","arguments","length","undefined","totalDiffuseNode","temp","totalSpecularNode","outgoingLightNode","_hash","hasLight","getHash","hash","lightNode","push","join","setup","builder","context","lightingModel","outgoingLight","stack","addStack","start","build","indirectDiffuse","indirectSpecular","ambientOcclusion","backdrop","backdropAlpha","directDiffuse","directSpecular","reflectedLight","totalDiffuse","add","mix","assign","finish","bypass","removeStack","_getLightNodeById","isAnalyticLightNode","light","fromLights","lightClass","lightNodeClass","has","get","lightsNode","addLightNode","console","warn","type","Error","name","set"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/lighting/LightsNode.js"],"sourcesContent":["import Node from '../core/Node.js';\nimport AnalyticLightNode from './AnalyticLightNode.js';\nimport { nodeObject, nodeProxy, vec3 } from '../shadernode/ShaderNode.js';\n\nconst LightNodes = new WeakMap();\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nclass LightsNode extends Node {\n\n\tconstructor( lightNodes = [] ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.totalDiffuseNode = vec3().temp( 'totalDiffuse' );\n\t\tthis.totalSpecularNode = vec3().temp( 'totalSpecular' );\n\n\t\tthis.outgoingLightNode = vec3().temp( 'outgoingLight' );\n\n\t\tthis.lightNodes = lightNodes;\n\n\t\tthis._hash = null;\n\n\t}\n\n\tget hasLight() {\n\n\t\treturn this.lightNodes.length > 0;\n\n\t}\n\n\tgetHash() {\n\n\t\tif ( this._hash === null ) {\n\n\t\t\tconst hash = [];\n\n\t\t\tfor ( const lightNode of this.lightNodes ) {\n\n\t\t\t\thash.push( lightNode.getHash() );\n\n\t\t\t}\n\n\t\t\tthis._hash = 'lights-' + hash.join( ',' );\n\n\t\t}\n\n\t\treturn this._hash;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst context = builder.context;\n\t\tconst lightingModel = context.lightingModel;\n\n\t\tlet outgoingLightNode = this.outgoingLightNode;\n\n\t\tif ( lightingModel ) {\n\n\t\t\tconst { lightNodes, totalDiffuseNode, totalSpecularNode } = this;\n\n\t\t\tcontext.outgoingLight = outgoingLightNode;\n\n\t\t\tconst stack = builder.addStack();\n\n\t\t\t//\n\n\t\t\tlightingModel.start( context, stack, builder );\n\n\t\t\t// lights\n\n\t\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\t\tlightNode.build( builder );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlightingModel.indirectDiffuse( context, stack, builder );\n\t\t\tlightingModel.indirectSpecular( context, stack, builder );\n\t\t\tlightingModel.ambientOcclusion( context, stack, builder );\n\n\t\t\t//\n\n\t\t\tconst { backdrop, backdropAlpha } = context;\n\t\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;\n\n\t\t\tlet totalDiffuse = directDiffuse.add( indirectDiffuse );\n\n\t\t\tif ( backdrop !== null ) {\n\n\t\t\t\ttotalDiffuse = vec3( backdropAlpha !== null ? backdropAlpha.mix( totalDiffuse, backdrop ) : backdrop );\n\n\t\t\t}\n\n\t\t\ttotalDiffuseNode.assign( totalDiffuse );\n\t\t\ttotalSpecularNode.assign( directSpecular.add( indirectSpecular ) );\n\n\t\t\toutgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );\n\n\t\t\t//\n\n\t\t\tlightingModel.finish( context, stack, builder );\n\n\t\t\t//\n\n\t\t\toutgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t_getLightNodeById( id ) {\n\n\t\tfor ( const lightNode of this.lightNodes ) {\n\n\t\t\tif ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {\n\n\t\t\t\treturn lightNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfromLights( lights = [] ) {\n\n\t\tconst lightNodes = [];\n\n\t\tlights = sortLights( lights );\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tlet lightNode = this._getLightNodeById( light.id );\n\n\t\t\tif ( lightNode === null ) {\n\n\t\t\t\tconst lightClass = light.constructor;\n\t\t\t\tconst lightNodeClass = LightNodes.has( lightClass ) ? LightNodes.get( lightClass ) : AnalyticLightNode;\n\n\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\n\t\t\t}\n\n\t\t\tlightNodes.push( lightNode );\n\n\t\t}\n\n\t\tthis.lightNodes = lightNodes;\n\t\tthis._hash = null;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport default LightsNode;\n\nexport const lights = ( lights ) => nodeObject( new LightsNode().fromLights( lights ) );\nexport const lightsNode = nodeProxy( LightsNode );\n\nexport function addLightNode( lightClass, lightNodeClass ) {\n\n\tif ( LightNodes.has( lightClass ) ) {\n\n\t\tconsole.warn( `Redefinition of light node ${ lightNodeClass.type }` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof lightClass !== 'function' ) throw new Error( `Light ${ lightClass.name } is not a class` );\n\tif ( typeof lightNodeClass !== 'function' || ! lightNodeClass.type ) throw new Error( `Light node ${ lightNodeClass.type } is not a class` );\n\n\tLightNodes.set( lightClass, lightNodeClass );\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}