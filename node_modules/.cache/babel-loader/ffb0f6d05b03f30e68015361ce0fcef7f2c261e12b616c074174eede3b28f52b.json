{"ast":null,"code":"import Node, { addNodeClass } from './Node.js';\nimport { varying } from './VaryingNode.js';\nimport { nodeObject } from '../shadernode/ShaderNode.js';\nclass AttributeNode extends Node {\n  constructor(attributeName) {\n    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(nodeType);\n    this._attributeName = attributeName;\n  }\n  isGlobal() {\n    return true;\n  }\n  getHash(builder) {\n    return this.getAttributeName(builder);\n  }\n  getNodeType(builder) {\n    let nodeType = super.getNodeType(builder);\n    if (nodeType === null) {\n      const attributeName = this.getAttributeName(builder);\n      if (builder.hasGeometryAttribute(attributeName)) {\n        const attribute = builder.geometry.getAttribute(attributeName);\n        nodeType = builder.getTypeFromAttribute(attribute);\n      } else {\n        nodeType = 'float';\n      }\n    }\n    return nodeType;\n  }\n  setAttributeName(attributeName) {\n    this._attributeName = attributeName;\n    return this;\n  }\n  getAttributeName( /*builder*/\n  ) {\n    return this._attributeName;\n  }\n  generate(builder) {\n    const attributeName = this.getAttributeName(builder);\n    const nodeType = this.getNodeType(builder);\n    const geometryAttribute = builder.hasGeometryAttribute(attributeName);\n    if (geometryAttribute === true) {\n      const attribute = builder.geometry.getAttribute(attributeName);\n      const attributeType = builder.getTypeFromAttribute(attribute);\n      const nodeAttribute = builder.getAttribute(attributeName, attributeType);\n      if (builder.shaderStage === 'vertex') {\n        return builder.format(nodeAttribute.name, attributeType, nodeType);\n      } else {\n        const nodeVarying = varying(this);\n        return nodeVarying.build(builder, nodeType);\n      }\n    } else {\n      console.warn(`AttributeNode: Vertex attribute \"${attributeName}\" not found on geometry.`);\n      return builder.generateConst(nodeType);\n    }\n  }\n}\nexport default AttributeNode;\nexport const attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));\naddNodeClass('AttributeNode', AttributeNode);","map":{"version":3,"names":["Node","addNodeClass","varying","nodeObject","AttributeNode","constructor","attributeName","nodeType","arguments","length","undefined","_attributeName","isGlobal","getHash","builder","getAttributeName","getNodeType","hasGeometryAttribute","attribute","geometry","getAttribute","getTypeFromAttribute","setAttributeName","generate","geometryAttribute","attributeType","nodeAttribute","shaderStage","format","name","nodeVarying","build","console","warn","generateConst"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/core/AttributeNode.js"],"sourcesContent":["import Node, { addNodeClass } from './Node.js';\nimport { varying } from './VaryingNode.js';\nimport { nodeObject } from '../shadernode/ShaderNode.js';\n\nclass AttributeNode extends Node {\n\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = super.getNodeType( builder );\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n}\n\nexport default AttributeNode;\n\nexport const attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );\n\naddNodeClass( 'AttributeNode', AttributeNode );\n"],"mappings":"AAAA,OAAOA,IAAI,IAAIC,YAAY,QAAQ,WAAW;AAC9C,SAASC,OAAO,QAAQ,kBAAkB;AAC1C,SAASC,UAAU,QAAQ,6BAA6B;AAExD,MAAMC,aAAa,SAASJ,IAAI,CAAC;EAEhCK,WAAWA,CAAEC,aAAa,EAAoB;IAAA,IAAlBC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAE1C,KAAK,CAAED,QAAS,CAAC;IAEjB,IAAI,CAACI,cAAc,GAAGL,aAAa;EAEpC;EAEAM,QAAQA,CAAA,EAAG;IAEV,OAAO,IAAI;EAEZ;EAEAC,OAAOA,CAAEC,OAAO,EAAG;IAElB,OAAO,IAAI,CAACC,gBAAgB,CAAED,OAAQ,CAAC;EAExC;EAEAE,WAAWA,CAAEF,OAAO,EAAG;IAEtB,IAAIP,QAAQ,GAAG,KAAK,CAACS,WAAW,CAAEF,OAAQ,CAAC;IAE3C,IAAKP,QAAQ,KAAK,IAAI,EAAG;MAExB,MAAMD,aAAa,GAAG,IAAI,CAACS,gBAAgB,CAAED,OAAQ,CAAC;MAEtD,IAAKA,OAAO,CAACG,oBAAoB,CAAEX,aAAc,CAAC,EAAG;QAEpD,MAAMY,SAAS,GAAGJ,OAAO,CAACK,QAAQ,CAACC,YAAY,CAAEd,aAAc,CAAC;QAEhEC,QAAQ,GAAGO,OAAO,CAACO,oBAAoB,CAAEH,SAAU,CAAC;MAErD,CAAC,MAAM;QAENX,QAAQ,GAAG,OAAO;MAEnB;IAED;IAEA,OAAOA,QAAQ;EAEhB;EAEAe,gBAAgBA,CAAEhB,aAAa,EAAG;IAEjC,IAAI,CAACK,cAAc,GAAGL,aAAa;IAEnC,OAAO,IAAI;EAEZ;EAEAS,gBAAgBA,CAAA,CAAE;EAAA,EAAc;IAE/B,OAAO,IAAI,CAACJ,cAAc;EAE3B;EAEAY,QAAQA,CAAET,OAAO,EAAG;IAEnB,MAAMR,aAAa,GAAG,IAAI,CAACS,gBAAgB,CAAED,OAAQ,CAAC;IACtD,MAAMP,QAAQ,GAAG,IAAI,CAACS,WAAW,CAAEF,OAAQ,CAAC;IAC5C,MAAMU,iBAAiB,GAAGV,OAAO,CAACG,oBAAoB,CAAEX,aAAc,CAAC;IAEvE,IAAKkB,iBAAiB,KAAK,IAAI,EAAG;MAEjC,MAAMN,SAAS,GAAGJ,OAAO,CAACK,QAAQ,CAACC,YAAY,CAAEd,aAAc,CAAC;MAChE,MAAMmB,aAAa,GAAGX,OAAO,CAACO,oBAAoB,CAAEH,SAAU,CAAC;MAE/D,MAAMQ,aAAa,GAAGZ,OAAO,CAACM,YAAY,CAAEd,aAAa,EAAEmB,aAAc,CAAC;MAE1E,IAAKX,OAAO,CAACa,WAAW,KAAK,QAAQ,EAAG;QAEvC,OAAOb,OAAO,CAACc,MAAM,CAAEF,aAAa,CAACG,IAAI,EAAEJ,aAAa,EAAElB,QAAS,CAAC;MAErE,CAAC,MAAM;QAEN,MAAMuB,WAAW,GAAG5B,OAAO,CAAE,IAAK,CAAC;QAEnC,OAAO4B,WAAW,CAACC,KAAK,CAAEjB,OAAO,EAAEP,QAAS,CAAC;MAE9C;IAED,CAAC,MAAM;MAENyB,OAAO,CAACC,IAAI,CAAG,oCAAoC3B,aAAe,0BAA0B,CAAC;MAE7F,OAAOQ,OAAO,CAACoB,aAAa,CAAE3B,QAAS,CAAC;IAEzC;EAED;AAED;AAEA,eAAeH,aAAa;AAE5B,OAAO,MAAMc,SAAS,GAAGA,CAAEW,IAAI,EAAEtB,QAAQ,KAAMJ,UAAU,CAAE,IAAIC,aAAa,CAAEyB,IAAI,EAAEtB,QAAS,CAAE,CAAC;AAEhGN,YAAY,CAAE,eAAe,EAAEG,aAAc,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}