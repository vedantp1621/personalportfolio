{"ast":null,"code":"import _classCallCheck from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport Node, { addNodeClass } from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy, tslFn } from '../shadernode/ShaderNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { referenceIndex } from './ReferenceNode.js';\nimport { positionLocal } from './PositionNode.js';\nimport { normalLocal } from './NormalNode.js';\nimport { textureLoad } from './TextureNode.js';\nimport { vertexIndex } from '../core/IndexNode.js';\nimport { ivec2, int } from '../shadernode/ShaderNode.js';\nimport { DataArrayTexture, Vector2, Vector4, FloatType } from 'three';\nvar morphTextures = new WeakMap();\nvar morphVec4 = new Vector4();\nvar getMorph = tslFn(function (_ref) {\n  var bufferMap = _ref.bufferMap,\n    influence = _ref.influence,\n    stride = _ref.stride,\n    width = _ref.width,\n    depth = _ref.depth,\n    offset = _ref.offset;\n  var texelIndex = int(vertexIndex).mul(stride).add(offset);\n  var y = texelIndex.div(width);\n  var x = texelIndex.sub(y.mul(width));\n  var bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth);\n  return bufferAttrib.mul(influence);\n});\nfunction getEntry(geometry) {\n  var hasMorphPosition = geometry.morphAttributes.position !== undefined;\n  var hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n  var hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n  // instead of using attributes, the WebGL 2 code path encodes morph targets\n  // into an array of data textures. Each layer represents a single morph target.\n\n  var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n  var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n  var entry = morphTextures.get(geometry);\n  if (entry === undefined || entry.count !== morphTargetsCount) {\n    var disposeTexture = function disposeTexture() {\n      bufferTexture.dispose();\n      morphTextures.delete(geometry);\n      geometry.removeEventListener('dispose', disposeTexture);\n    };\n    if (entry !== undefined) entry.texture.dispose();\n    var morphTargets = geometry.morphAttributes.position || [];\n    var morphNormals = geometry.morphAttributes.normal || [];\n    var morphColors = geometry.morphAttributes.color || [];\n    var vertexDataCount = 0;\n    if (hasMorphPosition === true) vertexDataCount = 1;\n    if (hasMorphNormals === true) vertexDataCount = 2;\n    if (hasMorphColors === true) vertexDataCount = 3;\n    var width = geometry.attributes.position.count * vertexDataCount;\n    var height = 1;\n    var maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n    if (width > maxTextureSize) {\n      height = Math.ceil(width / maxTextureSize);\n      width = maxTextureSize;\n    }\n    var buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n    var bufferTexture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n    bufferTexture.type = FloatType;\n    bufferTexture.needsUpdate = true;\n\n    // fill buffer\n\n    var vertexDataStride = vertexDataCount * 4;\n    for (var i = 0; i < morphTargetsCount; i++) {\n      var morphTarget = morphTargets[i];\n      var morphNormal = morphNormals[i];\n      var morphColor = morphColors[i];\n      var offset = width * height * 4 * i;\n      for (var j = 0; j < morphTarget.count; j++) {\n        var stride = j * vertexDataStride;\n        if (hasMorphPosition === true) {\n          morphVec4.fromBufferAttribute(morphTarget, j);\n          buffer[offset + stride + 0] = morphVec4.x;\n          buffer[offset + stride + 1] = morphVec4.y;\n          buffer[offset + stride + 2] = morphVec4.z;\n          buffer[offset + stride + 3] = 0;\n        }\n        if (hasMorphNormals === true) {\n          morphVec4.fromBufferAttribute(morphNormal, j);\n          buffer[offset + stride + 4] = morphVec4.x;\n          buffer[offset + stride + 5] = morphVec4.y;\n          buffer[offset + stride + 6] = morphVec4.z;\n          buffer[offset + stride + 7] = 0;\n        }\n        if (hasMorphColors === true) {\n          morphVec4.fromBufferAttribute(morphColor, j);\n          buffer[offset + stride + 8] = morphVec4.x;\n          buffer[offset + stride + 9] = morphVec4.y;\n          buffer[offset + stride + 10] = morphVec4.z;\n          buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morphVec4.w : 1;\n        }\n      }\n    }\n    entry = {\n      count: morphTargetsCount,\n      texture: bufferTexture,\n      stride: vertexDataCount,\n      size: new Vector2(width, height)\n    };\n    morphTextures.set(geometry, entry);\n    geometry.addEventListener('dispose', disposeTexture);\n  }\n  return entry;\n}\nvar MorphNode = /*#__PURE__*/function (_Node) {\n  _inherits(MorphNode, _Node);\n  var _super = _createSuper(MorphNode);\n  function MorphNode(mesh) {\n    var _this;\n    _classCallCheck(this, MorphNode);\n    _this = _super.call(this, 'void');\n    _this.mesh = mesh;\n    _this.morphBaseInfluence = uniform(1);\n    _this.updateType = NodeUpdateType.OBJECT;\n    return _this;\n  }\n  _createClass(MorphNode, [{\n    key: \"setup\",\n    value: function setup(builder) {\n      var geometry = builder.geometry;\n      var hasMorphPosition = geometry.morphAttributes.position !== undefined;\n      var hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n      var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n      var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n\n      // nodes\n\n      var _getEntry = getEntry(geometry),\n        bufferMap = _getEntry.texture,\n        stride = _getEntry.stride,\n        size = _getEntry.size;\n      if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);\n      if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);\n      var width = int(size.width);\n      for (var i = 0; i < morphTargetsCount; i++) {\n        var influence = referenceIndex('morphTargetInfluences', i, 'float');\n        var depth = int(i);\n        if (hasMorphPosition === true) {\n          positionLocal.addAssign(getMorph({\n            bufferMap: bufferMap,\n            influence: influence,\n            stride: stride,\n            width: width,\n            depth: depth,\n            offset: int(0)\n          }));\n        }\n        if (hasMorphNormals === true) {\n          normalLocal.addAssign(getMorph({\n            bufferMap: bufferMap,\n            influence: influence,\n            stride: stride,\n            width: width,\n            depth: depth,\n            offset: int(1)\n          }));\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var morphBaseInfluence = this.morphBaseInfluence;\n      if (this.mesh.geometry.morphTargetsRelative) {\n        morphBaseInfluence.value = 1;\n      } else {\n        morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n      }\n    }\n  }]);\n  return MorphNode;\n}(Node);\nexport default MorphNode;\nexport var morph = nodeProxy(MorphNode);\naddNodeClass('MorphNode', MorphNode);","map":{"version":3,"names":["Node","addNodeClass","NodeUpdateType","nodeProxy","tslFn","uniform","referenceIndex","positionLocal","normalLocal","textureLoad","vertexIndex","ivec2","int","DataArrayTexture","Vector2","Vector4","FloatType","morphTextures","WeakMap","morphVec4","getMorph","_ref","bufferMap","influence","stride","width","depth","offset","texelIndex","mul","add","y","div","x","sub","bufferAttrib","getEntry","geometry","hasMorphPosition","morphAttributes","position","undefined","hasMorphNormals","normal","hasMorphColors","color","morphAttribute","morphTargetsCount","length","entry","get","count","disposeTexture","bufferTexture","dispose","delete","removeEventListener","texture","morphTargets","morphNormals","morphColors","vertexDataCount","attributes","height","maxTextureSize","Math","ceil","buffer","Float32Array","type","needsUpdate","vertexDataStride","i","morphTarget","morphNormal","morphColor","j","fromBufferAttribute","z","itemSize","w","size","set","addEventListener","MorphNode","_Node","_inherits","_super","_createSuper","mesh","_this","_classCallCheck","call","morphBaseInfluence","updateType","OBJECT","_createClass","key","value","setup","builder","_getEntry","mulAssign","addAssign","update","morphTargetsRelative","morphTargetInfluences","reduce","a","b","morph"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/accessors/MorphNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy, tslFn } from '../shadernode/ShaderNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { referenceIndex } from './ReferenceNode.js';\nimport { positionLocal } from './PositionNode.js';\nimport { normalLocal } from './NormalNode.js';\nimport { textureLoad } from './TextureNode.js';\nimport { vertexIndex } from '../core/IndexNode.js';\nimport { ivec2, int } from '../shadernode/ShaderNode.js';\nimport { DataArrayTexture, Vector2, Vector4, FloatType } from 'three';\n\nconst morphTextures = new WeakMap();\nconst morphVec4 = new Vector4();\n\nconst getMorph = tslFn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\tmorphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\tmorphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\tmorphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\tmorphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\tmorphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n\nclass MorphNode extends Node {\n\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.mesh = mesh;\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst influence = referenceIndex( 'morphTargetInfluences', i, 'float' );\n\t\t\tconst depth = int( i );\n\n\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth,\n\t\t\t\t\toffset: int( 0 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth,\n\t\t\t\t\toffset: int( 1 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\nexport default MorphNode;\n\nexport const morph = nodeProxy( MorphNode );\n\naddNodeClass( 'MorphNode', MorphNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}