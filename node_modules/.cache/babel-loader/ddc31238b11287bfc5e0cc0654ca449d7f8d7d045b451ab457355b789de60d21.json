{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { addNodeElement, nodeObject } from '../shadernode/ShaderNode.js';\nclass ComputeNode extends Node {\n  constructor(computeNode, count) {\n    let workgroupSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [64];\n    super('void');\n    this.isComputeNode = true;\n    this.computeNode = computeNode;\n    this.count = count;\n    this.workgroupSize = workgroupSize;\n    this.dispatchCount = 0;\n    this.version = 1;\n    this.updateBeforeType = NodeUpdateType.OBJECT;\n    this.updateDispatchCount();\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  updateDispatchCount() {\n    const {\n      count,\n      workgroupSize\n    } = this;\n    let size = workgroupSize[0];\n    for (let i = 1; i < workgroupSize.length; i++) size *= workgroupSize[i];\n    this.dispatchCount = Math.ceil(count / size);\n  }\n  onInit() {}\n  updateBefore(_ref) {\n    let {\n      renderer\n    } = _ref;\n    renderer.compute(this);\n  }\n  generate(builder) {\n    const {\n      shaderStage\n    } = builder;\n    if (shaderStage === 'compute') {\n      const snippet = this.computeNode.build(builder, 'void');\n      if (snippet !== '') {\n        builder.addLineFlowCode(snippet);\n      }\n    }\n  }\n}\nexport default ComputeNode;\nexport const compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));\naddNodeElement('compute', compute);\naddNodeClass('ComputeNode', ComputeNode);","map":{"version":3,"names":["Node","addNodeClass","NodeUpdateType","addNodeElement","nodeObject","ComputeNode","constructor","computeNode","count","workgroupSize","arguments","length","undefined","isComputeNode","dispatchCount","version","updateBeforeType","OBJECT","updateDispatchCount","dispose","dispatchEvent","type","needsUpdate","value","size","i","Math","ceil","onInit","updateBefore","_ref","renderer","compute","generate","builder","shaderStage","snippet","build","addLineFlowCode","node"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { addNodeElement, nodeObject } from '../shadernode/ShaderNode.js';\n\nclass ComputeNode extends Node {\n\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.isComputeNode = true;\n\n\t\tthis.computeNode = computeNode;\n\n\t\tthis.count = count;\n\t\tthis.workgroupSize = workgroupSize;\n\t\tthis.dispatchCount = 0;\n\n\t\tthis.version = 1;\n\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\tonInit() { }\n\n\tupdateBefore( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport default ComputeNode;\n\nexport const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\n\naddNodeElement( 'compute', compute );\n\naddNodeClass( 'ComputeNode', ComputeNode );\n"],"mappings":"AAAA,OAAOA,IAAI,IAAIC,YAAY,QAAQ,iBAAiB;AACpD,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,cAAc,EAAEC,UAAU,QAAQ,6BAA6B;AAExE,MAAMC,WAAW,SAASL,IAAI,CAAC;EAE9BM,WAAWA,CAAEC,WAAW,EAAEC,KAAK,EAA2B;IAAA,IAAzBC,aAAa,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAE,EAAE,CAAE;IAEtD,KAAK,CAAE,MAAO,CAAC;IAEf,IAAI,CAACG,aAAa,GAAG,IAAI;IAEzB,IAAI,CAACN,WAAW,GAAGA,WAAW;IAE9B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACK,aAAa,GAAG,CAAC;IAEtB,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,gBAAgB,GAAGd,cAAc,CAACe,MAAM;IAE7C,IAAI,CAACC,mBAAmB,CAAC,CAAC;EAE3B;EAEAC,OAAOA,CAAA,EAAG;IAET,IAAI,CAACC,aAAa,CAAE;MAAEC,IAAI,EAAE;IAAU,CAAE,CAAC;EAE1C;EAEA,IAAIC,WAAWA,CAAEC,KAAK,EAAG;IAExB,IAAKA,KAAK,KAAK,IAAI,EAAG,IAAI,CAACR,OAAO,EAAG;EAEtC;EAEAG,mBAAmBA,CAAA,EAAG;IAErB,MAAM;MAAEV,KAAK;MAAEC;IAAc,CAAC,GAAG,IAAI;IAErC,IAAIe,IAAI,GAAGf,aAAa,CAAE,CAAC,CAAE;IAE7B,KAAM,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,aAAa,CAACE,MAAM,EAAEc,CAAC,EAAG,EAC9CD,IAAI,IAAIf,aAAa,CAAEgB,CAAC,CAAE;IAE3B,IAAI,CAACX,aAAa,GAAGY,IAAI,CAACC,IAAI,CAAEnB,KAAK,GAAGgB,IAAK,CAAC;EAE/C;EAEAI,MAAMA,CAAA,EAAG,CAAE;EAEXC,YAAYA,CAAAC,IAAA,EAAiB;IAAA,IAAf;MAAEC;IAAS,CAAC,GAAAD,IAAA;IAEzBC,QAAQ,CAACC,OAAO,CAAE,IAAK,CAAC;EAEzB;EAEAC,QAAQA,CAAEC,OAAO,EAAG;IAEnB,MAAM;MAAEC;IAAY,CAAC,GAAGD,OAAO;IAE/B,IAAKC,WAAW,KAAK,SAAS,EAAG;MAEhC,MAAMC,OAAO,GAAG,IAAI,CAAC7B,WAAW,CAAC8B,KAAK,CAAEH,OAAO,EAAE,MAAO,CAAC;MAEzD,IAAKE,OAAO,KAAK,EAAE,EAAG;QAErBF,OAAO,CAACI,eAAe,CAAEF,OAAQ,CAAC;MAEnC;IAED;EAED;AAED;AAEA,eAAe/B,WAAW;AAE1B,OAAO,MAAM2B,OAAO,GAAGA,CAAEO,IAAI,EAAE/B,KAAK,EAAEC,aAAa,KAAML,UAAU,CAAE,IAAIC,WAAW,CAAED,UAAU,CAAEmC,IAAK,CAAC,EAAE/B,KAAK,EAAEC,aAAc,CAAE,CAAC;AAElIN,cAAc,CAAE,SAAS,EAAE6B,OAAQ,CAAC;AAEpC/B,YAAY,CAAE,aAAa,EAAEI,WAAY,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}