{"ast":null,"code":"import _classCallCheck from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\nimport { WebGPUCoordinateSystem } from 'three';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\nvar overrideMaterial = null;\nvar AnalyticLightNode = /*#__PURE__*/function (_LightingNode) {\n  _inherits(AnalyticLightNode, _LightingNode);\n  var _super = _createSuper(AnalyticLightNode);\n  function AnalyticLightNode() {\n    var _this;\n    var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, AnalyticLightNode);\n    _this = _super.call(this);\n    _this.updateType = NodeUpdateType.FRAME;\n    _this.light = light;\n    _this.rtt = null;\n    _this.shadowNode = null;\n    _this.color = new Color();\n    _this._defaultColorNode = uniform(_this.color);\n    _this.colorNode = _this._defaultColorNode;\n    _this.isAnalyticLightNode = true;\n    return _this;\n  }\n  _createClass(AnalyticLightNode, [{\n    key: \"getCacheKey\",\n    value: function getCacheKey() {\n      return _get(_getPrototypeOf(AnalyticLightNode.prototype), \"getCacheKey\", this).call(this) + '-' + (this.light.id + '-' + (this.light.castShadow ? '1' : '0'));\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.light.uuid;\n    }\n  }, {\n    key: \"setupShadow\",\n    value: function setupShadow(builder) {\n      var shadowNode = this.shadowNode;\n      if (shadowNode === null) {\n        if (overrideMaterial === null) {\n          overrideMaterial = builder.createNodeMaterial();\n          overrideMaterial.fragmentNode = vec4(0, 0, 0, 1);\n          overrideMaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.fragmentNode unintentionally when using material.shadowNode\n        }\n\n        var shadow = this.light.shadow;\n        var rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n        var depthTexture = new DepthTexture();\n        depthTexture.minFilter = NearestFilter;\n        depthTexture.magFilter = NearestFilter;\n        depthTexture.image.width = shadow.mapSize.width;\n        depthTexture.image.height = shadow.mapSize.height;\n        depthTexture.compareFunction = LessCompare;\n        rtt.depthTexture = depthTexture;\n        shadow.camera.updateProjectionMatrix();\n\n        //\n\n        var bias = reference('bias', 'float', shadow);\n        var normalBias = reference('normalBias', 'float', shadow);\n        var shadowCoord = uniform(shadow.matrix).mul(positionWorld.add(normalWorld.mul(normalBias)));\n        shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n        var frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n        var coordZ = shadowCoord.z.add(bias);\n        if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {\n          coordZ = coordZ.mul(2).sub(1); // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n        }\n\n        shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n        // follow webgpu standards\n        coordZ);\n        var textureCompare = function textureCompare(depthTexture, shadowCoord, compare) {\n          return texture(depthTexture, shadowCoord).compare(compare);\n        };\n        //const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n        // BasicShadowMap\n\n        shadowNode = textureCompare(depthTexture, shadowCoord.xy, shadowCoord.z);\n\n        // PCFShadowMap\n        /*\n        const mapSize = reference( 'mapSize', 'vec2', shadow );\n        const radius = reference( 'radius', 'float', shadow );\n        \tconst texelSize = vec2( 1 ).div( mapSize );\n        const dx0 = texelSize.x.negate().mul( radius );\n        const dy0 = texelSize.y.negate().mul( radius );\n        const dx1 = texelSize.x.mul( radius );\n        const dy1 = texelSize.y.mul( radius );\n        const dx2 = dx0.mul( 2 );\n        const dy2 = dy0.mul( 2 );\n        const dx3 = dx1.mul( 2 );\n        const dy3 = dy1.mul( 2 );\n        \tshadowNode = add(\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n        ).mul( 1 / 17 );\n        */\n        //\n\n        var shadowColor = texture(rtt.texture, shadowCoord);\n        this.rtt = rtt;\n        this.colorNode = this.colorNode.mul(frustumTest.mix(1, shadowNode.mix(shadowColor.a.mix(1, shadowColor), 1)));\n        this.shadowNode = shadowNode;\n\n        //\n\n        this.updateBeforeType = NodeUpdateType.RENDER;\n      }\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(builder) {\n      if (this.light.castShadow) this.setupShadow(builder);else if (this.shadowNode !== null) this.disposeShadow();\n    }\n  }, {\n    key: \"updateShadow\",\n    value: function updateShadow(frame) {\n      var rtt = this.rtt,\n        light = this.light;\n      var renderer = frame.renderer,\n        scene = frame.scene;\n      var currentOverrideMaterial = scene.overrideMaterial;\n      scene.overrideMaterial = overrideMaterial;\n      rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);\n      light.shadow.updateMatrices(light);\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentRenderObjectFunction = renderer.getRenderObjectFunction();\n      renderer.setRenderObjectFunction(function (object) {\n        if (object.castShadow === true) {\n          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            params[_key - 1] = arguments[_key];\n          }\n          renderer.renderObject.apply(renderer, [object].concat(params));\n        }\n      });\n      renderer.setRenderTarget(rtt);\n      renderer.render(scene, light.shadow.camera);\n      renderer.setRenderTarget(currentRenderTarget);\n      renderer.setRenderObjectFunction(currentRenderObjectFunction);\n      scene.overrideMaterial = currentOverrideMaterial;\n    }\n  }, {\n    key: \"disposeShadow\",\n    value: function disposeShadow() {\n      this.rtt.dispose();\n      this.shadowNode = null;\n      this.rtt = null;\n      this.colorNode = this._defaultColorNode;\n    }\n  }, {\n    key: \"updateBefore\",\n    value: function updateBefore(frame) {\n      var light = this.light;\n      if (light.castShadow) this.updateShadow(frame);\n    }\n  }, {\n    key: \"update\",\n    value: function update( /*frame*/\n    ) {\n      var light = this.light;\n      this.color.copy(light.color).multiplyScalar(light.intensity);\n    }\n  }]);\n  return AnalyticLightNode;\n}(LightingNode);\nexport default AnalyticLightNode;\naddNodeClass('AnalyticLightNode', AnalyticLightNode);","map":{"version":3,"names":["LightingNode","NodeUpdateType","uniform","addNodeClass","vec3","vec4","reference","texture","positionWorld","normalWorld","WebGPUCoordinateSystem","Color","DepthTexture","NearestFilter","LessCompare","overrideMaterial","AnalyticLightNode","_LightingNode","_inherits","_super","_createSuper","_this","light","arguments","length","undefined","_classCallCheck","call","updateType","FRAME","rtt","shadowNode","color","_defaultColorNode","colorNode","isAnalyticLightNode","_createClass","key","value","getCacheKey","_get","_getPrototypeOf","prototype","id","castShadow","getHash","uuid","setupShadow","builder","createNodeMaterial","fragmentNode","isShadowNodeMaterial","shadow","getRenderTarget","mapSize","width","height","depthTexture","minFilter","magFilter","image","compareFunction","camera","updateProjectionMatrix","bias","normalBias","shadowCoord","matrix","mul","add","xyz","div","w","frustumTest","x","greaterThanEqual","and","lessThanEqual","y","z","coordZ","renderer","coordinateSystem","sub","oneMinus","textureCompare","compare","xy","shadowColor","mix","a","updateBeforeType","RENDER","setup","disposeShadow","updateShadow","frame","scene","currentOverrideMaterial","setSize","updateMatrices","currentRenderTarget","currentRenderObjectFunction","getRenderObjectFunction","setRenderObjectFunction","object","_len","params","Array","_key","renderObject","apply","concat","setRenderTarget","render","dispose","updateBefore","update","copy","multiplyScalar","intensity"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js"],"sourcesContent":["import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/ vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\nimport { WebGPUCoordinateSystem } from 'three';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\n\nlet overrideMaterial = null;\n\nclass AnalyticLightNode extends LightingNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\tthis.light = light;\n\n\t\tthis.rtt = null;\n\t\tthis.shadowNode = null;\n\n\t\tthis.color = new Color();\n\t\tthis._defaultColorNode = uniform( this.color );\n\n\t\tthis.colorNode = this._defaultColorNode;\n\n\t\tthis.isAnalyticLightNode = true;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn super.getCacheKey() + '-' + ( this.light.id + '-' + ( this.light.castShadow ? '1' : '0' ) );\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tlet shadowNode = this.shadowNode;\n\n\t\tif ( shadowNode === null ) {\n\n\t\t\tif ( overrideMaterial === null ) {\n\n\t\t\t\toverrideMaterial = builder.createNodeMaterial();\n\t\t\t\toverrideMaterial.fragmentNode = vec4( 0, 0, 0, 1 );\n\t\t\t\toverrideMaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.fragmentNode unintentionally when using material.shadowNode\n\n\t\t\t}\n\n\t\t\tconst shadow = this.light.shadow;\n\t\t\tconst rtt = builder.getRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\t\tconst depthTexture = new DepthTexture();\n\t\t\tdepthTexture.minFilter = NearestFilter;\n\t\t\tdepthTexture.magFilter = NearestFilter;\n\t\t\tdepthTexture.image.width = shadow.mapSize.width;\n\t\t\tdepthTexture.image.height = shadow.mapSize.height;\n\t\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\t\trtt.depthTexture = depthTexture;\n\n\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t//\n\n\t\t\tconst bias = reference( 'bias', 'float', shadow );\n\t\t\tconst normalBias = reference( 'normalBias', 'float', shadow );\n\n\t\t\tlet shadowCoord = uniform( shadow.matrix ).mul( positionWorld.add( normalWorld.mul( normalBias ) ) );\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\t\tlet coordZ = shadowCoord.z.add( bias );\n\n\t\t\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t\tshadowCoord = vec3(\n\t\t\t\tshadowCoord.x,\n\t\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\t\tcoordZ\n\t\t\t);\n\n\t\t\tconst textureCompare = ( depthTexture, shadowCoord, compare ) => texture( depthTexture, shadowCoord ).compare( compare );\n\t\t\t//const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n\t\t\t// BasicShadowMap\n\n\t\t\tshadowNode = textureCompare( depthTexture, shadowCoord.xy, shadowCoord.z );\n\n\t\t\t// PCFShadowMap\n\t\t\t/*\n\t\t\tconst mapSize = reference( 'mapSize', 'vec2', shadow );\n\t\t\tconst radius = reference( 'radius', 'float', shadow );\n\n\t\t\tconst texelSize = vec2( 1 ).div( mapSize );\n\t\t\tconst dx0 = texelSize.x.negate().mul( radius );\n\t\t\tconst dy0 = texelSize.y.negate().mul( radius );\n\t\t\tconst dx1 = texelSize.x.mul( radius );\n\t\t\tconst dy1 = texelSize.y.mul( radius );\n\t\t\tconst dx2 = dx0.mul( 2 );\n\t\t\tconst dy2 = dy0.mul( 2 );\n\t\t\tconst dx3 = dx1.mul( 2 );\n\t\t\tconst dy3 = dy1.mul( 2 );\n\n\t\t\tshadowNode = add(\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t\t\t).mul( 1 / 17 );\n\t\t\t*/\n\t\t\t//\n\n\t\t\tconst shadowColor = texture( rtt.texture, shadowCoord );\n\n\t\t\tthis.rtt = rtt;\n\t\t\tthis.colorNode = this.colorNode.mul( frustumTest.mix( 1, shadowNode.mix( shadowColor.a.mix( 1, shadowColor ), 1 ) ) );\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\t//\n\n\t\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.light.castShadow ) this.setupShadow( builder );\n\t\telse if ( this.shadowNode !== null ) this.disposeShadow();\n\n\t}\n\n\tupdateShadow( frame ) {\n\n\t\tconst { rtt, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst currentOverrideMaterial = scene.overrideMaterial;\n\n\t\tscene.overrideMaterial = overrideMaterial;\n\n\t\trtt.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );\n\n\t\tlight.shadow.updateMatrices( light );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( object.castShadow === true ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.setRenderTarget( rtt );\n\n\t\trenderer.render( scene, light.shadow.camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\tscene.overrideMaterial = currentOverrideMaterial;\n\n\t}\n\n\tdisposeShadow() {\n\n\t\tthis.rtt.dispose();\n\n\t\tthis.shadowNode = null;\n\t\tthis.rtt = null;\n\n\t\tthis.colorNode = this._defaultColorNode;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tif ( light.castShadow ) this.updateShadow( frame );\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nexport default AnalyticLightNode;\n\naddNodeClass( 'AnalyticLightNode', AnalyticLightNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}