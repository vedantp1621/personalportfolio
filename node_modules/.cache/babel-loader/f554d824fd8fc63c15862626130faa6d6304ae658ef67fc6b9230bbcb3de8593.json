{"ast":null,"code":"import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nclass TextureNode extends UniformNode {\n  constructor(value) {\n    let uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(value);\n    this.isTextureNode = true;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this.compareNode = null;\n    this.depthNode = null;\n    this.sampler = true;\n    this.updateMatrix = false;\n    this.updateType = NodeUpdateType.NONE;\n    this.setUpdateMatrix(uvNode === null);\n  }\n  getUniformHash( /*builder*/\n  ) {\n    return this.value.uuid;\n  }\n  getNodeType( /*builder*/\n  ) {\n    if (this.value.isDepthTexture === true) return 'float';\n    return 'vec4';\n  }\n  getInputType( /*builder*/\n  ) {\n    return 'texture';\n  }\n  getDefaultUV() {\n    return uv(this.value.channel);\n  }\n  updateReference( /*frame*/\n  ) {\n    return this.value;\n  }\n  getTransformedUV(uvNode) {\n    const texture = this.value;\n    return uniform(texture.matrix).mul(vec3(uvNode, 1)).xy;\n  }\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n    return this;\n  }\n  setupUV(builder, uvNode) {\n    const texture = this.value;\n    if (builder.isFlipY() && (texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {\n      uvNode = uvNode.setY(uvNode.y.oneMinus());\n    }\n    return uvNode;\n  }\n  setup(builder) {\n    const properties = builder.getNodeProperties(this);\n\n    //\n\n    let uvNode = this.uvNode;\n    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {\n      uvNode = builder.context.getUV(this);\n    }\n    if (!uvNode) uvNode = this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = this.getTransformedUV(uvNode);\n    }\n    uvNode = this.setupUV(builder, uvNode);\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getTextureLevel) {\n      levelNode = builder.context.getTextureLevel(this);\n    }\n    if (levelNode !== null && builder.context.getTextureLevelAlgorithm !== undefined) {\n      levelNode = builder.context.getTextureLevelAlgorithm(this, levelNode);\n    }\n\n    //\n\n    properties.uvNode = uvNode;\n    properties.levelNode = levelNode;\n    properties.compareNode = this.compareNode;\n    properties.depthNode = this.depthNode;\n  }\n  generateUV(builder, uvNode) {\n    return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');\n  }\n  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet) {\n    const texture = this.value;\n    let snippet;\n    if (levelSnippet) {\n      snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);\n    } else if (compareSnippet) {\n      snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);\n    } else if (this.sampler === false) {\n      snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);\n    } else {\n      snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);\n    }\n    return snippet;\n  }\n  generate(builder, output) {\n    const properties = builder.getNodeProperties(this);\n    const texture = this.value;\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n    const textureProperty = super.generate(builder, 'property');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const {\n          uvNode,\n          levelNode,\n          compareNode,\n          depthNode\n        } = properties;\n        const uvSnippet = this.generateUV(builder, uvNode);\n        const levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;\n        const depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;\n        const compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;\n        const nodeVar = builder.getVarFromNode(this);\n        propertyName = builder.getPropertyName(nodeVar);\n        const snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet);\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`);\n        if (builder.context.tempWrite !== false) {\n          nodeData.snippet = snippet;\n          nodeData.propertyName = propertyName;\n        }\n      }\n      let snippet = propertyName;\n      const nodeType = this.getNodeType(builder);\n      if (builder.needsColorSpaceToLinear(texture)) {\n        snippet = colorSpaceToLinear(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, nodeType, output);\n    }\n  }\n  setSampler(value) {\n    this.sampler = value;\n    return this;\n  }\n  getSampler() {\n    return this.sampler;\n  }\n\n  // @TODO: Move to TSL\n\n  uv(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = uvNode;\n    return nodeObject(textureNode);\n  }\n  blur(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = levelNode.mul(maxMipLevel(textureNode));\n    return nodeObject(textureNode);\n  }\n  level(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = levelNode;\n    return textureNode;\n  }\n  size(levelNode) {\n    return textureSize(this, levelNode);\n  }\n  compare(compareNode) {\n    const textureNode = this.clone();\n    textureNode.compareNode = nodeObject(compareNode);\n    return nodeObject(textureNode);\n  }\n  depth(depthNode) {\n    const textureNode = this.clone();\n    textureNode.depthNode = nodeObject(depthNode);\n    return nodeObject(textureNode);\n  }\n\n  // --\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  }\n  update() {\n    const texture = this.value;\n    if (texture.matrixAutoUpdate === true) {\n      texture.updateMatrix();\n    }\n  }\n  clone() {\n    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode);\n    newNode.sampler = this.sampler;\n    return newNode;\n  }\n}\nexport default TextureNode;\nexport const texture = nodeProxy(TextureNode);\nexport const textureLoad = function () {\n  return texture(...arguments).setSampler(false);\n};\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = aTexture => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\naddNodeElement('texture', texture);\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass('TextureNode', TextureNode);","map":{"version":3,"names":["UniformNode","uniform","uv","textureSize","colorSpaceToLinear","expression","addNodeClass","maxMipLevel","addNodeElement","nodeProxy","vec3","nodeObject","NodeUpdateType","TextureNode","constructor","value","uvNode","arguments","length","undefined","levelNode","isTextureNode","compareNode","depthNode","sampler","updateMatrix","updateType","NONE","setUpdateMatrix","getUniformHash","uuid","getNodeType","isDepthTexture","getInputType","getDefaultUV","channel","updateReference","getTransformedUV","texture","matrix","mul","xy","FRAME","setupUV","builder","isFlipY","isRenderTargetTexture","isFramebufferTexture","setY","y","oneMinus","setup","properties","getNodeProperties","context","forceUVContext","getUV","getTextureLevel","getTextureLevelAlgorithm","generateUV","build","generateSnippet","textureProperty","uvSnippet","levelSnippet","depthSnippet","compareSnippet","snippet","generateTextureLevel","generateTextureCompare","generateTextureLoad","generateTexture","generate","output","isTexture","Error","isReference","nodeData","getDataFromNode","propertyName","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","tempWrite","nodeType","needsColorSpaceToLinear","colorSpace","format","setSampler","getSampler","textureNode","clone","blur","level","size","compare","depth","serialize","data","toJSON","meta","deserialize","textures","update","matrixAutoUpdate","newNode","textureLoad","aTexture","isNode","convert"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/accessors/TextureNode.js"],"sourcesContent":["import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass TextureNode extends UniformNode {\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value );\n\n\t\tthis.isTextureNode = true;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\t\tthis.compareNode = null;\n\t\tthis.depthNode = null;\n\n\t\tthis.sampler = true;\n\t\tthis.updateMatrix = false;\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\treturn 'vec4';\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\tupdateReference( /*frame*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\tgetTransformedUV( uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\treturn uniform( texture.matrix ).mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tuvNode = uvNode.setY( uvNode.y.oneMinus() );\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\tif ( levelNode !== null && builder.context.getTextureLevelAlgorithm !== undefined ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevelAlgorithm( this, levelNode );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, compareNode, depthNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tif ( builder.context.tempWrite !== false ) {\n\n\t\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsColorSpaceToLinear( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToLinear( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\tuv( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = uvNode;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tblur( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = levelNode.mul( maxMipLevel( textureNode ) );\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = levelNode;\n\n\t\treturn textureNode;\n\n\t}\n\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nexport default TextureNode;\n\nexport const texture = nodeProxy( TextureNode );\nexport const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\naddNodeElement( 'texture', texture );\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass( 'TextureNode', TextureNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}