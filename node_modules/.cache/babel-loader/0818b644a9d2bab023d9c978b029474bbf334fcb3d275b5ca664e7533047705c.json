{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeArray, nodeObject, nodeObjects } from '../shadernode/ShaderNode.js';\nclass FunctionCallNode extends TempNode {\n  constructor() {\n    let functionNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.functionNode = functionNode;\n    this.parameters = parameters;\n  }\n  setParameters(parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n  getParameters() {\n    return this.parameters;\n  }\n  getNodeType(builder) {\n    return this.functionNode.getNodeType(builder);\n  }\n  generate(builder) {\n    const params = [];\n    const functionNode = this.functionNode;\n    const inputs = functionNode.getInputs(builder);\n    const parameters = this.parameters;\n    if (Array.isArray(parameters)) {\n      for (let i = 0; i < parameters.length; i++) {\n        const inputNode = inputs[i];\n        const node = parameters[i];\n        params.push(node.build(builder, inputNode.type));\n      }\n    } else {\n      for (const inputNode of inputs) {\n        const node = parameters[inputNode.name];\n        if (node !== undefined) {\n          params.push(node.build(builder, inputNode.type));\n        } else {\n          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);\n        }\n      }\n    }\n    const functionName = functionNode.build(builder, 'property');\n    return `${functionName}( ${params.join(', ')} )`;\n  }\n}\nexport default FunctionCallNode;\nexport const call = function (func) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);\n  return nodeObject(new FunctionCallNode(nodeObject(func), params));\n};\naddNodeElement('call', call);\naddNodeClass('FunctionCallNode', FunctionCallNode);","map":{"version":3,"names":["TempNode","addNodeClass","addNodeElement","nodeArray","nodeObject","nodeObjects","FunctionCallNode","constructor","functionNode","arguments","length","undefined","parameters","setParameters","getParameters","getNodeType","builder","generate","params","inputs","getInputs","Array","isArray","i","inputNode","node","push","build","type","name","Error","functionName","join","call","func","_len","_key","isNode"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/code/FunctionCallNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeArray, nodeObject, nodeObjects } from '../shadernode/ShaderNode.js';\n\nclass FunctionCallNode extends TempNode {\n\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tthis.functionNode = functionNode;\n\t\tthis.parameters = parameters;\n\n\t}\n\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tconst inputNode = inputs[ i ];\n\t\t\t\tconst node = parameters[ i ];\n\n\t\t\t\tparams.push( node.build( builder, inputNode.type ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( node.build( builder, inputNode.type ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\n\n\t}\n\n}\n\nexport default FunctionCallNode;\n\nexport const call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn nodeObject( new FunctionCallNode( nodeObject( func ), params ) );\n\n};\n\naddNodeElement( 'call', call );\n\naddNodeClass( 'FunctionCallNode', FunctionCallNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}