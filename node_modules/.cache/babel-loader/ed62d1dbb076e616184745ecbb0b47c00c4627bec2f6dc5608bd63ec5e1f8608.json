{"ast":null,"code":"import _classCallCheck from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nvar TextureNode = /*#__PURE__*/function (_UniformNode) {\n  _inherits(TextureNode, _UniformNode);\n  var _super = _createSuper(TextureNode);\n  function TextureNode(value) {\n    var _this;\n    var uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, TextureNode);\n    _this = _super.call(this, value);\n    _this.isTextureNode = true;\n    _this.uvNode = uvNode;\n    _this.levelNode = levelNode;\n    _this.compareNode = null;\n    _this.depthNode = null;\n    _this.sampler = true;\n    _this.updateMatrix = false;\n    _this.updateType = NodeUpdateType.NONE;\n    _this.setUpdateMatrix(uvNode === null);\n    return _this;\n  }\n  _createClass(TextureNode, [{\n    key: \"getUniformHash\",\n    value: function getUniformHash( /*builder*/\n    ) {\n      return this.value.uuid;\n    }\n  }, {\n    key: \"getNodeType\",\n    value: function getNodeType( /*builder*/\n    ) {\n      if (this.value.isDepthTexture === true) return 'float';\n      return 'vec4';\n    }\n  }, {\n    key: \"getInputType\",\n    value: function getInputType( /*builder*/\n    ) {\n      return 'texture';\n    }\n  }, {\n    key: \"getDefaultUV\",\n    value: function getDefaultUV() {\n      return uv(this.value.channel);\n    }\n  }, {\n    key: \"updateReference\",\n    value: function updateReference( /*frame*/\n    ) {\n      return this.value;\n    }\n  }, {\n    key: \"getTransformedUV\",\n    value: function getTransformedUV(uvNode) {\n      var texture = this.value;\n      return uniform(texture.matrix).mul(vec3(uvNode, 1)).xy;\n    }\n  }, {\n    key: \"setUpdateMatrix\",\n    value: function setUpdateMatrix(value) {\n      this.updateMatrix = value;\n      this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n      return this;\n    }\n  }, {\n    key: \"setupUV\",\n    value: function setupUV(builder, uvNode) {\n      var texture = this.value;\n      if (builder.isFlipY() && (texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {\n        uvNode = uvNode.setY(uvNode.y.oneMinus());\n      }\n      return uvNode;\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(builder) {\n      var properties = builder.getNodeProperties(this);\n\n      //\n\n      var uvNode = this.uvNode;\n      if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {\n        uvNode = builder.context.getUV(this);\n      }\n      if (!uvNode) uvNode = this.getDefaultUV();\n      if (this.updateMatrix === true) {\n        uvNode = this.getTransformedUV(uvNode);\n      }\n      uvNode = this.setupUV(builder, uvNode);\n\n      //\n\n      var levelNode = this.levelNode;\n      if (levelNode === null && builder.context.getTextureLevel) {\n        levelNode = builder.context.getTextureLevel(this);\n      }\n      if (levelNode !== null && builder.context.getTextureLevelAlgorithm !== undefined) {\n        levelNode = builder.context.getTextureLevelAlgorithm(this, levelNode);\n      }\n\n      //\n\n      properties.uvNode = uvNode;\n      properties.levelNode = levelNode;\n      properties.compareNode = this.compareNode;\n      properties.depthNode = this.depthNode;\n    }\n  }, {\n    key: \"generateUV\",\n    value: function generateUV(builder, uvNode) {\n      return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');\n    }\n  }, {\n    key: \"generateSnippet\",\n    value: function generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet) {\n      var texture = this.value;\n      var snippet;\n      if (levelSnippet) {\n        snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);\n      } else if (compareSnippet) {\n        snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);\n      } else if (this.sampler === false) {\n        snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);\n      } else {\n        snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);\n      }\n      return snippet;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(builder, output) {\n      var properties = builder.getNodeProperties(this);\n      var texture = this.value;\n      if (!texture || texture.isTexture !== true) {\n        throw new Error('TextureNode: Need a three.js texture.');\n      }\n      var textureProperty = _get(_getPrototypeOf(TextureNode.prototype), \"generate\", this).call(this, builder, 'property');\n      if (output === 'sampler') {\n        return textureProperty + '_sampler';\n      } else if (builder.isReference(output)) {\n        return textureProperty;\n      } else {\n        var nodeData = builder.getDataFromNode(this);\n        var propertyName = nodeData.propertyName;\n        if (propertyName === undefined) {\n          var uvNode = properties.uvNode,\n            levelNode = properties.levelNode,\n            compareNode = properties.compareNode,\n            depthNode = properties.depthNode;\n          var uvSnippet = this.generateUV(builder, uvNode);\n          var levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;\n          var depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;\n          var compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;\n          var nodeVar = builder.getVarFromNode(this);\n          propertyName = builder.getPropertyName(nodeVar);\n          var _snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet);\n          builder.addLineFlowCode(\"\".concat(propertyName, \" = \").concat(_snippet));\n          if (builder.context.tempWrite !== false) {\n            nodeData.snippet = _snippet;\n            nodeData.propertyName = propertyName;\n          }\n        }\n        var snippet = propertyName;\n        var nodeType = this.getNodeType(builder);\n        if (builder.needsColorSpaceToLinear(texture)) {\n          snippet = colorSpaceToLinear(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);\n        }\n        return builder.format(snippet, nodeType, output);\n      }\n    }\n  }, {\n    key: \"setSampler\",\n    value: function setSampler(value) {\n      this.sampler = value;\n      return this;\n    }\n  }, {\n    key: \"getSampler\",\n    value: function getSampler() {\n      return this.sampler;\n    }\n\n    // @TODO: Move to TSL\n  }, {\n    key: \"uv\",\n    value: function uv(uvNode) {\n      var textureNode = this.clone();\n      textureNode.uvNode = uvNode;\n      return nodeObject(textureNode);\n    }\n  }, {\n    key: \"blur\",\n    value: function blur(levelNode) {\n      var textureNode = this.clone();\n      textureNode.levelNode = levelNode.mul(maxMipLevel(textureNode));\n      return nodeObject(textureNode);\n    }\n  }, {\n    key: \"level\",\n    value: function level(levelNode) {\n      var textureNode = this.clone();\n      textureNode.levelNode = levelNode;\n      return textureNode;\n    }\n  }, {\n    key: \"size\",\n    value: function size(levelNode) {\n      return textureSize(this, levelNode);\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(compareNode) {\n      var textureNode = this.clone();\n      textureNode.compareNode = nodeObject(compareNode);\n      return nodeObject(textureNode);\n    }\n  }, {\n    key: \"depth\",\n    value: function depth(depthNode) {\n      var textureNode = this.clone();\n      textureNode.depthNode = nodeObject(depthNode);\n      return nodeObject(textureNode);\n    }\n\n    // --\n  }, {\n    key: \"serialize\",\n    value: function serialize(data) {\n      _get(_getPrototypeOf(TextureNode.prototype), \"serialize\", this).call(this, data);\n      data.value = this.value.toJSON(data.meta).uuid;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data) {\n      _get(_getPrototypeOf(TextureNode.prototype), \"deserialize\", this).call(this, data);\n      this.value = data.meta.textures[data.value];\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var texture = this.value;\n      if (texture.matrixAutoUpdate === true) {\n        texture.updateMatrix();\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var newNode = new this.constructor(this.value, this.uvNode, this.levelNode);\n      newNode.sampler = this.sampler;\n      return newNode;\n    }\n  }]);\n  return TextureNode;\n}(UniformNode);\nexport default TextureNode;\nexport var texture = nodeProxy(TextureNode);\nexport var textureLoad = function textureLoad() {\n  return texture.apply(void 0, arguments).setSampler(false);\n};\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport var sampler = function sampler(aTexture) {\n  return (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\n};\naddNodeElement('texture', texture);\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass('TextureNode', TextureNode);","map":{"version":3,"names":["UniformNode","uniform","uv","textureSize","colorSpaceToLinear","expression","addNodeClass","maxMipLevel","addNodeElement","nodeProxy","vec3","nodeObject","NodeUpdateType","TextureNode","_UniformNode","_inherits","_super","_createSuper","value","_this","uvNode","arguments","length","undefined","levelNode","_classCallCheck","call","isTextureNode","compareNode","depthNode","sampler","updateMatrix","updateType","NONE","setUpdateMatrix","_createClass","key","getUniformHash","uuid","getNodeType","isDepthTexture","getInputType","getDefaultUV","channel","updateReference","getTransformedUV","texture","matrix","mul","xy","FRAME","setupUV","builder","isFlipY","isRenderTargetTexture","isFramebufferTexture","setY","y","oneMinus","setup","properties","getNodeProperties","context","forceUVContext","getUV","getTextureLevel","getTextureLevelAlgorithm","generateUV","build","generateSnippet","textureProperty","uvSnippet","levelSnippet","depthSnippet","compareSnippet","snippet","generateTextureLevel","generateTextureCompare","generateTextureLoad","generateTexture","generate","output","isTexture","Error","_get","_getPrototypeOf","prototype","isReference","nodeData","getDataFromNode","propertyName","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","concat","tempWrite","nodeType","needsColorSpaceToLinear","colorSpace","format","setSampler","getSampler","textureNode","clone","blur","level","size","compare","depth","serialize","data","toJSON","meta","deserialize","textures","update","matrixAutoUpdate","newNode","constructor","textureLoad","apply","aTexture","isNode","convert"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/accessors/TextureNode.js"],"sourcesContent":["import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass TextureNode extends UniformNode {\n\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value );\n\n\t\tthis.isTextureNode = true;\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.levelNode = levelNode;\n\t\tthis.compareNode = null;\n\t\tthis.depthNode = null;\n\n\t\tthis.sampler = true;\n\t\tthis.updateMatrix = false;\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\treturn 'vec4';\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\tupdateReference( /*frame*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\tgetTransformedUV( uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\treturn uniform( texture.matrix ).mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tuvNode = uvNode.setY( uvNode.y.oneMinus() );\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\tif ( levelNode !== null && builder.context.getTextureLevelAlgorithm !== undefined ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevelAlgorithm( this, levelNode );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, compareNode, depthNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tif ( builder.context.tempWrite !== false ) {\n\n\t\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsColorSpaceToLinear( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToLinear( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\tuv( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = uvNode;\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tblur( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = levelNode.mul( maxMipLevel( textureNode ) );\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = levelNode;\n\n\t\treturn textureNode;\n\n\t}\n\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\nexport default TextureNode;\n\nexport const texture = nodeProxy( TextureNode );\nexport const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\naddNodeElement( 'texture', texture );\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass( 'TextureNode', TextureNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}