{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { nodeProxy } from '../shadernode/ShaderNode.js';\nclass FunctionOverloadingNode extends Node {\n  constructor() {\n    let functionNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.functionNodes = functionNodes;\n    for (var _len = arguments.length, parametersNodes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      parametersNodes[_key - 1] = arguments[_key];\n    }\n    this.parametersNodes = parametersNodes;\n    this._candidateFnCall = null;\n  }\n  getNodeType() {\n    return this.functionNodes[0].shaderNode.layout.type;\n  }\n  setup(builder) {\n    const params = this.parametersNodes;\n    let candidateFnCall = this._candidateFnCall;\n    if (candidateFnCall === null) {\n      let candidateFn = null;\n      let candidateScore = -1;\n      for (const functionNode of this.functionNodes) {\n        const shaderNode = functionNode.shaderNode;\n        const layout = shaderNode.layout;\n        if (layout === null) {\n          throw new Error('FunctionOverloadingNode: FunctionNode must be a layout.');\n        }\n        const inputs = layout.inputs;\n        if (params.length === inputs.length) {\n          let score = 0;\n          for (let i = 0; i < params.length; i++) {\n            const param = params[i];\n            const input = inputs[i];\n            if (param.getNodeType(builder) === input.type) {\n              score++;\n            } else {\n              score = 0;\n            }\n          }\n          if (score > candidateScore) {\n            candidateFn = functionNode;\n            candidateScore = score;\n          }\n        }\n      }\n      this._candidateFnCall = candidateFnCall = candidateFn(...params);\n    }\n    return candidateFnCall;\n  }\n}\nexport default FunctionOverloadingNode;\nconst overloadingBaseFn = nodeProxy(FunctionOverloadingNode);\nexport const overloadingFn = functionNodes => function () {\n  for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    params[_key2] = arguments[_key2];\n  }\n  return overloadingBaseFn(functionNodes, ...params);\n};\naddNodeClass('FunctionOverloadingNode', FunctionOverloadingNode);","map":{"version":3,"names":["Node","addNodeClass","nodeProxy","FunctionOverloadingNode","constructor","functionNodes","arguments","length","undefined","_len","parametersNodes","Array","_key","_candidateFnCall","getNodeType","shaderNode","layout","type","setup","builder","params","candidateFnCall","candidateFn","candidateScore","functionNode","Error","inputs","score","i","param","input","overloadingBaseFn","overloadingFn","_len2","_key2"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/utils/FunctionOverloadingNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { nodeProxy } from '../shadernode/ShaderNode.js';\n\nclass FunctionOverloadingNode extends Node {\n\n\tconstructor( functionNodes = [], ...parametersNodes ) {\n\n\t\tsuper();\n\n\t\tthis.functionNodes = functionNodes;\n\t\tthis.parametersNodes = parametersNodes;\n\n\t\tthis._candidateFnCall = null;\n\n\t}\n\n\tgetNodeType() {\n\n\t\treturn this.functionNodes[ 0 ].shaderNode.layout.type;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst params = this.parametersNodes;\n\n\t\tlet candidateFnCall = this._candidateFnCall;\n\n\t\tif ( candidateFnCall === null ) {\n\n\t\t\tlet candidateFn = null;\n\t\t\tlet candidateScore = - 1;\n\n\t\t\tfor ( const functionNode of this.functionNodes ) {\n\n\t\t\t\tconst shaderNode = functionNode.shaderNode;\n\t\t\t\tconst layout = shaderNode.layout;\n\n\t\t\t\tif ( layout === null ) {\n\n\t\t\t\t\tthrow new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst inputs = layout.inputs;\n\n\t\t\t\tif ( params.length === inputs.length ) {\n\n\t\t\t\t\tlet score = 0;\n\n\t\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\t\tconst param = params[ i ];\n\t\t\t\t\t\tconst input = inputs[ i ];\n\n\t\t\t\t\t\tif ( param.getNodeType( builder ) === input.type ) {\n\n\t\t\t\t\t\t\tscore ++;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscore = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( score > candidateScore ) {\n\n\t\t\t\t\t\tcandidateFn = functionNode;\n\t\t\t\t\t\tcandidateScore = score;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._candidateFnCall = candidateFnCall = candidateFn( ...params );\n\n\t\t}\n\n\t\treturn candidateFnCall;\n\n\t}\n\n}\n\nexport default FunctionOverloadingNode;\n\nconst overloadingBaseFn = nodeProxy( FunctionOverloadingNode );\n\nexport const overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );\n\naddNodeClass( 'FunctionOverloadingNode', FunctionOverloadingNode );\n"],"mappings":"AAAA,OAAOA,IAAI,IAAIC,YAAY,QAAQ,iBAAiB;AACpD,SAASC,SAAS,QAAQ,6BAA6B;AAEvD,MAAMC,uBAAuB,SAASH,IAAI,CAAC;EAE1CI,WAAWA,CAAA,EAA2C;IAAA,IAAzCC,aAAa,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IAE9B,KAAK,CAAC,CAAC;IAEP,IAAI,CAACD,aAAa,GAAGA,aAAa;IAAC,SAAAI,IAAA,GAAAH,SAAA,CAAAC,MAAA,EAJAG,eAAe,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAAfF,eAAe,CAAAE,IAAA,QAAAN,SAAA,CAAAM,IAAA;IAAA;IAKlD,IAAI,CAACF,eAAe,GAAGA,eAAe;IAEtC,IAAI,CAACG,gBAAgB,GAAG,IAAI;EAE7B;EAEAC,WAAWA,CAAA,EAAG;IAEb,OAAO,IAAI,CAACT,aAAa,CAAE,CAAC,CAAE,CAACU,UAAU,CAACC,MAAM,CAACC,IAAI;EAEtD;EAEAC,KAAKA,CAAEC,OAAO,EAAG;IAEhB,MAAMC,MAAM,GAAG,IAAI,CAACV,eAAe;IAEnC,IAAIW,eAAe,GAAG,IAAI,CAACR,gBAAgB;IAE3C,IAAKQ,eAAe,KAAK,IAAI,EAAG;MAE/B,IAAIC,WAAW,GAAG,IAAI;MACtB,IAAIC,cAAc,GAAG,CAAE,CAAC;MAExB,KAAM,MAAMC,YAAY,IAAI,IAAI,CAACnB,aAAa,EAAG;QAEhD,MAAMU,UAAU,GAAGS,YAAY,CAACT,UAAU;QAC1C,MAAMC,MAAM,GAAGD,UAAU,CAACC,MAAM;QAEhC,IAAKA,MAAM,KAAK,IAAI,EAAG;UAEtB,MAAM,IAAIS,KAAK,CAAE,yDAA0D,CAAC;QAE7E;QAEA,MAAMC,MAAM,GAAGV,MAAM,CAACU,MAAM;QAE5B,IAAKN,MAAM,CAACb,MAAM,KAAKmB,MAAM,CAACnB,MAAM,EAAG;UAEtC,IAAIoB,KAAK,GAAG,CAAC;UAEb,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,CAACb,MAAM,EAAEqB,CAAC,EAAG,EAAG;YAE1C,MAAMC,KAAK,GAAGT,MAAM,CAAEQ,CAAC,CAAE;YACzB,MAAME,KAAK,GAAGJ,MAAM,CAAEE,CAAC,CAAE;YAEzB,IAAKC,KAAK,CAACf,WAAW,CAAEK,OAAQ,CAAC,KAAKW,KAAK,CAACb,IAAI,EAAG;cAElDU,KAAK,EAAG;YAET,CAAC,MAAM;cAENA,KAAK,GAAG,CAAC;YAEV;UAED;UAEA,IAAKA,KAAK,GAAGJ,cAAc,EAAG;YAE7BD,WAAW,GAAGE,YAAY;YAC1BD,cAAc,GAAGI,KAAK;UAEvB;QAED;MAED;MAEA,IAAI,CAACd,gBAAgB,GAAGQ,eAAe,GAAGC,WAAW,CAAE,GAAGF,MAAO,CAAC;IAEnE;IAEA,OAAOC,eAAe;EAEvB;AAED;AAEA,eAAelB,uBAAuB;AAEtC,MAAM4B,iBAAiB,GAAG7B,SAAS,CAAEC,uBAAwB,CAAC;AAE9D,OAAO,MAAM6B,aAAa,GAAK3B,aAAa,IAAM;EAAA,SAAA4B,KAAA,GAAA3B,SAAA,CAAAC,MAAA,EAAKa,MAAM,OAAAT,KAAA,CAAAsB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAANd,MAAM,CAAAc,KAAA,IAAA5B,SAAA,CAAA4B,KAAA;EAAA;EAAA,OAAMH,iBAAiB,CAAE1B,aAAa,EAAE,GAAGe,MAAO,CAAC;AAAA;AAEhHnB,YAAY,CAAE,yBAAyB,EAAEE,uBAAwB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}