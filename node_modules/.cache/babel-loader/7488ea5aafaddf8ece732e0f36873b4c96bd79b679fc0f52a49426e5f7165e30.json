{"ast":null,"code":"import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { temp } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property, varyingProperty } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor, materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth } from '../accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { mix, smoothstep } from '../math/MathNode.js';\nimport { tslFn, float, vec2, vec3, vec4, If } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { dashSize, gapSize } from '../core/PropertyNode.js';\nimport { LineDashedMaterial } from 'three';\nconst defaultValues = new LineDashedMaterial();\nclass Line2NodeMaterial extends NodeMaterial {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.normals = false;\n    this.lights = false;\n    this.setDefaultValues(defaultValues);\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.useDash = params.dashed;\n    this.useWorldUnits = false;\n    this.dashOffset = 0;\n    this.lineWidth = 1;\n    this.lineColorNode = null;\n    this.offsetNode = null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    this.gapSizeNode = null;\n    this.setupShaders();\n    this.setValues(params);\n  }\n  setupShaders() {\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    const useDash = this.dashed;\n    const useWorldUnits = this.worldUnits;\n    const trimSegment = tslFn(_ref => {\n      let {\n        start,\n        end\n      } = _ref;\n      const a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column\n      const b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column\n      const nearEstimate = b.mul(-0.5).div(a);\n      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));\n      return vec4(mix(start.xyz, end.xyz, alpha), end.w);\n    });\n    this.vertexNode = tslFn(() => {\n      varyingProperty('vec2', 'vUv').assign(uv());\n      const instanceStart = attribute('instanceStart');\n      const instanceEnd = attribute('instanceEnd');\n\n      // camera space\n\n      const start = property('vec4', 'start');\n      const end = property('vec4', 'end');\n      start.assign(modelViewMatrix.mul(vec4(instanceStart, 1.0))); // force assignment into correct place in flow\n      end.assign(modelViewMatrix.mul(vec4(instanceEnd, 1.0)));\n      if (useWorldUnits) {\n        varyingProperty('vec3', 'worldStart').assign(start.xyz);\n        varyingProperty('vec3', 'worldEnd').assign(end.xyz);\n      }\n      const aspect = viewport.z.div(viewport.w);\n\n      // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n      // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n      // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n      // perhaps there is a more elegant solution -- WestLangley\n\n      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column\n\n      If(perspective, () => {\n        If(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), () => {\n          end.assign(trimSegment({\n            start: start,\n            end: end\n          }));\n        }).elseif(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), () => {\n          start.assign(trimSegment({\n            start: end,\n            end: start\n          }));\n        });\n      });\n\n      // clip space\n      const clipStart = cameraProjectionMatrix.mul(start);\n      const clipEnd = cameraProjectionMatrix.mul(end);\n\n      // ndc space\n      const ndcStart = clipStart.xyz.div(clipStart.w);\n      const ndcEnd = clipEnd.xyz.div(clipEnd.w);\n\n      // direction\n      const dir = ndcEnd.xy.sub(ndcStart.xy).temp();\n\n      // account for clip-space aspect ratio\n      dir.x.assign(dir.x.mul(aspect));\n      dir.assign(dir.normalize());\n      const clip = temp(vec4());\n      if (useWorldUnits) {\n        // get the offset direction as perpendicular to the view vector\n\n        const worldDir = end.xyz.sub(start.xyz).normalize();\n        const tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();\n        const worldUp = worldDir.cross(tmpFwd).normalize();\n        const worldFwd = worldDir.cross(worldUp);\n        const worldPos = varyingProperty('vec4', 'worldPos');\n        worldPos.assign(positionGeometry.y.lessThan(0.5).cond(start, end));\n\n        // height offset\n        const hw = materialLineWidth.mul(0.5);\n        worldPos.addAssign(vec4(positionGeometry.x.lessThan(0.0).cond(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));\n\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        if (!useDash) {\n          // cap extension\n          worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).cond(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));\n\n          // add width to the box\n          worldPos.addAssign(vec4(worldFwd.mul(hw), 0));\n\n          // endcaps\n          If(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), () => {\n            worldPos.subAssign(vec4(worldFwd.mul(2.0).mul(hw), 0));\n          });\n        }\n\n        // project the worldpos\n        clip.assign(cameraProjectionMatrix.mul(worldPos));\n\n        // shift the depth of the projected points so the line\n        // segments overlap neatly\n        const clipPose = temp(vec3());\n        clipPose.assign(positionGeometry.y.lessThan(0.5).cond(ndcStart, ndcEnd));\n        clip.z.assign(clipPose.z.mul(clip.w));\n      } else {\n        const offset = property('vec2', 'offset');\n        offset.assign(vec2(dir.y, dir.x.negate()));\n\n        // undo aspect ratio adjustment\n        dir.x.assign(dir.x.div(aspect));\n        offset.x.assign(offset.x.div(aspect));\n\n        // sign flip\n        offset.assign(positionGeometry.x.lessThan(0.0).cond(offset.negate(), offset));\n\n        // endcaps\n        If(positionGeometry.y.lessThan(0.0), () => {\n          offset.assign(offset.sub(dir));\n        }).elseif(positionGeometry.y.greaterThan(1.0), () => {\n          offset.assign(offset.add(dir));\n        });\n\n        // adjust for linewidth\n        offset.assign(offset.mul(materialLineWidth));\n\n        // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n        offset.assign(offset.div(viewport.w));\n\n        // select end\n        clip.assign(positionGeometry.y.lessThan(0.5).cond(clipStart, clipEnd));\n\n        // back to clip space\n        offset.assign(offset.mul(clip.w));\n        clip.assign(clip.add(vec4(offset, 0, 0)));\n      }\n      return clip;\n    })();\n    const closestLineToLine = tslFn(_ref2 => {\n      let {\n        p1,\n        p2,\n        p3,\n        p4\n      } = _ref2;\n      const p13 = p1.sub(p3);\n      const p43 = p4.sub(p3);\n      const p21 = p2.sub(p1);\n      const d1343 = p13.dot(p43);\n      const d4321 = p43.dot(p21);\n      const d1321 = p13.dot(p21);\n      const d4343 = p43.dot(p43);\n      const d2121 = p21.dot(p21);\n      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));\n      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));\n      const mua = numer.div(denom).clamp();\n      const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();\n      return vec2(mua, mub);\n    });\n    this.fragmentNode = tslFn(() => {\n      const vUv = varyingProperty('vec2', 'vUv');\n      if (useDash) {\n        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;\n        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n        dashSize.assign(dashSizeNode);\n        gapSize.assign(gapSizeNode);\n        const instanceDistanceStart = attribute('instanceDistanceStart');\n        const instanceDistanceEnd = attribute('instanceDistanceEnd');\n        const lineDistance = positionGeometry.y.lessThan(0.5).cond(dashScaleNode.mul(instanceDistanceStart), materialLineScale.mul(instanceDistanceEnd));\n        const vLineDistance = varying(lineDistance.add(materialLineDashOffset));\n        const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;\n        vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard(); // discard endcaps\n        vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard(); // todo - FIX\n      }\n\n      // force assignment into correct place in flow\n      const alpha = property('float', 'alpha');\n      alpha.assign(1);\n      if (useWorldUnits) {\n        const worldStart = varyingProperty('vec3', 'worldStart');\n        const worldEnd = varyingProperty('vec3', 'worldEnd');\n\n        // Find the closest points on the view ray and the line segment\n        const rayEnd = varyingProperty('vec4', 'worldPos').xyz.normalize().mul(1e5);\n        const lineDir = worldEnd.sub(worldStart);\n        const params = closestLineToLine({\n          p1: worldStart,\n          p2: worldEnd,\n          p3: vec3(0.0, 0.0, 0.0),\n          p4: rayEnd\n        });\n        const p1 = worldStart.add(lineDir.mul(params.x));\n        const p2 = rayEnd.mul(params.y);\n        const delta = p1.sub(p2);\n        const len = delta.length();\n        const norm = len.div(materialLineWidth);\n        if (!useDash) {\n          if (useAlphaToCoverage) {\n            const dnorm = norm.fwidth();\n            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());\n          } else {\n            norm.greaterThan(0.5).discard();\n          }\n        }\n      } else {\n        // round endcaps\n\n        if (useAlphaToCoverage) {\n          const a = vUv.x;\n          const b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n          const len2 = a.mul(a).add(b.mul(b));\n\n          // force assignment out of following 'if' statement - to avoid uniform control flow errors\n          const dlen = property('float', 'dlen');\n          dlen.assign(len2.fwidth());\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n          });\n        } else {\n          If(vUv.y.abs().greaterThan(1.0), () => {\n            const a = vUv.x;\n            const b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n            const len2 = a.mul(a).add(b.mul(b));\n            len2.greaterThan(1.0).discard();\n          });\n        }\n      }\n      let lineColorNode;\n      if (this.lineColorNode) {\n        lineColorNode = this.lineColorNode;\n      } else {\n        if (useColor) {\n          const instanceColorStart = attribute('instanceColorStart');\n          const instanceColorEnd = attribute('instanceColorEnd');\n          const instanceColor = positionGeometry.y.lessThan(0.5).cond(instanceColorStart, instanceColorEnd);\n          lineColorNode = instanceColor.mul(materialColor);\n        } else {\n          lineColorNode = materialColor;\n        }\n      }\n      return vec4(lineColorNode, alpha);\n    })();\n    this.needsUpdate = true;\n  }\n  get worldUnits() {\n    return this.useWorldUnits;\n  }\n  set worldUnits(value) {\n    if (this.useWorldUnits !== value) {\n      this.useWorldUnits = value;\n      this.setupShaders();\n    }\n  }\n  get dashed() {\n    return this.useDash;\n  }\n  set dashed(value) {\n    if (this.useDash !== value) {\n      this.useDash = value;\n      this.setupShaders();\n    }\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.setupShaders();\n    }\n  }\n}\nexport default Line2NodeMaterial;\naddNodeMaterial('Line2NodeMaterial', Line2NodeMaterial);","map":{"version":3,"names":["NodeMaterial","addNodeMaterial","temp","varying","property","varyingProperty","attribute","cameraProjectionMatrix","materialColor","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineDashOffset","materialLineWidth","modelViewMatrix","positionGeometry","mix","smoothstep","tslFn","float","vec2","vec3","vec4","If","uv","viewport","dashSize","gapSize","LineDashedMaterial","defaultValues","Line2NodeMaterial","constructor","params","arguments","length","undefined","normals","lights","setDefaultValues","useAlphaToCoverage","useColor","vertexColors","useDash","dashed","useWorldUnits","dashOffset","lineWidth","lineColorNode","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","setupShaders","setValues","alphaToCoverage","worldUnits","trimSegment","_ref","start","end","a","element","b","nearEstimate","mul","div","alpha","sub","z","xyz","w","vertexNode","assign","instanceStart","instanceEnd","aspect","perspective","equal","lessThan","and","greaterThan","elseif","greaterThanEqual","clipStart","clipEnd","ndcStart","ndcEnd","dir","xy","x","normalize","clip","worldDir","tmpFwd","worldUp","cross","worldFwd","worldPos","y","cond","hw","addAssign","negate","or","subAssign","clipPose","offset","add","closestLineToLine","_ref2","p1","p2","p3","p4","p13","p43","p21","d1343","dot","d4321","d1321","d4343","d2121","denom","numer","mua","clamp","mub","fragmentNode","vUv","offsetNodeNode","dashGapNode","instanceDistanceStart","instanceDistanceEnd","lineDistance","vLineDistance","vLineDistanceOffset","discard","mod","worldStart","worldEnd","rayEnd","lineDir","delta","len","norm","dnorm","fwidth","oneMinus","len2","dlen","abs","instanceColorStart","instanceColorEnd","instanceColor","needsUpdate","value"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/materials/Line2NodeMaterial.js"],"sourcesContent":["import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { temp } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property, varyingProperty } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor, materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth } from '../accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { mix, smoothstep } from '../math/MathNode.js';\nimport { tslFn, float, vec2, vec3, vec4, If } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { dashSize, gapSize } from '../core/PropertyNode.js';\n\nimport { LineDashedMaterial } from 'three';\n\nconst defaultValues = new LineDashedMaterial();\n\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.normals = false;\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.useAlphaToCoverage = true;\n\t\tthis.useColor = params.vertexColors;\n\t\tthis.useDash = params.dashed;\n\t\tthis.useWorldUnits = false;\n\n\t\tthis.dashOffset = 0;\n\t\tthis.lineWidth = 1;\n\n\t\tthis.lineColorNode = null;\n\n\t\tthis.offsetNode = null;\n\t\tthis.dashScaleNode = null;\n\t\tthis.dashSizeNode = null;\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setupShaders();\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetupShaders() {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this.dashed;\n\t\tconst useWorldUnits = this.worldUnits;\n\n\t\tconst trimSegment = tslFn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( - 0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} );\n\n\t\tthis.vertexNode = tslFn( () => {\n\n\t\t\tvaryingProperty( 'vec2', 'vUv' ).assign( uv() );\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = property( 'vec4', 'start' );\n\t\t\tconst end = property( 'vec4', 'end' );\n\n\t\t\tstart.assign( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ); // force assignment into correct place in flow\n\t\t\tend.assign( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tvaryingProperty( 'vec3', 'worldStart' ).assign( start.xyz );\n\t\t\t\tvaryingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tIf( perspective, () => {\n\n\t\t\t\tIf( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\t\tend.assign( trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).elseif( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\t\tstart.assign( trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy ).temp();\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x.assign( dir.x.mul( aspect ) );\n\t\t\tdir.assign( dir.normalize() );\n\n\t\t\tconst clip = temp( vec4() );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\t\t\t\tconst tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();\n\t\t\t\tconst worldUp = worldDir.cross( tmpFwd ).normalize();\n\t\t\t\tconst worldFwd = worldDir.cross( worldUp );\n\n\t\t\t\tconst worldPos = varyingProperty( 'vec4', 'worldPos' );\n\n\t\t\t\tworldPos.assign( positionGeometry.y.lessThan( 0.5 ).cond( start, end) );\n\n\t\t\t\t// height offset\n\t\t\t\tconst hw = materialLineWidth.mul( 0.5 );\n\t\t\t\tworldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).cond( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).cond( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tIf( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {\n\n\t\t\t\t\t\tworldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// project the worldpos\n\t\t\t\tclip.assign( cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = temp( vec3() );\n\n\t\t\t\tclipPose.assign( positionGeometry.y.lessThan( 0.5 ).cond( ndcStart, ndcEnd ) );\n\t\t\t\tclip.z.assign( clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = property( 'vec2', 'offset' );\n\n\t\t\t\toffset.assign( vec2( dir.y, dir.x.negate() ) );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x.assign( dir.x.div( aspect ) );\n\t\t\t\toffset.x.assign( offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\toffset.assign( positionGeometry.x.lessThan( 0.0 ).cond( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tIf( positionGeometry.y.lessThan( 0.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.sub( dir ) );\n\n\t\t\t\t} ).elseif( positionGeometry.y.greaterThan( 1.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset.assign( offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset.assign( offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tclip.assign( positionGeometry.y.lessThan( 0.5 ).cond( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset.assign( offset.mul( clip.w ) );\n\n\t\t\t\tclip.assign( clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} )();\n\n\t\tconst closestLineToLine = tslFn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = p13.dot( p43 );\n\t\t\tconst d4321 = p43.dot( p21 );\n\t\t\tconst d1321 = p13.dot( p21 );\n\t\t\tconst d4343 = p43.dot( p43 );\n\t\t\tconst d2121 = p21.dot( p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = numer.div( denom ).clamp();\n\t\t\tconst mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.fragmentNode = tslFn( () => {\n\n\t\t\tconst vUv = varyingProperty( 'vec2', 'vUv' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;\n\n\t\t\t\tdashSize.assign( dashSizeNode );\n\t\t\t\tgapSize.assign( gapSizeNode );\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tconst lineDistance = positionGeometry.y.lessThan( 0.5 ).cond( dashScaleNode.mul( instanceDistanceStart ), materialLineScale.mul( instanceDistanceEnd ) );\n\n\t\t\t\tconst vLineDistance = varying( lineDistance.add( materialLineDashOffset ) );\n\t\t\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\t\t\tvUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps\n\t\t\t\tvLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX\n\n\t\t\t}\n\n\t\t\t // force assignment into correct place in flow\n\t\t\tconst alpha = property( 'float', 'alpha' );\n\t\t\talpha.assign( 1 );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tconst worldStart = varyingProperty( 'vec3', 'worldStart' );\n\t\t\t\tconst worldEnd = varyingProperty( 'vec3', 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\talpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnorm.greaterThan( 0.5 ).discard();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).cond( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t// force assignment out of following 'if' statement - to avoid uniform control flow errors\n\t\t\t\t\tconst dlen = property( 'float', 'dlen' );\n\t\t\t\t\tdlen.assign( len2.fwidth() );\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).cond( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tconst instanceColor = positionGeometry.y.lessThan( 0.5 ).cond( instanceColorStart, instanceColorEnd );\n\n\t\t\t\t\tlineColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} )();\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\n\tget worldUnits() {\n\n\t\treturn this.useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this.useWorldUnits !== value ) {\n\n\t\t\tthis.useWorldUnits = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n\n\tget dashed() {\n\n\t\treturn this.useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this.useDash !== value ) {\n\n\t\t\tthis.useDash = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n}\n\nexport default Line2NodeMaterial;\n\naddNodeMaterial( 'Line2NodeMaterial', Line2NodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}