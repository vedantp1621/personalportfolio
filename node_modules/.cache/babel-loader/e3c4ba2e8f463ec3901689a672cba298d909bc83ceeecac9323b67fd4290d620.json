{"ast":null,"code":"import NodeFunction from '../core/NodeFunction.js';\nimport NodeFunctionInput from '../core/NodeFunctionInput.js';\nconst declarationRegexp = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp = /[a-z_0-9]+/ig;\nconst pragmaMain = '#pragma main';\nconst parse = source => {\n  source = source.trim();\n  const pragmaMainIndex = source.indexOf(pragmaMain);\n  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;\n  const declaration = mainCode.match(declarationRegexp);\n  if (declaration !== null && declaration.length === 5) {\n    // tokenizer\n\n    const inputsCode = declaration[4];\n    const propsMatches = [];\n    let nameMatch = null;\n    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push(nameMatch);\n    }\n\n    // parser\n\n    const inputs = [];\n    let i = 0;\n    while (i < propsMatches.length) {\n      const isConst = propsMatches[i][0] === 'const';\n      if (isConst === true) {\n        i++;\n      }\n      let qualifier = propsMatches[i][0];\n      if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n        i++;\n      } else {\n        qualifier = '';\n      }\n      const type = propsMatches[i++][0];\n      let count = Number.parseInt(propsMatches[i][0]);\n      if (Number.isNaN(count) === false) i++;else count = null;\n      const name = propsMatches[i++][0];\n      inputs.push(new NodeFunctionInput(type, name, count, qualifier, isConst));\n    }\n\n    //\n\n    const blockCode = mainCode.substring(declaration[0].length);\n    const name = declaration[3] !== undefined ? declaration[3] : '';\n    const type = declaration[2];\n    const presicion = declaration[1] !== undefined ? declaration[1] : '';\n    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : '';\n    return {\n      type,\n      inputs,\n      name,\n      presicion,\n      inputsCode,\n      blockCode,\n      headerCode\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a GLSL code.');\n  }\n};\nclass GLSLNodeFunction extends NodeFunction {\n  constructor(source) {\n    const {\n      type,\n      inputs,\n      name,\n      presicion,\n      inputsCode,\n      blockCode,\n      headerCode\n    } = parse(source);\n    super(type, inputs, name, presicion);\n    this.inputsCode = inputsCode;\n    this.blockCode = blockCode;\n    this.headerCode = headerCode;\n  }\n  getCode() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;\n    let code;\n    const blockCode = this.blockCode;\n    if (blockCode !== '') {\n      const {\n        type,\n        inputsCode,\n        headerCode,\n        presicion\n      } = this;\n      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;\n      if (presicion !== '') {\n        declarationCode = `${presicion} ${declarationCode}`;\n      }\n      code = headerCode + declarationCode + blockCode;\n    } else {\n      // interface function\n\n      code = '';\n    }\n    return code;\n  }\n}\nexport default GLSLNodeFunction;","map":{"version":3,"names":["NodeFunction","NodeFunctionInput","declarationRegexp","propertiesRegexp","pragmaMain","parse","source","trim","pragmaMainIndex","indexOf","mainCode","slice","length","declaration","match","inputsCode","propsMatches","nameMatch","exec","push","inputs","i","isConst","qualifier","type","count","Number","parseInt","isNaN","name","blockCode","substring","undefined","presicion","headerCode","Error","GLSLNodeFunction","constructor","getCode","arguments","code","declarationCode"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js"],"sourcesContent":["import NodeFunction from '../core/NodeFunction.js';\nimport NodeFunctionInput from '../core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst presicion = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tpresicion,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\nclass GLSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse( source );\n\n\t\tsuper( type, inputs, name, presicion );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, presicion } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( presicion !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ presicion } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\nexport default GLSLNodeFunction;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}