{"ast":null,"code":"import _classCallCheck from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport TextureNode from '../accessors/TextureNode.js';\nimport { nodeObject, vec2 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { viewportTopLeft } from '../display/ViewportNode.js';\nimport { Matrix4, Vector2, Vector3, Vector4, Object3D, Plane, RenderTarget, HalfFloatType, LinearMipMapLinearFilter } from 'three';\nvar _reflectorPlane = new Plane();\nvar _normal = new Vector3();\nvar _reflectorWorldPosition = new Vector3();\nvar _cameraWorldPosition = new Vector3();\nvar _rotationMatrix = new Matrix4();\nvar _lookAtPosition = new Vector3(0, 0, -1);\nvar clipPlane = new Vector4();\nvar _view = new Vector3();\nvar _target = new Vector3();\nvar _q = new Vector4();\nvar _size = new Vector2();\nvar _defaultRT = new RenderTarget();\nvar _defaultUV = vec2(viewportTopLeft.x.oneMinus(), viewportTopLeft.y);\nvar _inReflector = false;\nvar ReflectorNode = /*#__PURE__*/function (_TextureNode) {\n  _inherits(ReflectorNode, _TextureNode);\n  var _super = _createSuper(ReflectorNode);\n  function ReflectorNode() {\n    var _this;\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ReflectorNode);\n    _this = _super.call(this, _defaultRT.texture, _defaultUV);\n    var _parameters$target = parameters.target,\n      target = _parameters$target === void 0 ? new Object3D() : _parameters$target,\n      _parameters$resolutio = parameters.resolution,\n      resolution = _parameters$resolutio === void 0 ? 1 : _parameters$resolutio,\n      _parameters$generateM = parameters.generateMipmaps,\n      generateMipmaps = _parameters$generateM === void 0 ? false : _parameters$generateM,\n      _parameters$bounces = parameters.bounces,\n      bounces = _parameters$bounces === void 0 ? true : _parameters$bounces;\n\n    //\n\n    _this.target = target;\n    _this.resolution = resolution;\n    _this.generateMipmaps = generateMipmaps;\n    _this.bounces = bounces;\n    _this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n    _this.virtualCameras = new WeakMap();\n    _this.renderTargets = new WeakMap();\n    return _this;\n  }\n  _createClass(ReflectorNode, [{\n    key: \"_updateResolution\",\n    value: function _updateResolution(renderTarget, renderer) {\n      var resolution = this.resolution;\n      renderer.getDrawingBufferSize(_size);\n      renderTarget.setSize(Math.round(_size.width * resolution), Math.round(_size.height * resolution));\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(builder) {\n      this._updateResolution(_defaultRT, builder.renderer);\n      return _get(_getPrototypeOf(ReflectorNode.prototype), \"setup\", this).call(this, builder);\n    }\n  }, {\n    key: \"getTextureNode\",\n    value: function getTextureNode() {\n      return this.textureNode;\n    }\n  }, {\n    key: \"getVirtualCamera\",\n    value: function getVirtualCamera(camera) {\n      var virtualCamera = this.virtualCameras.get(camera);\n      if (virtualCamera === undefined) {\n        virtualCamera = camera.clone();\n        this.virtualCameras.set(camera, virtualCamera);\n      }\n      return virtualCamera;\n    }\n  }, {\n    key: \"getRenderTarget\",\n    value: function getRenderTarget(camera) {\n      var renderTarget = this.renderTargets.get(camera);\n      if (renderTarget === undefined) {\n        renderTarget = new RenderTarget(0, 0, {\n          type: HalfFloatType\n        });\n        if (this.generateMipmaps === true) {\n          renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n          renderTarget.texture.generateMipmaps = true;\n        }\n        this.renderTargets.set(camera, renderTarget);\n      }\n      return renderTarget;\n    }\n  }, {\n    key: \"updateBefore\",\n    value: function updateBefore(frame) {\n      if (this.bounces === false && _inReflector) return false;\n      _inReflector = true;\n      var scene = frame.scene,\n        camera = frame.camera,\n        renderer = frame.renderer,\n        material = frame.material;\n      var target = this.target;\n      var virtualCamera = this.getVirtualCamera(camera);\n      var renderTarget = this.getRenderTarget(virtualCamera);\n      renderer.getDrawingBufferSize(_size);\n      this._updateResolution(renderTarget, renderer);\n\n      //\n\n      _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);\n      _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      _rotationMatrix.extractRotation(target.matrixWorld);\n      _normal.set(0, 0, 1);\n      _normal.applyMatrix4(_rotationMatrix);\n      _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);\n\n      // Avoid rendering when reflector is facing away\n\n      if (_view.dot(_normal) > 0) return;\n      _view.reflect(_normal).negate();\n      _view.add(_reflectorWorldPosition);\n      _rotationMatrix.extractRotation(camera.matrixWorld);\n      _lookAtPosition.set(0, 0, -1);\n      _lookAtPosition.applyMatrix4(_rotationMatrix);\n      _lookAtPosition.add(_cameraWorldPosition);\n      _target.subVectors(_reflectorWorldPosition, _lookAtPosition);\n      _target.reflect(_normal).negate();\n      _target.add(_reflectorWorldPosition);\n\n      //\n\n      virtualCamera.coordinateSystem = camera.coordinateSystem;\n      virtualCamera.position.copy(_view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(_rotationMatrix);\n      virtualCamera.up.reflect(_normal);\n      virtualCamera.lookAt(_target);\n      virtualCamera.near = camera.near;\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);\n      _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      _q.z = -1.0;\n      _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));\n      var clipBias = 0;\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n\n      //\n\n      this.value = renderTarget.texture;\n      material.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      renderer.setRenderTarget(renderTarget);\n      renderer.render(scene, virtualCamera);\n      renderer.setRenderTarget(currentRenderTarget);\n      material.visible = true;\n      _inReflector = false;\n    }\n  }]);\n  return ReflectorNode;\n}(TextureNode);\nexport var reflector = function reflector(parameters) {\n  return nodeObject(new ReflectorNode(parameters));\n};\nexport default ReflectorNode;","map":{"version":3,"names":["TextureNode","nodeObject","vec2","NodeUpdateType","viewportTopLeft","Matrix4","Vector2","Vector3","Vector4","Object3D","Plane","RenderTarget","HalfFloatType","LinearMipMapLinearFilter","_reflectorPlane","_normal","_reflectorWorldPosition","_cameraWorldPosition","_rotationMatrix","_lookAtPosition","clipPlane","_view","_target","_q","_size","_defaultRT","_defaultUV","x","oneMinus","y","_inReflector","ReflectorNode","_TextureNode","_inherits","_super","_createSuper","_this","parameters","arguments","length","undefined","_classCallCheck","call","texture","_parameters$target","target","_parameters$resolutio","resolution","_parameters$generateM","generateMipmaps","_parameters$bounces","bounces","updateBeforeType","RENDER","FRAME","virtualCameras","WeakMap","renderTargets","_createClass","key","value","_updateResolution","renderTarget","renderer","getDrawingBufferSize","setSize","Math","round","width","height","setup","builder","_get","_getPrototypeOf","prototype","getTextureNode","textureNode","getVirtualCamera","camera","virtualCamera","get","clone","set","getRenderTarget","type","minFilter","updateBefore","frame","scene","material","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","dot","reflect","negate","add","coordinateSystem","position","copy","up","lookAt","near","far","updateMatrixWorld","projectionMatrix","setFromNormalAndCoplanarPoint","matrixWorldInverse","normal","z","constant","sign","elements","w","multiplyScalar","clipBias","visible","currentRenderTarget","setRenderTarget","render","reflector"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/utils/ReflectorNode.js"],"sourcesContent":["import TextureNode from '../accessors/TextureNode.js';\nimport { nodeObject, vec2 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { viewportTopLeft } from '../display/ViewportNode.js';\nimport { Matrix4, Vector2, Vector3, Vector4, Object3D, Plane, RenderTarget, HalfFloatType, LinearMipMapLinearFilter } from 'three';\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = vec2( viewportTopLeft.x.oneMinus(), viewportTopLeft.y );\n\nlet _inReflector = false;\n\nclass ReflectorNode extends TextureNode {\n\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( _defaultRT.texture, _defaultUV );\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true\n\t\t} = parameters;\n\n\t\t//\n\n\t\tthis.target = target;\n\t\tthis.resolution = resolution;\n\t\tthis.generateMipmaps = generateMipmaps;\n\t\tthis.bounces = bounces;\n\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\tthis.virtualCameras = new WeakMap();\n\t\tthis.renderTargets = new WeakMap();\n\n\n\t}\n\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\trenderTarget.setSize( Math.round( _size.width * resolution ), Math.round( _size.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgetTextureNode() {\n\n\t\treturn this.textureNode;\n\n\t}\n\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t    renderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t    renderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return false;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( _view.dot( _normal ) > 0 ) return;\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.value = renderTarget.texture;\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t}\n\n}\n\nexport const reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\nexport default ReflectorNode;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}