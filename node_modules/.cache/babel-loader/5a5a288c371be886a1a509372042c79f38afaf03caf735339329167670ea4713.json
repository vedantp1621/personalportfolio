{"ast":null,"code":"import _toConsumableArray from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport ParameterNode from './ParameterNode.js';\nimport FunctionNode from '../code/FunctionNode.js';\nimport { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\nimport { FloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform, ColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform } from '../../renderers/common/nodes/NodeUniform.js';\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\nimport { stack } from './StackNode.js';\nimport { getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\nvar uniformsGroupCache = new ChainMap();\nvar typeFromLength = new Map([[2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nvar typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nvar toFloat = function toFloat(value) {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nvar NodeBuilder = /*#__PURE__*/function () {\n  function NodeBuilder(object, renderer, parser) {\n    var scene = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var material = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    _classCallCheck(this, NodeBuilder);\n    this.object = object;\n    this.material = material || object && object.material || null;\n    this.geometry = object && object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.scene = scene;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.hashNodes = {};\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.toneMappingNode = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: []\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.bindings = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindingsOffset = {\n      vertex: 0,\n      fragment: 0,\n      compute: 0\n    };\n    this.bindingsArray = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.codes = {};\n    this.vars = {};\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.stacks = [];\n    this.tab = '\\t';\n    this.currentFunctionNode = null;\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: this.material\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n  }\n  _createClass(NodeBuilder, [{\n    key: \"getRenderTarget\",\n    value: function getRenderTarget(width, height, options) {\n      return new RenderTarget(width, height, options);\n    }\n  }, {\n    key: \"getCubeRenderTarget\",\n    value: function getCubeRenderTarget(size, options) {\n      return new CubeRenderTarget(size, options);\n    }\n  }, {\n    key: \"includes\",\n    value: function includes(node) {\n      return this.nodes.includes(node);\n    }\n  }, {\n    key: \"_getSharedBindings\",\n    value: function _getSharedBindings(bindings) {\n      var shared = [];\n      var _iterator = _createForOfIteratorHelper(bindings),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var binding = _step.value;\n          if (binding.shared === true) {\n            // nodes is the chainmap key\n            var nodes = binding.getNodes();\n            var sharedBinding = uniformsGroupCache.get(nodes);\n            if (sharedBinding === undefined) {\n              uniformsGroupCache.set(nodes, binding);\n              sharedBinding = binding;\n            }\n            shared.push(sharedBinding);\n          } else {\n            shared.push(binding);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return shared;\n    }\n  }, {\n    key: \"getBindings\",\n    value: function getBindings() {\n      var bindingsArray = this.bindingsArray;\n      if (bindingsArray === null) {\n        var bindings = this.bindings;\n        this.bindingsArray = bindingsArray = this._getSharedBindings(this.material !== null ? [].concat(_toConsumableArray(bindings.vertex), _toConsumableArray(bindings.fragment)) : bindings.compute);\n      }\n      return bindingsArray;\n    }\n  }, {\n    key: \"setHashNode\",\n    value: function setHashNode(node, hash) {\n      this.hashNodes[hash] = node;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      if (this.nodes.includes(node) === false) {\n        this.nodes.push(node);\n        this.setHashNode(node, node.getHash(this));\n      }\n    }\n  }, {\n    key: \"buildUpdateNodes\",\n    value: function buildUpdateNodes() {\n      var _iterator2 = _createForOfIteratorHelper(this.nodes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var node = _step2.value;\n          var updateType = node.getUpdateType();\n          var updateBeforeType = node.getUpdateBeforeType();\n          if (updateType !== NodeUpdateType.NONE) {\n            this.updateNodes.push(node.getSelf());\n          }\n          if (updateBeforeType !== NodeUpdateType.NONE) {\n            this.updateBeforeNodes.push(node);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"currentNode\",\n    get: function get() {\n      return this.chaining[this.chaining.length - 1];\n    }\n  }, {\n    key: \"addChain\",\n    value: function addChain(node) {\n      /*\n      if ( this.chaining.indexOf( node ) !== - 1 ) {\n      \t\tconsole.warn( 'Recursive node: ', node );\n      \t}\n      */\n\n      this.chaining.push(node);\n    }\n  }, {\n    key: \"removeChain\",\n    value: function removeChain(node) {\n      var lastChain = this.chaining.pop();\n      if (lastChain !== node) {\n        throw new Error('NodeBuilder: Invalid node chaining!');\n      }\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getNodeFromHash\",\n    value: function getNodeFromHash(hash) {\n      return this.hashNodes[hash];\n    }\n  }, {\n    key: \"addFlow\",\n    value: function addFlow(shaderStage, node) {\n      this.flowNodes[shaderStage].push(node);\n      return node;\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context) {\n      this.context = context;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context;\n    }\n  }, {\n    key: \"setCache\",\n    value: function setCache(cache) {\n      this.cache = cache;\n    }\n  }, {\n    key: \"getCache\",\n    value: function getCache() {\n      return this.cache;\n    }\n  }, {\n    key: \"isAvailable\",\n    value: function isAvailable( /*name*/\n    ) {\n      return false;\n    }\n  }, {\n    key: \"getVertexIndex\",\n    value: function getVertexIndex() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getInstanceIndex\",\n    value: function getInstanceIndex() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getFrontFacing\",\n    value: function getFrontFacing() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getFragCoord\",\n    value: function getFragCoord() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"isFlipY\",\n    value: function isFlipY() {\n      return false;\n    }\n  }, {\n    key: \"generateTexture\",\n    value: function generateTexture( /* texture, textureProperty, uvSnippet */\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"generateTextureLod\",\n    value: function generateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"generateConst\",\n    value: function generateConst(type) {\n      var _this = this;\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (value === null) {\n        if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n      }\n      if (type === 'float') return toFloat(value);\n      if (type === 'int') return \"\".concat(Math.round(value));\n      if (type === 'uint') return value >= 0 ? \"\".concat(Math.round(value), \"u\") : '0u';\n      if (type === 'bool') return value ? 'true' : 'false';\n      if (type === 'color') return \"\".concat(this.getType('vec3'), \"( \").concat(toFloat(value.r), \", \").concat(toFloat(value.g), \", \").concat(toFloat(value.b), \" )\");\n      var typeLength = this.getTypeLength(type);\n      var componentType = this.getComponentType(type);\n      var generateConst = function generateConst(value) {\n        return _this.generateConst(componentType, value);\n      };\n      if (typeLength === 2) {\n        return \"\".concat(this.getType(type), \"( \").concat(generateConst(value.x), \", \").concat(generateConst(value.y), \" )\");\n      } else if (typeLength === 3) {\n        return \"\".concat(this.getType(type), \"( \").concat(generateConst(value.x), \", \").concat(generateConst(value.y), \", \").concat(generateConst(value.z), \" )\");\n      } else if (typeLength === 4) {\n        return \"\".concat(this.getType(type), \"( \").concat(generateConst(value.x), \", \").concat(generateConst(value.y), \", \").concat(generateConst(value.z), \", \").concat(generateConst(value.w), \" )\");\n      } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n        return \"\".concat(this.getType(type), \"( \").concat(value.elements.map(generateConst).join(', '), \" )\");\n      } else if (typeLength > 4) {\n        return \"\".concat(this.getType(type), \"()\");\n      }\n      throw new Error(\"NodeBuilder: Type '\".concat(type, \"' not found in generate constant attempt.\"));\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(type) {\n      if (type === 'color') return 'vec3';\n      return type;\n    }\n  }, {\n    key: \"generateMethod\",\n    value: function generateMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"hasGeometryAttribute\",\n    value: function hasGeometryAttribute(name) {\n      return this.geometry && this.geometry.getAttribute(name) !== undefined;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name, type) {\n      var attributes = this.attributes;\n\n      // find attribute\n      var _iterator3 = _createForOfIteratorHelper(attributes),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _attribute = _step3.value;\n          if (_attribute.name === name) {\n            return _attribute;\n          }\n        }\n\n        // create a new if no exist\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var attribute = new NodeAttribute(name, type);\n      attributes.push(attribute);\n      return attribute;\n    }\n  }, {\n    key: \"getPropertyName\",\n    value: function getPropertyName(node /*, shaderStage*/) {\n      return node.name;\n    }\n  }, {\n    key: \"isVector\",\n    value: function isVector(type) {\n      return /vec\\d/.test(type);\n    }\n  }, {\n    key: \"isMatrix\",\n    value: function isMatrix(type) {\n      return /mat\\d/.test(type);\n    }\n  }, {\n    key: \"isReference\",\n    value: function isReference(type) {\n      return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture';\n    }\n  }, {\n    key: \"needsColorSpaceToLinear\",\n    value: function needsColorSpaceToLinear( /*texture*/\n    ) {\n      return false;\n    }\n\n    /** @deprecated, r152 */\n  }, {\n    key: \"getTextureEncodingFromMap\",\n    value: function getTextureEncodingFromMap(map) {\n      console.warn('THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.');\n      return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n    }\n  }, {\n    key: \"getTextureColorSpaceFromMap\",\n    value: function getTextureColorSpaceFromMap(map) {\n      var colorSpace;\n      if (map && map.isTexture) {\n        colorSpace = map.colorSpace;\n      } else if (map && map.isWebGLRenderTarget) {\n        colorSpace = map.texture.colorSpace;\n      } else {\n        colorSpace = NoColorSpace;\n      }\n      return colorSpace;\n    }\n  }, {\n    key: \"getComponentType\",\n    value: function getComponentType(type) {\n      type = this.getVectorType(type);\n      if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n      var componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n      if (componentType === null) return null;\n      if (componentType[1] === 'b') return 'bool';\n      if (componentType[1] === 'i') return 'int';\n      if (componentType[1] === 'u') return 'uint';\n      return 'float';\n    }\n  }, {\n    key: \"getVectorType\",\n    value: function getVectorType(type) {\n      if (type === 'color') return 'vec3';\n      if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture') return 'vec4';\n      return type;\n    }\n  }, {\n    key: \"getTypeFromLength\",\n    value: function getTypeFromLength(length) {\n      var componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n      if (length === 1) return componentType;\n      var baseType = typeFromLength.get(length);\n      var prefix = componentType === 'float' ? '' : componentType[0];\n      return prefix + baseType;\n    }\n  }, {\n    key: \"getTypeFromArray\",\n    value: function getTypeFromArray(array) {\n      return typeFromArray.get(array.constructor);\n    }\n  }, {\n    key: \"getTypeFromAttribute\",\n    value: function getTypeFromAttribute(attribute) {\n      var dataAttribute = attribute;\n      if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n      var array = dataAttribute.array;\n      var itemSize = attribute.itemSize;\n      var normalized = attribute.normalized;\n      var arrayType;\n      if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n        arrayType = this.getTypeFromArray(array);\n      }\n      return this.getTypeFromLength(itemSize, arrayType);\n    }\n  }, {\n    key: \"getTypeLength\",\n    value: function getTypeLength(type) {\n      var vecType = this.getVectorType(type);\n      var vecNum = /vec([2-4])/.exec(vecType);\n      if (vecNum !== null) return Number(vecNum[1]);\n      if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n      if (/mat2/.test(type) === true) return 4;\n      if (/mat3/.test(type) === true) return 9;\n      if (/mat4/.test(type) === true) return 16;\n      return 0;\n    }\n  }, {\n    key: \"getVectorFromMatrix\",\n    value: function getVectorFromMatrix(type) {\n      return type.replace('mat', 'vec');\n    }\n  }, {\n    key: \"changeComponentType\",\n    value: function changeComponentType(type, newComponentType) {\n      return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n    }\n  }, {\n    key: \"getIntegerType\",\n    value: function getIntegerType(type) {\n      var componentType = this.getComponentType(type);\n      if (componentType === 'int' || componentType === 'uint') return type;\n      return this.changeComponentType(type, 'int');\n    }\n  }, {\n    key: \"addStack\",\n    value: function addStack() {\n      this.stack = stack(this.stack);\n      this.stacks.push(getCurrentStack() || this.stack);\n      setCurrentStack(this.stack);\n      return this.stack;\n    }\n  }, {\n    key: \"removeStack\",\n    value: function removeStack() {\n      var lastStack = this.stack;\n      this.stack = lastStack.parent;\n      setCurrentStack(this.stacks.pop());\n      return lastStack;\n    }\n  }, {\n    key: \"getDataFromNode\",\n    value: function getDataFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      cache = cache === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache;\n      var nodeData = cache.getNodeData(node);\n      if (nodeData === undefined) {\n        nodeData = {};\n        cache.setNodeData(node, nodeData);\n      }\n      if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n      return nodeData[shaderStage];\n    }\n  }, {\n    key: \"getNodeProperties\",\n    value: function getNodeProperties(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      return nodeData.properties || (nodeData.properties = {\n        outputNode: null\n      });\n    }\n  }, {\n    key: \"getBufferAttributeFromNode\",\n    value: function getBufferAttributeFromNode(node, type) {\n      var nodeData = this.getDataFromNode(node);\n      var bufferAttribute = nodeData.bufferAttribute;\n      if (bufferAttribute === undefined) {\n        var index = this.uniforms.index++;\n        bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n        this.bufferAttributes.push(bufferAttribute);\n        nodeData.bufferAttribute = bufferAttribute;\n      }\n      return bufferAttribute;\n    }\n  }, {\n    key: \"getStructTypeFromNode\",\n    value: function getStructTypeFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      if (nodeData.structType === undefined) {\n        var index = this.structs.index++;\n        node.name = \"StructType\".concat(index);\n        this.structs[shaderStage].push(node);\n        nodeData.structType = node;\n      }\n      return node;\n    }\n  }, {\n    key: \"getUniformFromNode\",\n    value: function getUniformFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n      var nodeUniform = nodeData.uniform;\n      if (nodeUniform === undefined) {\n        var index = this.uniforms.index++;\n        nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n        this.uniforms[shaderStage].push(nodeUniform);\n        nodeData.uniform = nodeUniform;\n      }\n      return nodeUniform;\n    }\n  }, {\n    key: \"getVarFromNode\",\n    value: function getVarFromNode(node) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);\n      var shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeVar = nodeData.variable;\n      if (nodeVar === undefined) {\n        var vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);\n        if (name === null) name = 'nodeVar' + vars.length;\n        nodeVar = new NodeVar(name, type);\n        vars.push(nodeVar);\n        nodeData.variable = nodeVar;\n      }\n      return nodeVar;\n    }\n  }, {\n    key: \"getVaryingFromNode\",\n    value: function getVaryingFromNode(node) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);\n      var nodeData = this.getDataFromNode(node, 'any');\n      var nodeVarying = nodeData.varying;\n      if (nodeVarying === undefined) {\n        var varyings = this.varyings;\n        var index = varyings.length;\n        if (name === null) name = 'nodeVarying' + index;\n        nodeVarying = new NodeVarying(name, type);\n        varyings.push(nodeVarying);\n        nodeData.varying = nodeVarying;\n      }\n      return nodeVarying;\n    }\n  }, {\n    key: \"getCodeFromNode\",\n    value: function getCodeFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node);\n      var nodeCode = nodeData.code;\n      if (nodeCode === undefined) {\n        var codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);\n        var index = codes.length;\n        nodeCode = new NodeCode('nodeCode' + index, type);\n        codes.push(nodeCode);\n        nodeData.code = nodeCode;\n      }\n      return nodeCode;\n    }\n  }, {\n    key: \"addLineFlowCode\",\n    value: function addLineFlowCode(code) {\n      if (code === '') return this;\n      code = this.tab + code;\n      if (!/;\\s*$/.test(code)) {\n        code = code + ';\\n';\n      }\n      this.flow.code += code;\n      return this;\n    }\n  }, {\n    key: \"addFlowCode\",\n    value: function addFlowCode(code) {\n      this.flow.code += code;\n      return this;\n    }\n  }, {\n    key: \"addFlowTab\",\n    value: function addFlowTab() {\n      this.tab += '\\t';\n      return this;\n    }\n  }, {\n    key: \"removeFlowTab\",\n    value: function removeFlowTab() {\n      this.tab = this.tab.slice(0, -1);\n      return this;\n    }\n  }, {\n    key: \"getFlowData\",\n    value: function getFlowData(node /*, shaderStage*/) {\n      return this.flowsData.get(node);\n    }\n  }, {\n    key: \"flowNode\",\n    value: function flowNode(node) {\n      var output = node.getNodeType(this);\n      var flowData = this.flowChildNode(node, output);\n      this.flowsData.set(node, flowData);\n      return flowData;\n    }\n  }, {\n    key: \"buildFunctionNode\",\n    value: function buildFunctionNode(shaderNode) {\n      var fn = new FunctionNode();\n      var previous = this.currentFunctionNode;\n      this.currentFunctionNode = fn;\n      fn.code = this.buildFunctionCode(shaderNode);\n      this.currentFunctionNode = previous;\n      return fn;\n    }\n  }, {\n    key: \"flowShaderNode\",\n    value: function flowShaderNode(shaderNode) {\n      var layout = shaderNode.layout;\n      var inputs;\n      if (shaderNode.isArrayInput) {\n        inputs = [];\n        var _iterator4 = _createForOfIteratorHelper(layout.inputs),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var input = _step4.value;\n            inputs.push(new ParameterNode(input.type, input.name));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        inputs = {};\n        var _iterator5 = _createForOfIteratorHelper(layout.inputs),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _input = _step5.value;\n            inputs[_input.name] = new ParameterNode(_input.type, _input.name);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      //\n\n      shaderNode.layout = null;\n      var callNode = shaderNode.call(inputs);\n      var flowData = this.flowStagesNode(callNode, layout.type);\n      shaderNode.layout = layout;\n      return flowData;\n    }\n  }, {\n    key: \"flowStagesNode\",\n    value: function flowStagesNode(node) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var previousFlow = this.flow;\n      var previousVars = this.vars;\n      var previousBuildStage = this.buildStage;\n      var flow = {\n        code: ''\n      };\n      this.flow = flow;\n      this.vars = {};\n      var _iterator6 = _createForOfIteratorHelper(defaultBuildStages),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var buildStage = _step6.value;\n          this.setBuildStage(buildStage);\n          flow.result = node.build(this, output);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      flow.vars = this.getVars(this.shaderStage);\n      this.flow = previousFlow;\n      this.vars = previousVars;\n      this.setBuildStage(previousBuildStage);\n      return flow;\n    }\n  }, {\n    key: \"getFunctionOperator\",\n    value: function getFunctionOperator() {\n      return null;\n    }\n  }, {\n    key: \"flowChildNode\",\n    value: function flowChildNode(node) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var previousFlow = this.flow;\n      var flow = {\n        code: ''\n      };\n      this.flow = flow;\n      flow.result = node.build(this, output);\n      this.flow = previousFlow;\n      return flow;\n    }\n  }, {\n    key: \"flowNodeFromShaderStage\",\n    value: function flowNodeFromShaderStage(shaderStage, node) {\n      var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var previousShaderStage = this.shaderStage;\n      this.setShaderStage(shaderStage);\n      var flowData = this.flowChildNode(node, output);\n      if (propertyName !== null) {\n        flowData.code += \"\".concat(this.tab + propertyName, \" = \").concat(flowData.result, \";\\n\");\n      }\n      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n      this.setShaderStage(previousShaderStage);\n      return flowData;\n    }\n  }, {\n    key: \"getAttributesArray\",\n    value: function getAttributesArray() {\n      return this.attributes.concat(this.bufferAttributes);\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes( /*shaderStage*/\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVaryings\",\n    value: function getVaryings( /*shaderStage*/\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVar\",\n    value: function getVar(type, name) {\n      return \"\".concat(this.getType(type), \" \").concat(name);\n    }\n  }, {\n    key: \"getVars\",\n    value: function getVars(shaderStage) {\n      var snippet = '';\n      var vars = this.vars[shaderStage];\n      if (vars !== undefined) {\n        var _iterator7 = _createForOfIteratorHelper(vars),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var variable = _step7.value;\n            snippet += \"\".concat(this.getVar(variable.type, variable.name), \"; \");\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n      return snippet;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms( /*shaderStage*/\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCodes\",\n    value: function getCodes(shaderStage) {\n      var codes = this.codes[shaderStage];\n      var code = '';\n      if (codes !== undefined) {\n        var _iterator8 = _createForOfIteratorHelper(codes),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var nodeCode = _step8.value;\n            code += nodeCode.code + '\\n';\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n      return code;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.vertexShader + this.fragmentShader + this.computeShader;\n    }\n  }, {\n    key: \"setShaderStage\",\n    value: function setShaderStage(shaderStage) {\n      this.shaderStage = shaderStage;\n    }\n  }, {\n    key: \"getShaderStage\",\n    value: function getShaderStage() {\n      return this.shaderStage;\n    }\n  }, {\n    key: \"setBuildStage\",\n    value: function setBuildStage(buildStage) {\n      this.buildStage = buildStage;\n    }\n  }, {\n    key: \"getBuildStage\",\n    value: function getBuildStage() {\n      return this.buildStage;\n    }\n  }, {\n    key: \"buildCode\",\n    value: function buildCode() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var convertMaterial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var object = this.object,\n        material = this.material;\n      if (convertMaterial) {\n        if (material !== null) {\n          NodeMaterial.fromMaterial(material).build(this);\n        } else {\n          this.addFlow('compute', object);\n        }\n      }\n\n      // setup() -> stage 1: create possible new nodes and returns an output reference node\n      // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n      // generate()  -> stage 3: generate shader\n      var _iterator9 = _createForOfIteratorHelper(defaultBuildStages),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var buildStage = _step9.value;\n          this.setBuildStage(buildStage);\n          if (this.context.vertex && this.context.vertex.isNode) {\n            this.flowNodeFromShaderStage('vertex', this.context.vertex);\n          }\n          var _iterator10 = _createForOfIteratorHelper(shaderStages),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var shaderStage = _step10.value;\n              this.setShaderStage(shaderStage);\n              var flowNodes = this.flowNodes[shaderStage];\n              var _iterator11 = _createForOfIteratorHelper(flowNodes),\n                _step11;\n              try {\n                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                  var node = _step11.value;\n                  if (buildStage === 'generate') {\n                    this.flowNode(node);\n                  } else {\n                    node.build(this);\n                  }\n                }\n              } catch (err) {\n                _iterator11.e(err);\n              } finally {\n                _iterator11.f();\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      this.setBuildStage(null);\n      this.setShaderStage(null);\n\n      // stage 4: build code for a specific output\n\n      this.buildCode();\n      this.buildUpdateNodes();\n      return this;\n    }\n  }, {\n    key: \"getNodeUniform\",\n    value: function getNodeUniform(uniformNode, type) {\n      if (type === 'float') return new FloatNodeUniform(uniformNode);\n      if (type === 'vec2') return new Vector2NodeUniform(uniformNode);\n      if (type === 'vec3') return new Vector3NodeUniform(uniformNode);\n      if (type === 'vec4') return new Vector4NodeUniform(uniformNode);\n      if (type === 'color') return new ColorNodeUniform(uniformNode);\n      if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n      if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n      throw new Error(\"Uniform \\\"\".concat(type, \"\\\" not declared.\"));\n    }\n  }, {\n    key: \"createNodeMaterial\",\n    value: function createNodeMaterial() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NodeMaterial';\n      return createNodeMaterialFromType(type);\n    }\n  }, {\n    key: \"format\",\n    value: function format(snippet, fromType, toType) {\n      fromType = this.getVectorType(fromType);\n      toType = this.getVectorType(toType);\n      if (fromType === toType || toType === null || this.isReference(toType)) {\n        return snippet;\n      }\n      var fromTypeLength = this.getTypeLength(fromType);\n      var toTypeLength = this.getTypeLength(toType);\n      if (fromTypeLength > 4) {\n        // fromType is matrix-like\n\n        // @TODO: ignore for now\n\n        return snippet;\n      }\n      if (toTypeLength > 4 || toTypeLength === 0) {\n        // toType is matrix-like or unknown\n\n        // @TODO: ignore for now\n\n        return snippet;\n      }\n      if (fromTypeLength === toTypeLength) {\n        return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\");\n      }\n      if (fromTypeLength > toTypeLength) {\n        return this.format(\"\".concat(snippet, \".\").concat('xyz'.slice(0, toTypeLength)), this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n      }\n      if (toTypeLength === 4 && fromTypeLength > 1) {\n        // toType is vec4-like\n\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec3'), \", 1.0 )\");\n      }\n      if (fromTypeLength === 2) {\n        // fromType is vec2-like and toType is vec3-like\n\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec2'), \", 0.0 )\");\n      }\n      if (fromTypeLength === 1 && toTypeLength > 1 && fromType[0] !== toType[0]) {\n        // fromType is float-like\n\n        // convert a number value to vector type, e.g:\n        // vec3( 1u ) -> vec3( float( 1u ) )\n\n        snippet = \"\".concat(this.getType(this.getComponentType(toType)), \"( \").concat(snippet, \" )\");\n      }\n      return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\"); // fromType is float-like\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return \"// Three.js r\".concat(REVISION, \" - NodeMaterial System\\n\");\n    }\n  }]);\n  return NodeBuilder;\n}();\nexport default NodeBuilder;","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeKeywords","NodeCache","ParameterNode","FunctionNode","createNodeMaterialFromType","default","NodeMaterial","NodeUpdateType","defaultBuildStages","shaderStages","FloatNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","REVISION","RenderTarget","NoColorSpace","LinearEncoding","sRGBEncoding","SRGBColorSpace","Color","Vector2","Vector3","Vector4","Float16BufferAttribute","stack","getCurrentStack","setCurrentStack","CubeRenderTarget","ChainMap","uniformsGroupCache","typeFromLength","Map","typeFromArray","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","toFloat","value","Number","NodeBuilder","object","renderer","parser","scene","arguments","length","undefined","material","_classCallCheck","geometry","nodes","updateNodes","updateBeforeNodes","hashNodes","lightsNode","environmentNode","fogNode","toneMappingNode","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","structs","bindings","bindingsOffset","bindingsArray","attributes","bufferAttributes","varyings","codes","vars","flow","code","chaining","stacks","tab","currentFunctionNode","context","keywords","cache","globalCache","flowsData","WeakMap","shaderStage","buildStage","_createClass","key","getRenderTarget","width","height","options","getCubeRenderTarget","size","includes","node","_getSharedBindings","shared","_iterator","_createForOfIteratorHelper","_step","s","n","done","binding","getNodes","sharedBinding","get","set","push","err","e","f","getBindings","concat","_toConsumableArray","setHashNode","hash","addNode","getHash","buildUpdateNodes","_iterator2","_step2","updateType","getUpdateType","updateBeforeType","getUpdateBeforeType","NONE","getSelf","addChain","removeChain","lastChain","pop","Error","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","setCache","getCache","isAvailable","getVertexIndex","console","warn","getInstanceIndex","getFrontFacing","getFragCoord","isFlipY","generateTexture","generateTextureLod","generateConst","type","_this","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","isMatrix3","isMatrix4","elements","map","join","generateMethod","hasGeometryAttribute","name","getAttribute","_iterator3","_step3","attribute","getPropertyName","isVector","test","isMatrix","isReference","needsColorSpaceToLinear","getTextureEncodingFromMap","getTextureColorSpaceFromMap","colorSpace","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","baseType","prefix","getTypeFromArray","array","constructor","getTypeFromAttribute","dataAttribute","isInterleavedBufferAttribute","data","itemSize","normalized","arrayType","vecType","vecNum","getVectorFromMatrix","replace","changeComponentType","newComponentType","getIntegerType","addStack","removeStack","lastStack","parent","getDataFromNode","isGlobal","nodeData","getNodeData","setNodeData","getNodeProperties","properties","outputNode","getBufferAttributeFromNode","bufferAttribute","getStructTypeFromNode","structType","getUniformFromNode","nodeUniform","uniform","getVarFromNode","getNodeType","nodeVar","variable","getVaryingFromNode","nodeVarying","varying","getCodeFromNode","nodeCode","addLineFlowCode","addFlowCode","addFlowTab","removeFlowTab","slice","getFlowData","flowNode","output","flowData","flowChildNode","buildFunctionNode","shaderNode","fn","previous","buildFunctionCode","flowShaderNode","layout","inputs","isArrayInput","_iterator4","_step4","input","_iterator5","_step5","callNode","call","flowStagesNode","previousFlow","previousVars","previousBuildStage","_iterator6","_step6","setBuildStage","result","build","getVars","getFunctionOperator","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributesArray","getAttributes","getVaryings","getVar","snippet","_iterator7","_step7","getUniforms","getCodes","_iterator8","_step8","getShaderStage","getBuildStage","buildCode","convertMaterial","fromMaterial","_iterator9","_step9","isNode","_iterator10","_step10","_iterator11","_step11","getNodeUniform","uniformNode","createNodeMaterial","format","fromType","toType","fromTypeLength","toTypeLength","getSignature"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport ParameterNode from './ParameterNode.js';\nimport FunctionNode from '../code/FunctionNode.js';\nimport { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\n\nimport {\n\tFloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform,\n\tColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform\n} from '../../renderers/common/nodes/NodeUniform.js';\n\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\n\nimport { stack } from './StackNode.js';\nimport { getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\n\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\n\nconst uniformsGroupCache = new ChainMap();\n\nconst typeFromLength = new Map( [\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser, scene = null, material = null ) {\n\n\t\tthis.object = object;\n\t\tthis.material = material || ( object && object.material ) || null;\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\t\tthis.scene = scene;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.updateBeforeNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.lightsNode = null;\n\t\tthis.environmentNode = null;\n\t\tthis.fogNode = null;\n\t\tthis.toneMappingNode = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.bindings = { vertex: [], fragment: [], compute: [] };\n\t\tthis.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };\n\t\tthis.bindingsArray = null;\n\t\tthis.attributes = [];\n\t\tthis.bufferAttributes = [];\n\t\tthis.varyings = [];\n\t\tthis.codes = {};\n\t\tthis.vars = {};\n\t\tthis.flow = { code: '' };\n\t\tthis.chaining = [];\n\t\tthis.stack = stack();\n\t\tthis.stacks = [];\n\t\tthis.tab = '\\t';\n\n\t\tthis.currentFunctionNode = null;\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t}\n\n\tgetRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\tgetCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t_getSharedBindings( bindings ) {\n\n\t\tconst shared = [];\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tif ( binding.shared === true ) {\n\n\t\t\t\t// nodes is the chainmap key\n\t\t\t\tconst nodes = binding.getNodes();\n\n\t\t\t\tlet sharedBinding = uniformsGroupCache.get( nodes );\n\n\t\t\t\tif ( sharedBinding === undefined ) {\n\n\t\t\t\t\tuniformsGroupCache.set( nodes, binding );\n\n\t\t\t\t\tsharedBinding = binding;\n\n\t\t\t\t}\n\n\t\t\t\tshared.push( sharedBinding );\n\n\t\t\t} else {\n\n\t\t\t\tshared.push( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shared;\n\n\t}\n\n\tgetBindings() {\n\n\t\tlet bindingsArray = this.bindingsArray;\n\n\t\tif ( bindingsArray === null ) {\n\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tthis.bindingsArray = bindingsArray = this._getSharedBindings( ( this.material !== null ) ? [ ...bindings.vertex, ...bindings.fragment ] : bindings.compute );\n\n\t\t}\n\n\t\treturn bindingsArray;\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture';\n\n\t}\n\n\tneedsColorSpaceToLinear( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/** @deprecated, r152 */\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tconsole.warn( 'THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.' );\n\t\treturn this.getTextureColorSpaceFromMap( map ) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n\n\t}\n\n\tgetTextureColorSpaceFromMap( map ) {\n\n\t\tlet colorSpace;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tcolorSpace = map.colorSpace;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tcolorSpace = map.texture.colorSpace;\n\n\t\t} else {\n\n\t\t\tcolorSpace = NoColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = typeFromLength.get( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getNodeData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setNodeData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\tgetStructTypeFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tif ( nodeData.structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tnode.name = `StructType${ index }`;\n\t\t\tthis.structs[ shaderStage ].push( node );\n\n\t\t\tnodeData.structType = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\n\t\t\tif ( name === null ) name = 'nodeVar' + vars.length;\n\n\t\t\tnodeVar = new NodeVar( name, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\tnodeVarying = new NodeVarying( name, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddLineFlowCode( code ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tlet inputs;\n\n\t\tif ( shaderNode.isArrayInput ) {\n\n\t\t\tinputs = [];\n\n\t\t\tfor ( const input of layout.inputs ) {\n\n\t\t\t\tinputs.push( new ParameterNode( input.type, input.name ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tinputs = {};\n\n\t\t\tfor ( const input of layout.inputs ) {\n\n\t\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousBuildStage = this.buildStage;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\tgetFunctionOperator() {\n\n\t\treturn null;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild( convertMaterial = true ) {\n\n\t\tconst { object, material } = this;\n\n\t\tif ( convertMaterial ) {\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tNodeMaterial.fromMaterial( material ).build( this );\n\n\t\t\t} else {\n\n\t\t\t\tthis.addFlow( 'compute', object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' ) return new FloatNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\tcreateNodeMaterial( type = 'NodeMaterial' ) {\n\n\t\treturn createNodeMaterialFromType( type );\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType[ 0 ] !== toType[ 0 ] ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}