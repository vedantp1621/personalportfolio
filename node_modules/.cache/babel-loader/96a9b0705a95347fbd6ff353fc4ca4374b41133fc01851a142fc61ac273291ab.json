{"ast":null,"code":"import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport ParameterNode from './ParameterNode.js';\nimport FunctionNode from '../code/FunctionNode.js';\nimport { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\nimport { FloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform, ColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform } from '../../renderers/common/nodes/NodeUniform.js';\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\nimport { stack } from './StackNode.js';\nimport { getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\nconst uniformsGroupCache = new ChainMap();\nconst typeFromLength = new Map([[2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nconst typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    let scene = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let material = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    this.object = object;\n    this.material = material || object && object.material || null;\n    this.geometry = object && object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.scene = scene;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.hashNodes = {};\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.toneMappingNode = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: []\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.bindings = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindingsOffset = {\n      vertex: 0,\n      fragment: 0,\n      compute: 0\n    };\n    this.bindingsArray = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.codes = {};\n    this.vars = {};\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.stacks = [];\n    this.tab = '\\t';\n    this.currentFunctionNode = null;\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: this.material\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n  }\n  getRenderTarget(width, height, options) {\n    return new RenderTarget(width, height, options);\n  }\n  getCubeRenderTarget(size, options) {\n    return new CubeRenderTarget(size, options);\n  }\n  includes(node) {\n    return this.nodes.includes(node);\n  }\n  _getSharedBindings(bindings) {\n    const shared = [];\n    for (const binding of bindings) {\n      if (binding.shared === true) {\n        // nodes is the chainmap key\n        const nodes = binding.getNodes();\n        let sharedBinding = uniformsGroupCache.get(nodes);\n        if (sharedBinding === undefined) {\n          uniformsGroupCache.set(nodes, binding);\n          sharedBinding = binding;\n        }\n        shared.push(sharedBinding);\n      } else {\n        shared.push(binding);\n      }\n    }\n    return shared;\n  }\n  getBindings() {\n    let bindingsArray = this.bindingsArray;\n    if (bindingsArray === null) {\n      const bindings = this.bindings;\n      this.bindingsArray = bindingsArray = this._getSharedBindings(this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute);\n    }\n    return bindingsArray;\n  }\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n  addNode(node) {\n    if (this.nodes.includes(node) === false) {\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n  buildUpdateNodes() {\n    for (const node of this.nodes) {\n      const updateType = node.getUpdateType();\n      const updateBeforeType = node.getUpdateBeforeType();\n      if (updateType !== NodeUpdateType.NONE) {\n        this.updateNodes.push(node.getSelf());\n      }\n      if (updateBeforeType !== NodeUpdateType.NONE) {\n        this.updateBeforeNodes.push(node);\n      }\n    }\n  }\n  get currentNode() {\n    return this.chaining[this.chaining.length - 1];\n  }\n  addChain(node) {\n    /*\n    if ( this.chaining.indexOf( node ) !== - 1 ) {\n    \t\tconsole.warn( 'Recursive node: ', node );\n    \t}\n    */\n\n    this.chaining.push(node);\n  }\n  removeChain(node) {\n    const lastChain = this.chaining.pop();\n    if (lastChain !== node) {\n      throw new Error('NodeBuilder: Invalid node chaining!');\n    }\n  }\n  getMethod(method) {\n    return method;\n  }\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  getContext() {\n    return this.context;\n  }\n  setCache(cache) {\n    this.cache = cache;\n  }\n  getCache() {\n    return this.cache;\n  }\n  isAvailable( /*name*/\n  ) {\n    return false;\n  }\n  getVertexIndex() {\n    console.warn('Abstract function.');\n  }\n  getInstanceIndex() {\n    console.warn('Abstract function.');\n  }\n  getFrontFacing() {\n    console.warn('Abstract function.');\n  }\n  getFragCoord() {\n    console.warn('Abstract function.');\n  }\n  isFlipY() {\n    return false;\n  }\n  generateTexture( /* texture, textureProperty, uvSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */\n  ) {\n    console.warn('Abstract function.');\n  }\n  generateConst(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (value === null) {\n      if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n    }\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n    const generateConst = value => this.generateConst(componentType, value);\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;\n    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n      return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;\n    } else if (typeLength > 4) {\n      return `${this.getType(type)}()`;\n    }\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n  getType(type) {\n    if (type === 'color') return 'vec3';\n    return type;\n  }\n  generateMethod(method) {\n    return method;\n  }\n  hasGeometryAttribute(name) {\n    return this.geometry && this.geometry.getAttribute(name) !== undefined;\n  }\n  getAttribute(name, type) {\n    const attributes = this.attributes;\n\n    // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    }\n\n    // create a new if no exist\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n  getPropertyName(node /*, shaderStage*/) {\n    return node.name;\n  }\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture';\n  }\n  needsColorSpaceToLinear( /*texture*/\n  ) {\n    return false;\n  }\n\n  /** @deprecated, r152 */\n  getTextureEncodingFromMap(map) {\n    console.warn('THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.');\n    return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n  }\n  getTextureColorSpaceFromMap(map) {\n    let colorSpace;\n    if (map && map.isTexture) {\n      colorSpace = map.colorSpace;\n    } else if (map && map.isWebGLRenderTarget) {\n      colorSpace = map.texture.colorSpace;\n    } else {\n      colorSpace = NoColorSpace;\n    }\n    return colorSpace;\n  }\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture') return 'vec4';\n    return type;\n  }\n  getTypeFromLength(length) {\n    let componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n    if (length === 1) return componentType;\n    const baseType = typeFromLength.get(length);\n    const prefix = componentType === 'float' ? '' : componentType[0];\n    return prefix + baseType;\n  }\n  getTypeFromArray(array) {\n    return typeFromArray.get(array.constructor);\n  }\n  getTypeFromAttribute(attribute) {\n    let dataAttribute = attribute;\n    if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n    const array = dataAttribute.array;\n    const itemSize = attribute.itemSize;\n    const normalized = attribute.normalized;\n    let arrayType;\n    if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n      arrayType = this.getTypeFromArray(array);\n    }\n    return this.getTypeFromLength(itemSize, arrayType);\n  }\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    if (/mat2/.test(type) === true) return 4;\n    if (/mat3/.test(type) === true) return 9;\n    if (/mat4/.test(type) === true) return 16;\n    return 0;\n  }\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n  changeComponentType(type, newComponentType) {\n    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n  }\n  getIntegerType(type) {\n    const componentType = this.getComponentType(type);\n    if (componentType === 'int' || componentType === 'uint') return type;\n    return this.changeComponentType(type, 'int');\n  }\n  addStack() {\n    this.stack = stack(this.stack);\n    this.stacks.push(getCurrentStack() || this.stack);\n    setCurrentStack(this.stack);\n    return this.stack;\n  }\n  removeStack() {\n    const lastStack = this.stack;\n    this.stack = lastStack.parent;\n    setCurrentStack(this.stacks.pop());\n    return lastStack;\n  }\n  getDataFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    let cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    cache = cache === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache;\n    let nodeData = cache.getNodeData(node);\n    if (nodeData === undefined) {\n      nodeData = {};\n      cache.setNodeData(node, nodeData);\n    }\n    if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n    return nodeData[shaderStage];\n  }\n  getNodeProperties(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    return nodeData.properties || (nodeData.properties = {\n      outputNode: null\n    });\n  }\n  getBufferAttributeFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node);\n    let bufferAttribute = nodeData.bufferAttribute;\n    if (bufferAttribute === undefined) {\n      const index = this.uniforms.index++;\n      bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n      this.bufferAttributes.push(bufferAttribute);\n      nodeData.bufferAttribute = bufferAttribute;\n    }\n    return bufferAttribute;\n  }\n  getStructTypeFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    if (nodeData.structType === undefined) {\n      const index = this.structs.index++;\n      node.name = `StructType${index}`;\n      this.structs[shaderStage].push(node);\n      nodeData.structType = node;\n    }\n    return node;\n  }\n  getUniformFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    let name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);\n    let nodeUniform = nodeData.uniform;\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n    return nodeUniform;\n  }\n  getVarFromNode(node) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);\n    let shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);\n      if (name === null) name = 'nodeVar' + vars.length;\n      nodeVar = new NodeVar(name, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n    return nodeVar;\n  }\n  getVaryingFromNode(node) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);\n    const nodeData = this.getDataFromNode(node, 'any');\n    let nodeVarying = nodeData.varying;\n    if (nodeVarying === undefined) {\n      const varyings = this.varyings;\n      const index = varyings.length;\n      if (name === null) name = 'nodeVarying' + index;\n      nodeVarying = new NodeVarying(name, type);\n      varyings.push(nodeVarying);\n      nodeData.varying = nodeVarying;\n    }\n    return nodeVarying;\n  }\n  getCodeFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n    return nodeCode;\n  }\n  addLineFlowCode(code) {\n    if (code === '') return this;\n    code = this.tab + code;\n    if (!/;\\s*$/.test(code)) {\n      code = code + ';\\n';\n    }\n    this.flow.code += code;\n    return this;\n  }\n  addFlowCode(code) {\n    this.flow.code += code;\n    return this;\n  }\n  addFlowTab() {\n    this.tab += '\\t';\n    return this;\n  }\n  removeFlowTab() {\n    this.tab = this.tab.slice(0, -1);\n    return this;\n  }\n  getFlowData(node /*, shaderStage*/) {\n    return this.flowsData.get(node);\n  }\n  flowNode(node) {\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    return flowData;\n  }\n  buildFunctionNode(shaderNode) {\n    const fn = new FunctionNode();\n    const previous = this.currentFunctionNode;\n    this.currentFunctionNode = fn;\n    fn.code = this.buildFunctionCode(shaderNode);\n    this.currentFunctionNode = previous;\n    return fn;\n  }\n  flowShaderNode(shaderNode) {\n    const layout = shaderNode.layout;\n    let inputs;\n    if (shaderNode.isArrayInput) {\n      inputs = [];\n      for (const input of layout.inputs) {\n        inputs.push(new ParameterNode(input.type, input.name));\n      }\n    } else {\n      inputs = {};\n      for (const input of layout.inputs) {\n        inputs[input.name] = new ParameterNode(input.type, input.name);\n      }\n    }\n\n    //\n\n    shaderNode.layout = null;\n    const callNode = shaderNode.call(inputs);\n    const flowData = this.flowStagesNode(callNode, layout.type);\n    shaderNode.layout = layout;\n    return flowData;\n  }\n  flowStagesNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const previousVars = this.vars;\n    const previousBuildStage = this.buildStage;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    this.vars = {};\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      flow.result = node.build(this, output);\n    }\n    flow.vars = this.getVars(this.shaderStage);\n    this.flow = previousFlow;\n    this.vars = previousVars;\n    this.setBuildStage(previousBuildStage);\n    return flow;\n  }\n  getFunctionOperator() {\n    return null;\n  }\n  flowChildNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n  flowNodeFromShaderStage(shaderStage, node) {\n    let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n    if (propertyName !== null) {\n      flowData.code += `${this.tab + propertyName} = ${flowData.result};\\n`;\n    }\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n  getAttributesArray() {\n    return this.attributes.concat(this.bufferAttributes);\n  }\n  getAttributes( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVaryings( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getVar(type, name) {\n    return `${this.getType(type)} ${name}`;\n  }\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n    if (vars !== undefined) {\n      for (const variable of vars) {\n        snippet += `${this.getVar(variable.type, variable.name)}; `;\n      }\n    }\n    return snippet;\n  }\n  getUniforms( /*shaderStage*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n    if (codes !== undefined) {\n      for (const nodeCode of codes) {\n        code += nodeCode.code + '\\n';\n      }\n    }\n    return code;\n  }\n  getHash() {\n    return this.vertexShader + this.fragmentShader + this.computeShader;\n  }\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n  getShaderStage() {\n    return this.shaderStage;\n  }\n  setBuildStage(buildStage) {\n    this.buildStage = buildStage;\n  }\n  getBuildStage() {\n    return this.buildStage;\n  }\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n  build() {\n    let convertMaterial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const {\n      object,\n      material\n    } = this;\n    if (convertMaterial) {\n      if (material !== null) {\n        NodeMaterial.fromMaterial(material).build(this);\n      } else {\n        this.addFlow('compute', object);\n      }\n    }\n\n    // setup() -> stage 1: create possible new nodes and returns an output reference node\n    // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n    // generate()  -> stage 3: generate shader\n\n    for (const buildStage of defaultBuildStages) {\n      this.setBuildStage(buildStage);\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      }\n      for (const shaderStage of shaderStages) {\n        this.setShaderStage(shaderStage);\n        const flowNodes = this.flowNodes[shaderStage];\n        for (const node of flowNodes) {\n          if (buildStage === 'generate') {\n            this.flowNode(node);\n          } else {\n            node.build(this);\n          }\n        }\n      }\n    }\n    this.setBuildStage(null);\n    this.setShaderStage(null);\n\n    // stage 4: build code for a specific output\n\n    this.buildCode();\n    this.buildUpdateNodes();\n    return this;\n  }\n  getNodeUniform(uniformNode, type) {\n    if (type === 'float') return new FloatNodeUniform(uniformNode);\n    if (type === 'vec2') return new Vector2NodeUniform(uniformNode);\n    if (type === 'vec3') return new Vector3NodeUniform(uniformNode);\n    if (type === 'vec4') return new Vector4NodeUniform(uniformNode);\n    if (type === 'color') return new ColorNodeUniform(uniformNode);\n    if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n    if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n    throw new Error(`Uniform \"${type}\" not declared.`);\n  }\n  createNodeMaterial() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NodeMaterial';\n    return createNodeMaterialFromType(type);\n  }\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n    if (fromTypeLength > 4) {\n      // fromType is matrix-like\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (toTypeLength > 4 || toTypeLength === 0) {\n      // toType is matrix-like or unknown\n\n      // @TODO: ignore for now\n\n      return snippet;\n    }\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n    }\n    if (toTypeLength === 4 && fromTypeLength > 1) {\n      // toType is vec4-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n    if (fromTypeLength === 1 && toTypeLength > 1 && fromType[0] !== toType[0]) {\n      // fromType is float-like\n\n      // convert a number value to vector type, e.g:\n      // vec3( 1u ) -> vec3( float( 1u ) )\n\n      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;\n    }\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n}\nexport default NodeBuilder;","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeKeywords","NodeCache","ParameterNode","FunctionNode","createNodeMaterialFromType","default","NodeMaterial","NodeUpdateType","defaultBuildStages","shaderStages","FloatNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","REVISION","RenderTarget","NoColorSpace","LinearEncoding","sRGBEncoding","SRGBColorSpace","Color","Vector2","Vector3","Vector4","Float16BufferAttribute","stack","getCurrentStack","setCurrentStack","CubeRenderTarget","ChainMap","uniformsGroupCache","typeFromLength","Map","typeFromArray","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","scene","arguments","length","undefined","material","geometry","nodes","updateNodes","updateBeforeNodes","hashNodes","lightsNode","environmentNode","fogNode","toneMappingNode","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","structs","bindings","bindingsOffset","bindingsArray","attributes","bufferAttributes","varyings","codes","vars","flow","code","chaining","stacks","tab","currentFunctionNode","context","keywords","cache","globalCache","flowsData","WeakMap","shaderStage","buildStage","getRenderTarget","width","height","options","getCubeRenderTarget","size","includes","node","_getSharedBindings","shared","binding","getNodes","sharedBinding","get","set","push","getBindings","setHashNode","hash","addNode","getHash","buildUpdateNodes","updateType","getUpdateType","updateBeforeType","getUpdateBeforeType","NONE","getSelf","currentNode","addChain","removeChain","lastChain","pop","Error","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","setCache","getCache","isAvailable","getVertexIndex","console","warn","getInstanceIndex","getFrontFacing","getFragCoord","isFlipY","generateTexture","generateTextureLod","generateConst","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","isMatrix3","isMatrix4","elements","map","join","generateMethod","hasGeometryAttribute","name","getAttribute","attribute","getPropertyName","isVector","test","isMatrix","isReference","needsColorSpaceToLinear","getTextureEncodingFromMap","getTextureColorSpaceFromMap","colorSpace","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","baseType","prefix","getTypeFromArray","array","getTypeFromAttribute","dataAttribute","isInterleavedBufferAttribute","data","itemSize","normalized","arrayType","vecType","vecNum","getVectorFromMatrix","replace","changeComponentType","newComponentType","getIntegerType","addStack","removeStack","lastStack","parent","getDataFromNode","isGlobal","nodeData","getNodeData","setNodeData","getNodeProperties","properties","outputNode","getBufferAttributeFromNode","bufferAttribute","getStructTypeFromNode","structType","getUniformFromNode","nodeUniform","uniform","getVarFromNode","getNodeType","nodeVar","variable","getVaryingFromNode","nodeVarying","varying","getCodeFromNode","nodeCode","addLineFlowCode","addFlowCode","addFlowTab","removeFlowTab","slice","getFlowData","flowNode","output","flowData","flowChildNode","buildFunctionNode","shaderNode","fn","previous","buildFunctionCode","flowShaderNode","layout","inputs","isArrayInput","input","callNode","call","flowStagesNode","previousFlow","previousVars","previousBuildStage","setBuildStage","result","build","getVars","getFunctionOperator","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributesArray","concat","getAttributes","getVaryings","getVar","snippet","getUniforms","getCodes","getShaderStage","getBuildStage","buildCode","convertMaterial","fromMaterial","isNode","getNodeUniform","uniformNode","createNodeMaterial","format","fromType","toType","fromTypeLength","toTypeLength","getSignature"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport ParameterNode from './ParameterNode.js';\nimport FunctionNode from '../code/FunctionNode.js';\nimport { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\n\nimport {\n\tFloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform,\n\tColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform\n} from '../../renderers/common/nodes/NodeUniform.js';\n\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\n\nimport { stack } from './StackNode.js';\nimport { getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\n\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nimport ChainMap from '../../renderers/common/ChainMap.js';\n\nconst uniformsGroupCache = new ChainMap();\n\nconst typeFromLength = new Map( [\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser, scene = null, material = null ) {\n\n\t\tthis.object = object;\n\t\tthis.material = material || ( object && object.material ) || null;\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\t\tthis.scene = scene;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.updateBeforeNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.lightsNode = null;\n\t\tthis.environmentNode = null;\n\t\tthis.fogNode = null;\n\t\tthis.toneMappingNode = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.bindings = { vertex: [], fragment: [], compute: [] };\n\t\tthis.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };\n\t\tthis.bindingsArray = null;\n\t\tthis.attributes = [];\n\t\tthis.bufferAttributes = [];\n\t\tthis.varyings = [];\n\t\tthis.codes = {};\n\t\tthis.vars = {};\n\t\tthis.flow = { code: '' };\n\t\tthis.chaining = [];\n\t\tthis.stack = stack();\n\t\tthis.stacks = [];\n\t\tthis.tab = '\\t';\n\n\t\tthis.currentFunctionNode = null;\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t}\n\n\tgetRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\tgetCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t_getSharedBindings( bindings ) {\n\n\t\tconst shared = [];\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tif ( binding.shared === true ) {\n\n\t\t\t\t// nodes is the chainmap key\n\t\t\t\tconst nodes = binding.getNodes();\n\n\t\t\t\tlet sharedBinding = uniformsGroupCache.get( nodes );\n\n\t\t\t\tif ( sharedBinding === undefined ) {\n\n\t\t\t\t\tuniformsGroupCache.set( nodes, binding );\n\n\t\t\t\t\tsharedBinding = binding;\n\n\t\t\t\t}\n\n\t\t\t\tshared.push( sharedBinding );\n\n\t\t\t} else {\n\n\t\t\t\tshared.push( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shared;\n\n\t}\n\n\tgetBindings() {\n\n\t\tlet bindingsArray = this.bindingsArray;\n\n\t\tif ( bindingsArray === null ) {\n\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tthis.bindingsArray = bindingsArray = this._getSharedBindings( ( this.material !== null ) ? [ ...bindings.vertex, ...bindings.fragment ] : bindings.compute );\n\n\t\t}\n\n\t\treturn bindingsArray;\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture';\n\n\t}\n\n\tneedsColorSpaceToLinear( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/** @deprecated, r152 */\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tconsole.warn( 'THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.' );\n\t\treturn this.getTextureColorSpaceFromMap( map ) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n\n\t}\n\n\tgetTextureColorSpaceFromMap( map ) {\n\n\t\tlet colorSpace;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tcolorSpace = map.colorSpace;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tcolorSpace = map.texture.colorSpace;\n\n\t\t} else {\n\n\t\t\tcolorSpace = NoColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = typeFromLength.get( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getNodeData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setNodeData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\tgetStructTypeFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tif ( nodeData.structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tnode.name = `StructType${ index }`;\n\t\t\tthis.structs[ shaderStage ].push( node );\n\n\t\t\tnodeData.structType = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\n\t\t\tif ( name === null ) name = 'nodeVar' + vars.length;\n\n\t\t\tnodeVar = new NodeVar( name, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\tnodeVarying = new NodeVarying( name, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddLineFlowCode( code ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tlet inputs;\n\n\t\tif ( shaderNode.isArrayInput ) {\n\n\t\t\tinputs = [];\n\n\t\t\tfor ( const input of layout.inputs ) {\n\n\t\t\t\tinputs.push( new ParameterNode( input.type, input.name ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tinputs = {};\n\n\t\t\tfor ( const input of layout.inputs ) {\n\n\t\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousBuildStage = this.buildStage;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\tgetFunctionOperator() {\n\n\t\treturn null;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild( convertMaterial = true ) {\n\n\t\tconst { object, material } = this;\n\n\t\tif ( convertMaterial ) {\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tNodeMaterial.fromMaterial( material ).build( this );\n\n\t\t\t} else {\n\n\t\t\t\tthis.addFlow( 'compute', object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' ) return new FloatNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\tcreateNodeMaterial( type = 'NodeMaterial' ) {\n\n\t\treturn createNodeMaterialFromType( type );\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType[ 0 ] !== toType[ 0 ] ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}