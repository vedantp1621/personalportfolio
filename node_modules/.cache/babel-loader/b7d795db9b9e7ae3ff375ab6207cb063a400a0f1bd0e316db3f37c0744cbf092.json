{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy, tslFn } from '../shadernode/ShaderNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { referenceIndex } from './ReferenceNode.js';\nimport { positionLocal } from './PositionNode.js';\nimport { normalLocal } from './NormalNode.js';\nimport { textureLoad } from './TextureNode.js';\nimport { vertexIndex } from '../core/IndexNode.js';\nimport { ivec2, int } from '../shadernode/ShaderNode.js';\nimport { DataArrayTexture, Vector2, Vector4, FloatType } from 'three';\nconst morphTextures = new WeakMap();\nconst morphVec4 = new Vector4();\nconst getMorph = tslFn(_ref => {\n  let {\n    bufferMap,\n    influence,\n    stride,\n    width,\n    depth,\n    offset\n  } = _ref;\n  const texelIndex = int(vertexIndex).mul(stride).add(offset);\n  const y = texelIndex.div(width);\n  const x = texelIndex.sub(y.mul(width));\n  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth);\n  return bufferAttrib.mul(influence);\n});\nfunction getEntry(geometry) {\n  const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n  const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n  const hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n  // instead of using attributes, the WebGL 2 code path encodes morph targets\n  // into an array of data textures. Each layer represents a single morph target.\n\n  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n  const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n  let entry = morphTextures.get(geometry);\n  if (entry === undefined || entry.count !== morphTargetsCount) {\n    if (entry !== undefined) entry.texture.dispose();\n    const morphTargets = geometry.morphAttributes.position || [];\n    const morphNormals = geometry.morphAttributes.normal || [];\n    const morphColors = geometry.morphAttributes.color || [];\n    let vertexDataCount = 0;\n    if (hasMorphPosition === true) vertexDataCount = 1;\n    if (hasMorphNormals === true) vertexDataCount = 2;\n    if (hasMorphColors === true) vertexDataCount = 3;\n    let width = geometry.attributes.position.count * vertexDataCount;\n    let height = 1;\n    const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n    if (width > maxTextureSize) {\n      height = Math.ceil(width / maxTextureSize);\n      width = maxTextureSize;\n    }\n    const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n    const bufferTexture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n    bufferTexture.type = FloatType;\n    bufferTexture.needsUpdate = true;\n\n    // fill buffer\n\n    const vertexDataStride = vertexDataCount * 4;\n    for (let i = 0; i < morphTargetsCount; i++) {\n      const morphTarget = morphTargets[i];\n      const morphNormal = morphNormals[i];\n      const morphColor = morphColors[i];\n      const offset = width * height * 4 * i;\n      for (let j = 0; j < morphTarget.count; j++) {\n        const stride = j * vertexDataStride;\n        if (hasMorphPosition === true) {\n          morphVec4.fromBufferAttribute(morphTarget, j);\n          buffer[offset + stride + 0] = morphVec4.x;\n          buffer[offset + stride + 1] = morphVec4.y;\n          buffer[offset + stride + 2] = morphVec4.z;\n          buffer[offset + stride + 3] = 0;\n        }\n        if (hasMorphNormals === true) {\n          morphVec4.fromBufferAttribute(morphNormal, j);\n          buffer[offset + stride + 4] = morphVec4.x;\n          buffer[offset + stride + 5] = morphVec4.y;\n          buffer[offset + stride + 6] = morphVec4.z;\n          buffer[offset + stride + 7] = 0;\n        }\n        if (hasMorphColors === true) {\n          morphVec4.fromBufferAttribute(morphColor, j);\n          buffer[offset + stride + 8] = morphVec4.x;\n          buffer[offset + stride + 9] = morphVec4.y;\n          buffer[offset + stride + 10] = morphVec4.z;\n          buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morphVec4.w : 1;\n        }\n      }\n    }\n    entry = {\n      count: morphTargetsCount,\n      texture: bufferTexture,\n      stride: vertexDataCount,\n      size: new Vector2(width, height)\n    };\n    morphTextures.set(geometry, entry);\n    function disposeTexture() {\n      bufferTexture.dispose();\n      morphTextures.delete(geometry);\n      geometry.removeEventListener('dispose', disposeTexture);\n    }\n    geometry.addEventListener('dispose', disposeTexture);\n  }\n  return entry;\n}\nclass MorphNode extends Node {\n  constructor(mesh) {\n    super('void');\n    this.mesh = mesh;\n    this.morphBaseInfluence = uniform(1);\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  setup(builder) {\n    const {\n      geometry\n    } = builder;\n    const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n    const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n\n    // nodes\n\n    const {\n      texture: bufferMap,\n      stride,\n      size\n    } = getEntry(geometry);\n    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);\n    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);\n    const width = int(size.width);\n    for (let i = 0; i < morphTargetsCount; i++) {\n      const influence = referenceIndex('morphTargetInfluences', i, 'float');\n      const depth = int(i);\n      if (hasMorphPosition === true) {\n        positionLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth,\n          offset: int(0)\n        }));\n      }\n      if (hasMorphNormals === true) {\n        normalLocal.addAssign(getMorph({\n          bufferMap,\n          influence,\n          stride,\n          width,\n          depth,\n          offset: int(1)\n        }));\n      }\n    }\n  }\n  update() {\n    const morphBaseInfluence = this.morphBaseInfluence;\n    if (this.mesh.geometry.morphTargetsRelative) {\n      morphBaseInfluence.value = 1;\n    } else {\n      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);\n    }\n  }\n}\nexport default MorphNode;\nexport const morph = nodeProxy(MorphNode);\naddNodeClass('MorphNode', MorphNode);","map":{"version":3,"names":["Node","addNodeClass","NodeUpdateType","nodeProxy","tslFn","uniform","referenceIndex","positionLocal","normalLocal","textureLoad","vertexIndex","ivec2","int","DataArrayTexture","Vector2","Vector4","FloatType","morphTextures","WeakMap","morphVec4","getMorph","_ref","bufferMap","influence","stride","width","depth","offset","texelIndex","mul","add","y","div","x","sub","bufferAttrib","getEntry","geometry","hasMorphPosition","morphAttributes","position","undefined","hasMorphNormals","normal","hasMorphColors","color","morphAttribute","morphTargetsCount","length","entry","get","count","texture","dispose","morphTargets","morphNormals","morphColors","vertexDataCount","attributes","height","maxTextureSize","Math","ceil","buffer","Float32Array","bufferTexture","type","needsUpdate","vertexDataStride","i","morphTarget","morphNormal","morphColor","j","fromBufferAttribute","z","itemSize","w","size","set","disposeTexture","delete","removeEventListener","addEventListener","MorphNode","constructor","mesh","morphBaseInfluence","updateType","OBJECT","setup","builder","mulAssign","addAssign","update","morphTargetsRelative","value","morphTargetInfluences","reduce","a","b","morph"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/accessors/MorphNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy, tslFn } from '../shadernode/ShaderNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { referenceIndex } from './ReferenceNode.js';\nimport { positionLocal } from './PositionNode.js';\nimport { normalLocal } from './NormalNode.js';\nimport { textureLoad } from './TextureNode.js';\nimport { vertexIndex } from '../core/IndexNode.js';\nimport { ivec2, int } from '../shadernode/ShaderNode.js';\nimport { DataArrayTexture, Vector2, Vector4, FloatType } from 'three';\n\nconst morphTextures = new WeakMap();\nconst morphVec4 = new Vector4();\n\nconst getMorph = tslFn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\tmorphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\tmorphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\tmorphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\tmorphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\tmorphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n\nclass MorphNode extends Node {\n\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.mesh = mesh;\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst influence = referenceIndex( 'morphTargetInfluences', i, 'float' );\n\t\t\tconst depth = int( i );\n\n\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth,\n\t\t\t\t\toffset: int( 0 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth,\n\t\t\t\t\toffset: int( 1 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\nexport default MorphNode;\n\nexport const morph = nodeProxy( MorphNode );\n\naddNodeClass( 'MorphNode', MorphNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}