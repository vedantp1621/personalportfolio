{"ast":null,"code":"import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\nimport { WebGPUCoordinateSystem } from 'three';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\nlet overrideMaterial = null;\nclass AnalyticLightNode extends LightingNode {\n  constructor() {\n    let light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.updateType = NodeUpdateType.FRAME;\n    this.light = light;\n    this.rtt = null;\n    this.shadowNode = null;\n    this.color = new Color();\n    this._defaultColorNode = uniform(this.color);\n    this.colorNode = this._defaultColorNode;\n    this.isAnalyticLightNode = true;\n  }\n  getCacheKey() {\n    return super.getCacheKey() + '-' + (this.light.id + '-' + (this.light.castShadow ? '1' : '0'));\n  }\n  getHash() {\n    return this.light.uuid;\n  }\n  setupShadow(builder) {\n    let shadowNode = this.shadowNode;\n    if (shadowNode === null) {\n      if (overrideMaterial === null) {\n        overrideMaterial = builder.createNodeMaterial();\n        overrideMaterial.fragmentNode = vec4(0, 0, 0, 1);\n        overrideMaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.fragmentNode unintentionally when using material.shadowNode\n      }\n\n      const shadow = this.light.shadow;\n      const rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n      const depthTexture = new DepthTexture();\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n      depthTexture.image.width = shadow.mapSize.width;\n      depthTexture.image.height = shadow.mapSize.height;\n      depthTexture.compareFunction = LessCompare;\n      rtt.depthTexture = depthTexture;\n      shadow.camera.updateProjectionMatrix();\n\n      //\n\n      const bias = reference('bias', 'float', shadow);\n      const normalBias = reference('normalBias', 'float', shadow);\n      let shadowCoord = uniform(shadow.matrix).mul(positionWorld.add(normalWorld.mul(normalBias)));\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n      let coordZ = shadowCoord.z.add(bias);\n      if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {\n        coordZ = coordZ.mul(2).sub(1); // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n      }\n\n      shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n      // follow webgpu standards\n      coordZ);\n      const textureCompare = (depthTexture, shadowCoord, compare) => texture(depthTexture, shadowCoord).compare(compare);\n      //const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n      // BasicShadowMap\n\n      shadowNode = textureCompare(depthTexture, shadowCoord.xy, shadowCoord.z);\n\n      // PCFShadowMap\n      /*\n      const mapSize = reference( 'mapSize', 'vec2', shadow );\n      const radius = reference( 'radius', 'float', shadow );\n      \tconst texelSize = vec2( 1 ).div( mapSize );\n      const dx0 = texelSize.x.negate().mul( radius );\n      const dy0 = texelSize.y.negate().mul( radius );\n      const dx1 = texelSize.x.mul( radius );\n      const dy1 = texelSize.y.mul( radius );\n      const dx2 = dx0.mul( 2 );\n      const dy2 = dy0.mul( 2 );\n      const dx3 = dx1.mul( 2 );\n      const dy3 = dy1.mul( 2 );\n      \tshadowNode = add(\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n      ).mul( 1 / 17 );\n      */\n      //\n\n      const shadowColor = texture(rtt.texture, shadowCoord);\n      this.rtt = rtt;\n      this.colorNode = this.colorNode.mul(frustumTest.mix(1, shadowNode.mix(shadowColor.a.mix(1, shadowColor), 1)));\n      this.shadowNode = shadowNode;\n\n      //\n\n      this.updateBeforeType = NodeUpdateType.RENDER;\n    }\n  }\n  setup(builder) {\n    if (this.light.castShadow) this.setupShadow(builder);else if (this.shadowNode !== null) this.disposeShadow();\n  }\n  updateShadow(frame) {\n    const {\n      rtt,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    const currentOverrideMaterial = scene.overrideMaterial;\n    scene.overrideMaterial = overrideMaterial;\n    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);\n    light.shadow.updateMatrices(light);\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentRenderObjectFunction = renderer.getRenderObjectFunction();\n    renderer.setRenderObjectFunction(function (object) {\n      if (object.castShadow === true) {\n        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          params[_key - 1] = arguments[_key];\n        }\n        renderer.renderObject(object, ...params);\n      }\n    });\n    renderer.setRenderTarget(rtt);\n    renderer.render(scene, light.shadow.camera);\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.setRenderObjectFunction(currentRenderObjectFunction);\n    scene.overrideMaterial = currentOverrideMaterial;\n  }\n  disposeShadow() {\n    this.rtt.dispose();\n    this.shadowNode = null;\n    this.rtt = null;\n    this.colorNode = this._defaultColorNode;\n  }\n  updateBefore(frame) {\n    const {\n      light\n    } = this;\n    if (light.castShadow) this.updateShadow(frame);\n  }\n  update( /*frame*/\n  ) {\n    const {\n      light\n    } = this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  }\n}\nexport default AnalyticLightNode;\naddNodeClass('AnalyticLightNode', AnalyticLightNode);","map":{"version":3,"names":["LightingNode","NodeUpdateType","uniform","addNodeClass","vec3","vec4","reference","texture","positionWorld","normalWorld","WebGPUCoordinateSystem","Color","DepthTexture","NearestFilter","LessCompare","overrideMaterial","AnalyticLightNode","constructor","light","arguments","length","undefined","updateType","FRAME","rtt","shadowNode","color","_defaultColorNode","colorNode","isAnalyticLightNode","getCacheKey","id","castShadow","getHash","uuid","setupShadow","builder","createNodeMaterial","fragmentNode","isShadowNodeMaterial","shadow","getRenderTarget","mapSize","width","height","depthTexture","minFilter","magFilter","image","compareFunction","camera","updateProjectionMatrix","bias","normalBias","shadowCoord","matrix","mul","add","xyz","div","w","frustumTest","x","greaterThanEqual","and","lessThanEqual","y","z","coordZ","renderer","coordinateSystem","sub","oneMinus","textureCompare","compare","xy","shadowColor","mix","a","updateBeforeType","RENDER","setup","disposeShadow","updateShadow","frame","scene","currentOverrideMaterial","setSize","updateMatrices","currentRenderTarget","currentRenderObjectFunction","getRenderObjectFunction","setRenderObjectFunction","object","_len","params","Array","_key","renderObject","setRenderTarget","render","dispose","updateBefore","update","copy","multiplyScalar","intensity"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js"],"sourcesContent":["import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/ vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\nimport { WebGPUCoordinateSystem } from 'three';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\n\nlet overrideMaterial = null;\n\nclass AnalyticLightNode extends LightingNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\tthis.light = light;\n\n\t\tthis.rtt = null;\n\t\tthis.shadowNode = null;\n\n\t\tthis.color = new Color();\n\t\tthis._defaultColorNode = uniform( this.color );\n\n\t\tthis.colorNode = this._defaultColorNode;\n\n\t\tthis.isAnalyticLightNode = true;\n\n\t}\n\n\tgetCacheKey() {\n\n\t\treturn super.getCacheKey() + '-' + ( this.light.id + '-' + ( this.light.castShadow ? '1' : '0' ) );\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tlet shadowNode = this.shadowNode;\n\n\t\tif ( shadowNode === null ) {\n\n\t\t\tif ( overrideMaterial === null ) {\n\n\t\t\t\toverrideMaterial = builder.createNodeMaterial();\n\t\t\t\toverrideMaterial.fragmentNode = vec4( 0, 0, 0, 1 );\n\t\t\t\toverrideMaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.fragmentNode unintentionally when using material.shadowNode\n\n\t\t\t}\n\n\t\t\tconst shadow = this.light.shadow;\n\t\t\tconst rtt = builder.getRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\t\tconst depthTexture = new DepthTexture();\n\t\t\tdepthTexture.minFilter = NearestFilter;\n\t\t\tdepthTexture.magFilter = NearestFilter;\n\t\t\tdepthTexture.image.width = shadow.mapSize.width;\n\t\t\tdepthTexture.image.height = shadow.mapSize.height;\n\t\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\t\trtt.depthTexture = depthTexture;\n\n\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t//\n\n\t\t\tconst bias = reference( 'bias', 'float', shadow );\n\t\t\tconst normalBias = reference( 'normalBias', 'float', shadow );\n\n\t\t\tlet shadowCoord = uniform( shadow.matrix ).mul( positionWorld.add( normalWorld.mul( normalBias ) ) );\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\t\tlet coordZ = shadowCoord.z.add( bias );\n\n\t\t\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t\tshadowCoord = vec3(\n\t\t\t\tshadowCoord.x,\n\t\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\t\tcoordZ\n\t\t\t);\n\n\t\t\tconst textureCompare = ( depthTexture, shadowCoord, compare ) => texture( depthTexture, shadowCoord ).compare( compare );\n\t\t\t//const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n\t\t\t// BasicShadowMap\n\n\t\t\tshadowNode = textureCompare( depthTexture, shadowCoord.xy, shadowCoord.z );\n\n\t\t\t// PCFShadowMap\n\t\t\t/*\n\t\t\tconst mapSize = reference( 'mapSize', 'vec2', shadow );\n\t\t\tconst radius = reference( 'radius', 'float', shadow );\n\n\t\t\tconst texelSize = vec2( 1 ).div( mapSize );\n\t\t\tconst dx0 = texelSize.x.negate().mul( radius );\n\t\t\tconst dy0 = texelSize.y.negate().mul( radius );\n\t\t\tconst dx1 = texelSize.x.mul( radius );\n\t\t\tconst dy1 = texelSize.y.mul( radius );\n\t\t\tconst dx2 = dx0.mul( 2 );\n\t\t\tconst dy2 = dy0.mul( 2 );\n\t\t\tconst dx3 = dx1.mul( 2 );\n\t\t\tconst dy3 = dy1.mul( 2 );\n\n\t\t\tshadowNode = add(\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t\t\t).mul( 1 / 17 );\n\t\t\t*/\n\t\t\t//\n\n\t\t\tconst shadowColor = texture( rtt.texture, shadowCoord );\n\n\t\t\tthis.rtt = rtt;\n\t\t\tthis.colorNode = this.colorNode.mul( frustumTest.mix( 1, shadowNode.mix( shadowColor.a.mix( 1, shadowColor ), 1 ) ) );\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\t//\n\n\t\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.light.castShadow ) this.setupShadow( builder );\n\t\telse if ( this.shadowNode !== null ) this.disposeShadow();\n\n\t}\n\n\tupdateShadow( frame ) {\n\n\t\tconst { rtt, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst currentOverrideMaterial = scene.overrideMaterial;\n\n\t\tscene.overrideMaterial = overrideMaterial;\n\n\t\trtt.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );\n\n\t\tlight.shadow.updateMatrices( light );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\n\n\t\t\tif ( object.castShadow === true ) {\n\n\t\t\t\trenderer.renderObject( object, ...params );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.setRenderTarget( rtt );\n\n\t\trenderer.render( scene, light.shadow.camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\tscene.overrideMaterial = currentOverrideMaterial;\n\n\t}\n\n\tdisposeShadow() {\n\n\t\tthis.rtt.dispose();\n\n\t\tthis.shadowNode = null;\n\t\tthis.rtt = null;\n\n\t\tthis.colorNode = this._defaultColorNode;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tif ( light.castShadow ) this.updateShadow( frame );\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nexport default AnalyticLightNode;\n\naddNodeClass( 'AnalyticLightNode', AnalyticLightNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}