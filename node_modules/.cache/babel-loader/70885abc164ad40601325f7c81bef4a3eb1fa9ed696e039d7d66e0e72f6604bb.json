{"ast":null,"code":"import _classCallCheck from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { mul } from '../math/OperatorNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texturePass } from './PassNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { Vector2, RenderTarget } from 'three';\nimport QuadMesh from '../../objects/QuadMesh.js';\n\n// WebGPU: The use of a single QuadMesh for both gaussian blur passes results in a single RenderObject with a SampledTexture binding that\n// alternates between source textures and triggers creation of new BindGroups and BindGroupLayouts every frame.\n\nvar quadMesh1 = new QuadMesh();\nvar quadMesh2 = new QuadMesh();\nvar GaussianBlurNode = /*#__PURE__*/function (_TempNode) {\n  _inherits(GaussianBlurNode, _TempNode);\n  var _super = _createSuper(GaussianBlurNode);\n  function GaussianBlurNode(textureNode) {\n    var _this;\n    var sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    _classCallCheck(this, GaussianBlurNode);\n    _this = _super.call(this, 'vec4');\n    _this.textureNode = textureNode;\n    _this.sigma = sigma;\n    _this.directionNode = vec2(1);\n    _this._invSize = uniform(new Vector2());\n    _this._passDirection = uniform(new Vector2());\n    _this._horizontalRT = new RenderTarget();\n    _this._horizontalRT.texture.name = 'GaussianBlurNode.horizontal';\n    _this._verticalRT = new RenderTarget();\n    _this._verticalRT.texture.name = 'GaussianBlurNode.vertical';\n    _this._textureNode = texturePass(_assertThisInitialized(_this), _this._verticalRT.texture);\n    _this.updateBeforeType = NodeUpdateType.RENDER;\n    _this.resolution = new Vector2(1, 1);\n    return _this;\n  }\n  _createClass(GaussianBlurNode, [{\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      width = Math.max(Math.round(width * this.resolution.x), 1);\n      height = Math.max(Math.round(height * this.resolution.y), 1);\n      this._invSize.value.set(1 / width, 1 / height);\n      this._horizontalRT.setSize(width, height);\n      this._verticalRT.setSize(width, height);\n    }\n  }, {\n    key: \"updateBefore\",\n    value: function updateBefore(frame) {\n      var renderer = frame.renderer;\n      var textureNode = this.textureNode;\n      var map = textureNode.value;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentTexture = textureNode.value;\n      quadMesh1.material = this._material;\n      quadMesh2.material = this._material;\n      this.setSize(map.image.width, map.image.height);\n      var textureType = map.type;\n      this._horizontalRT.texture.type = textureType;\n      this._verticalRT.texture.type = textureType;\n\n      // horizontal\n\n      renderer.setRenderTarget(this._horizontalRT);\n      this._passDirection.value.set(1, 0);\n      quadMesh1.render(renderer);\n\n      // vertical\n\n      textureNode.value = this._horizontalRT.texture;\n      renderer.setRenderTarget(this._verticalRT);\n      this._passDirection.value.set(0, 1);\n      quadMesh2.render(renderer);\n\n      // restore\n\n      renderer.setRenderTarget(currentRenderTarget);\n      textureNode.value = currentTexture;\n    }\n  }, {\n    key: \"getTextureNode\",\n    value: function getTextureNode() {\n      return this._textureNode;\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(builder) {\n      var _this2 = this;\n      var textureNode = this.textureNode;\n      if (textureNode.isTextureNode !== true) {\n        console.error('GaussianBlurNode requires a TextureNode.');\n        return vec4();\n      }\n\n      //\n\n      var uvNode = textureNode.uvNode || uv();\n      var sampleTexture = function sampleTexture(uv) {\n        return textureNode.cache().context({\n          getUV: function getUV() {\n            return uv;\n          },\n          forceUVContext: true\n        });\n      };\n      var blur = tslFn(function () {\n        var kernelSize = 3 + 2 * _this2.sigma;\n        var gaussianCoefficients = _this2._getCoefficients(kernelSize);\n        var invSize = _this2._invSize;\n        var direction = vec2(_this2.directionNode).mul(_this2._passDirection);\n        var weightSum = float(gaussianCoefficients[0]).toVar();\n        var diffuseSum = vec4(sampleTexture(uvNode).mul(weightSum)).toVar();\n        for (var i = 1; i < kernelSize; i++) {\n          var x = float(i);\n          var w = float(gaussianCoefficients[i]);\n          var uvOffset = vec2(direction.mul(invSize.mul(x))).toVar();\n          var sample1 = vec4(sampleTexture(uvNode.add(uvOffset)));\n          var sample2 = vec4(sampleTexture(uvNode.sub(uvOffset)));\n          diffuseSum.addAssign(sample1.add(sample2).mul(w));\n          weightSum.addAssign(mul(2.0, w));\n        }\n        return diffuseSum.div(weightSum);\n      });\n\n      //\n\n      var material = this._material || (this._material = builder.createNodeMaterial());\n      material.fragmentNode = blur();\n\n      //\n\n      var properties = builder.getNodeProperties(this);\n      properties.textureNode = textureNode;\n\n      //\n\n      return this._textureNode;\n    }\n  }, {\n    key: \"_getCoefficients\",\n    value: function _getCoefficients(kernelRadius) {\n      var coefficients = [];\n      for (var i = 0; i < kernelRadius; i++) {\n        coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);\n      }\n      return coefficients;\n    }\n  }]);\n  return GaussianBlurNode;\n}(TempNode);\nexport var gaussianBlur = function gaussianBlur(node, sigma) {\n  return nodeObject(new GaussianBlurNode(nodeObject(node), sigma));\n};\naddNodeElement('gaussianBlur', gaussianBlur);\nexport default GaussianBlurNode;","map":{"version":3,"names":["TempNode","nodeObject","addNodeElement","tslFn","float","vec2","vec4","NodeUpdateType","mul","uv","texturePass","uniform","Vector2","RenderTarget","QuadMesh","quadMesh1","quadMesh2","GaussianBlurNode","_TempNode","_inherits","_super","_createSuper","textureNode","_this","sigma","arguments","length","undefined","_classCallCheck","call","directionNode","_invSize","_passDirection","_horizontalRT","texture","name","_verticalRT","_textureNode","_assertThisInitialized","updateBeforeType","RENDER","resolution","_createClass","key","value","setSize","width","height","Math","max","round","x","y","set","updateBefore","frame","renderer","map","currentRenderTarget","getRenderTarget","currentTexture","material","_material","image","textureType","type","setRenderTarget","render","getTextureNode","setup","builder","_this2","isTextureNode","console","error","uvNode","sampleTexture","cache","context","getUV","forceUVContext","blur","kernelSize","gaussianCoefficients","_getCoefficients","invSize","direction","weightSum","toVar","diffuseSum","i","w","uvOffset","sample1","add","sample2","sub","addAssign","div","createNodeMaterial","fragmentNode","properties","getNodeProperties","kernelRadius","coefficients","push","exp","gaussianBlur","node"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/GaussianBlurNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { mul } from '../math/OperatorNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texturePass } from './PassNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { Vector2, RenderTarget } from 'three';\nimport QuadMesh from '../../objects/QuadMesh.js';\n\n// WebGPU: The use of a single QuadMesh for both gaussian blur passes results in a single RenderObject with a SampledTexture binding that\n// alternates between source textures and triggers creation of new BindGroups and BindGroupLayouts every frame.\n\nconst quadMesh1 = new QuadMesh();\nconst quadMesh2 = new QuadMesh();\n\nclass GaussianBlurNode extends TempNode {\n\n\tconstructor( textureNode, sigma = 2 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.sigma = sigma;\n\n\t\tthis.directionNode = vec2( 1 );\n\n\t\tthis._invSize = uniform( new Vector2() );\n\t\tthis._passDirection = uniform( new Vector2() );\n\n\t\tthis._horizontalRT = new RenderTarget();\n\t\tthis._horizontalRT.texture.name = 'GaussianBlurNode.horizontal';\n\t\tthis._verticalRT = new RenderTarget();\n\t\tthis._verticalRT.texture.name = 'GaussianBlurNode.vertical';\n\n\t\tthis._textureNode = texturePass( this, this._verticalRT.texture );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\tthis.resolution = new Vector2( 1, 1 );\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\twidth = Math.max( Math.round( width * this.resolution.x ), 1 );\n\t\theight = Math.max( Math.round( height * this.resolution.y ), 1 );\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\t\tthis._horizontalRT.setSize( width, height );\n\t\tthis._verticalRT.setSize( width, height );\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentTexture = textureNode.value;\n\n\t\tquadMesh1.material = this._material;\n\t\tquadMesh2.material = this._material;\n\n\t\tthis.setSize( map.image.width, map.image.height );\n\n\t\tconst textureType = map.type;\n\n\t\tthis._horizontalRT.texture.type = textureType;\n\t\tthis._verticalRT.texture.type = textureType;\n\n\t\t// horizontal\n\n\t\trenderer.setRenderTarget( this._horizontalRT );\n\n\t\tthis._passDirection.value.set( 1, 0 );\n\n\t\tquadMesh1.render( renderer );\n\n\t\t// vertical\n\n\t\ttextureNode.value = this._horizontalRT.texture;\n\t\trenderer.setRenderTarget( this._verticalRT );\n\n\t\tthis._passDirection.value.set( 0, 1 );\n\n\t\tquadMesh2.render( renderer );\n\n\t\t// restore\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\ttextureNode.value = currentTexture;\n\n\t}\n\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\n\t\tif ( textureNode.isTextureNode !== true ) {\n\n\t\t\tconsole.error( 'GaussianBlurNode requires a TextureNode.' );\n\n\t\t\treturn vec4();\n\n\t\t}\n\n\t\t//\n\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst sampleTexture = ( uv ) => textureNode.cache().context( { getUV: () => uv, forceUVContext: true } );\n\n\t\tconst blur = tslFn( () => {\n\n\t\t\tconst kernelSize = 3 + ( 2 * this.sigma );\n\t\t\tconst gaussianCoefficients = this._getCoefficients( kernelSize );\n\n\t\t\tconst invSize = this._invSize;\n\t\t\tconst direction = vec2( this.directionNode ).mul( this._passDirection );\n\n\t\t\tconst weightSum = float( gaussianCoefficients[ 0 ] ).toVar();\n\t\t\tconst diffuseSum = vec4( sampleTexture( uvNode ).mul( weightSum ) ).toVar();\n\n\t\t\tfor ( let i = 1; i < kernelSize; i ++ ) {\n\n\t\t\t\tconst x = float( i );\n\t\t\t\tconst w = float( gaussianCoefficients[ i ] );\n\n\t\t\t\tconst uvOffset = vec2( direction.mul( invSize.mul( x ) ) ).toVar();\n\n\t\t\t\tconst sample1 = vec4( sampleTexture( uvNode.add( uvOffset ) ) );\n\t\t\t\tconst sample2 = vec4( sampleTexture( uvNode.sub( uvOffset ) ) );\n\n\t\t\t\tdiffuseSum.addAssign( sample1.add( sample2 ).mul( w ) );\n\t\t\t\tweightSum.addAssign( mul( 2.0, w ) );\n\n\t\t\t}\n\n\t\t\treturn diffuseSum.div( weightSum );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst material = this._material || ( this._material = builder.createNodeMaterial() );\n\t\tmaterial.fragmentNode = blur();\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t_getCoefficients( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );\n\n\t\t}\n\n\t\treturn coefficients;\n\n\t}\n\n}\n\nexport const gaussianBlur = ( node, sigma ) => nodeObject( new GaussianBlurNode( nodeObject( node ), sigma ) );\n\naddNodeElement( 'gaussianBlur', gaussianBlur );\n\nexport default GaussianBlurNode;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}