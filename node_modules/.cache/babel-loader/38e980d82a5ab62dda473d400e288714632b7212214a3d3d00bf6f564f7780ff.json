{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec4 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { texturePass } from './PassNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { RenderTarget } from 'three';\nimport { sign, max } from '../math/MathNode.js';\nimport QuadMesh from '../../objects/QuadMesh.js';\nconst quadMeshComp = new QuadMesh();\nclass AfterImageNode extends TempNode {\n  constructor(textureNode) {\n    let damp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.96;\n    super(textureNode);\n    this.textureNode = textureNode;\n    this.textureNodeOld = texture();\n    this.damp = uniform(damp);\n    this._compRT = new RenderTarget();\n    this._compRT.texture.name = 'AfterImageNode.comp';\n    this._oldRT = new RenderTarget();\n    this._oldRT.texture.name = 'AfterImageNode.old';\n    this._textureNode = texturePass(this, this._compRT.texture);\n    this.updateBeforeType = NodeUpdateType.RENDER;\n  }\n  getTextureNode() {\n    return this._textureNode;\n  }\n  setSize(width, height) {\n    this._compRT.setSize(width, height);\n    this._oldRT.setSize(width, height);\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const textureNode = this.textureNode;\n    const map = textureNode.value;\n    const textureType = map.type;\n    this._compRT.texture.type = textureType;\n    this._oldRT.texture.type = textureType;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentTexture = textureNode.value;\n    this.textureNodeOld.value = this._oldRT.texture;\n\n    // comp\n    renderer.setRenderTarget(this._compRT);\n    quadMeshComp.render(renderer);\n\n    // Swap the textures\n    const temp = this._oldRT;\n    this._oldRT = this._compRT;\n    this._compRT = temp;\n\n    // set size before swapping fails\n    this.setSize(map.image.width, map.image.height);\n    renderer.setRenderTarget(currentRenderTarget);\n    textureNode.value = currentTexture;\n  }\n  setup(builder) {\n    const textureNode = this.textureNode;\n    const textureNodeOld = this.textureNodeOld;\n    if (textureNode.isTextureNode !== true) {\n      console.error('AfterImageNode requires a TextureNode.');\n      return vec4();\n    }\n\n    //\n\n    const uvNode = textureNode.uvNode || uv();\n    textureNodeOld.uvNode = uvNode;\n    const sampleTexture = uv => textureNode.cache().context({\n      getUV: () => uv,\n      forceUVContext: true\n    });\n    const when_gt = tslFn(_ref => {\n      let [x_immutable, y_immutable] = _ref;\n      const y = float(y_immutable).toVar();\n      const x = vec4(x_immutable).toVar();\n      return max(sign(x.sub(y)), 0.0);\n    });\n    const afterImg = tslFn(() => {\n      const texelOld = vec4(textureNodeOld);\n      const texelNew = vec4(sampleTexture(uvNode));\n      texelOld.mulAssign(this.damp.mul(when_gt(texelOld, 0.1)));\n      return max(texelNew, texelOld);\n    });\n\n    //\n\n    const materialComposed = this._materialComposed || (this._materialComposed = builder.createNodeMaterial());\n    materialComposed.fragmentNode = afterImg();\n    quadMeshComp.material = materialComposed;\n\n    //\n\n    const properties = builder.getNodeProperties(this);\n    properties.textureNode = textureNode;\n\n    //\n\n    return this._textureNode;\n  }\n}\nexport const afterImage = (node, damp) => nodeObject(new AfterImageNode(nodeObject(node), damp));\naddNodeElement('afterImage', afterImage);\nexport default AfterImageNode;","map":{"version":3,"names":["TempNode","nodeObject","addNodeElement","tslFn","float","vec4","NodeUpdateType","uv","texture","texturePass","uniform","RenderTarget","sign","max","QuadMesh","quadMeshComp","AfterImageNode","constructor","textureNode","damp","arguments","length","undefined","textureNodeOld","_compRT","name","_oldRT","_textureNode","updateBeforeType","RENDER","getTextureNode","setSize","width","height","updateBefore","frame","renderer","map","value","textureType","type","currentRenderTarget","getRenderTarget","currentTexture","setRenderTarget","render","temp","image","setup","builder","isTextureNode","console","error","uvNode","sampleTexture","cache","context","getUV","forceUVContext","when_gt","_ref","x_immutable","y_immutable","y","toVar","x","sub","afterImg","texelOld","texelNew","mulAssign","mul","materialComposed","_materialComposed","createNodeMaterial","fragmentNode","material","properties","getNodeProperties","afterImage","node"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/AfterImageNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec4 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { texturePass } from './PassNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { RenderTarget } from 'three';\nimport { sign, max } from '../math/MathNode.js';\nimport QuadMesh from '../../objects/QuadMesh.js';\n\nconst quadMeshComp = new QuadMesh();\n\nclass AfterImageNode extends TempNode {\n\n\tconstructor( textureNode, damp = 0.96 ) {\n\n\t\tsuper( textureNode );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.textureNodeOld = texture();\n\t\tthis.damp = uniform( damp );\n\n\t\tthis._compRT = new RenderTarget();\n\t\tthis._compRT.texture.name = 'AfterImageNode.comp';\n\n\t\tthis._oldRT = new RenderTarget();\n\t\tthis._oldRT.texture.name = 'AfterImageNode.old';\n\n\t\tthis._textureNode = texturePass( this, this._compRT.texture );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis._compRT.setSize( width, height );\n\t\tthis._oldRT.setSize( width, height );\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tconst textureType = map.type;\n\n\t\tthis._compRT.texture.type = textureType;\n\t\tthis._oldRT.texture.type = textureType;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentTexture = textureNode.value;\n\n\t\tthis.textureNodeOld.value = this._oldRT.texture;\n\n\t\t// comp\n\t\trenderer.setRenderTarget( this._compRT );\n\t\tquadMeshComp.render( renderer );\n\n\t\t// Swap the textures\n\t\tconst temp = this._oldRT;\n\t\tthis._oldRT = this._compRT;\n\t\tthis._compRT = temp;\n\n\t\t// set size before swapping fails\n\t\tthis.setSize( map.image.width, map.image.height );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\ttextureNode.value = currentTexture;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst textureNodeOld = this.textureNodeOld;\n\n\t\tif ( textureNode.isTextureNode !== true ) {\n\n\t\t\tconsole.error( 'AfterImageNode requires a TextureNode.' );\n\n\t\t\treturn vec4();\n\n\t\t}\n\n\t\t//\n\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\ttextureNodeOld.uvNode = uvNode;\n\n\t\tconst sampleTexture = ( uv ) => textureNode.cache().context( { getUV: () => uv, forceUVContext: true } );\n\n\t\tconst when_gt = tslFn( ( [ x_immutable, y_immutable ] ) => {\n\n\t\t\tconst y = float( y_immutable ).toVar();\n\t\t\tconst x = vec4( x_immutable ).toVar();\n\n\t\t\treturn max( sign( x.sub( y ) ), 0.0 );\n\n\t\t} );\n\n\t\tconst afterImg = tslFn( () => {\n\n\t\t\tconst texelOld = vec4( textureNodeOld );\n\t\t\tconst texelNew = vec4( sampleTexture( uvNode ) );\n\n\t\t\ttexelOld.mulAssign( this.damp.mul( when_gt( texelOld, 0.1 ) ) );\n\t\t\treturn max( texelNew, texelOld );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst materialComposed = this._materialComposed || ( this._materialComposed = builder.createNodeMaterial() );\n\t\tmaterialComposed.fragmentNode = afterImg();\n\n\t\tquadMeshComp.material = materialComposed;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n}\n\nexport const afterImage = ( node, damp ) => nodeObject( new AfterImageNode( nodeObject( node ), damp ) );\n\naddNodeElement( 'afterImage', afterImage );\n\nexport default AfterImageNode;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}