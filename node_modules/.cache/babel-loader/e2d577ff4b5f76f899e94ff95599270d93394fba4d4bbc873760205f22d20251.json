{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { normalView } from '../accessors/NormalNode.js';\nimport { positionView } from '../accessors/PositionNode.js';\nimport { faceDirection } from './FrontFacingNode.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec2 } from '../shadernode/ShaderNode.js';\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst dHdxy_fwd = tslFn(_ref => {\n  let {\n    textureNode,\n    bumpScale\n  } = _ref;\n  let texNode = textureNode;\n  if (texNode.isTextureNode !== true) {\n    texNode.traverse(node => {\n      if (node.isTextureNode === true) texNode = node;\n    });\n  }\n  if (texNode.isTextureNode !== true) {\n    throw new Error('THREE.TSL: dHdxy_fwd() requires a TextureNode.');\n  }\n  const Hll = float(textureNode);\n  const uvNode = texNode.uvNode || uv();\n\n  // It's used to preserve the same TextureNode instance\n  const sampleTexture = uv => textureNode.cache().context({\n    getUV: () => uv,\n    forceUVContext: true\n  });\n  return vec2(float(sampleTexture(uvNode.add(uvNode.dFdx()))).sub(Hll), float(sampleTexture(uvNode.add(uvNode.dFdy()))).sub(Hll)).mul(bumpScale);\n});\nconst perturbNormalArb = tslFn(inputs => {\n  const {\n    surf_pos,\n    surf_norm,\n    dHdxy\n  } = inputs;\n\n  // normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n  const vSigmaX = surf_pos.dFdx().normalize();\n  const vSigmaY = surf_pos.dFdy().normalize();\n  const vN = surf_norm; // normalized\n\n  const R1 = vSigmaY.cross(vN);\n  const R2 = vN.cross(vSigmaX);\n  const fDet = vSigmaX.dot(R1).mul(faceDirection);\n  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));\n  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();\n});\nclass BumpMapNode extends TempNode {\n  constructor(textureNode) {\n    let scaleNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super('vec3');\n    this.textureNode = textureNode;\n    this.scaleNode = scaleNode;\n  }\n  setup() {\n    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n    const dHdxy = dHdxy_fwd({\n      textureNode: this.textureNode,\n      bumpScale\n    });\n    return perturbNormalArb({\n      surf_pos: positionView,\n      surf_norm: normalView,\n      dHdxy\n    });\n  }\n}\nexport default BumpMapNode;\nexport const bumpMap = nodeProxy(BumpMapNode);\naddNodeElement('bumpMap', bumpMap);\naddNodeClass('BumpMapNode', BumpMapNode);","map":{"version":3,"names":["TempNode","addNodeClass","uv","normalView","positionView","faceDirection","addNodeElement","tslFn","nodeProxy","float","vec2","dHdxy_fwd","_ref","textureNode","bumpScale","texNode","isTextureNode","traverse","node","Error","Hll","uvNode","sampleTexture","cache","context","getUV","forceUVContext","add","dFdx","sub","dFdy","mul","perturbNormalArb","inputs","surf_pos","surf_norm","dHdxy","vSigmaX","normalize","vSigmaY","vN","R1","cross","R2","fDet","dot","vGrad","sign","x","y","abs","BumpMapNode","constructor","scaleNode","arguments","length","undefined","setup","bumpMap"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/BumpMapNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { normalView } from '../accessors/NormalNode.js';\nimport { positionView } from '../accessors/PositionNode.js';\nimport { faceDirection } from './FrontFacingNode.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec2 } from '../shadernode/ShaderNode.js';\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst dHdxy_fwd = tslFn( ( { textureNode, bumpScale } ) => {\n\n\tlet texNode = textureNode;\n\n\tif ( texNode.isTextureNode !== true ) {\n\n\t\ttexNode.traverse( ( node ) => {\n\n\t\t\tif ( node.isTextureNode === true ) texNode = node;\n\n\t\t} );\n\n\t}\n\n\tif ( texNode.isTextureNode !== true ) {\n\n\t\tthrow new Error( 'THREE.TSL: dHdxy_fwd() requires a TextureNode.' );\n\n\t}\n\n\tconst Hll = float( textureNode );\n\tconst uvNode = texNode.uvNode || uv();\n\n\t// It's used to preserve the same TextureNode instance\n\tconst sampleTexture = ( uv ) => textureNode.cache().context( { getUV: () => uv, forceUVContext: true } );\n\n\treturn vec2(\n\t\tfloat( sampleTexture( uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),\n\t\tfloat( sampleTexture( uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )\n\t).mul( bumpScale );\n\n} );\n\nconst perturbNormalArb = tslFn( ( inputs ) => {\n\n\tconst { surf_pos, surf_norm, dHdxy } = inputs;\n\n\t// normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n\tconst vSigmaX = surf_pos.dFdx().normalize();\n\tconst vSigmaY = surf_pos.dFdy().normalize();\n\tconst vN = surf_norm; // normalized\n\n\tconst R1 = vSigmaY.cross( vN );\n\tconst R2 = vN.cross( vSigmaX );\n\n\tconst fDet = vSigmaX.dot( R1 ).mul( faceDirection );\n\n\tconst vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );\n\n\treturn fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();\n\n} );\n\nclass BumpMapNode extends TempNode {\n\n\tconstructor( textureNode, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.scaleNode = scaleNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n\t\tconst dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );\n\n\t\treturn perturbNormalArb( {\n\t\t\tsurf_pos: positionView,\n\t\t\tsurf_norm: normalView,\n\t\t\tdHdxy\n\t\t} );\n\n\t}\n\n}\n\nexport default BumpMapNode;\n\nexport const bumpMap = nodeProxy( BumpMapNode );\n\naddNodeElement( 'bumpMap', bumpMap );\n\naddNodeClass( 'BumpMapNode', BumpMapNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}