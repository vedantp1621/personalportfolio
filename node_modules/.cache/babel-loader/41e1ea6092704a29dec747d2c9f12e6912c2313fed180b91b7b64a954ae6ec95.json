{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { mul } from '../math/OperatorNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texturePass } from './PassNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { Vector2, RenderTarget } from 'three';\nimport QuadMesh from '../../objects/QuadMesh.js';\n\n// WebGPU: The use of a single QuadMesh for both gaussian blur passes results in a single RenderObject with a SampledTexture binding that\n// alternates between source textures and triggers creation of new BindGroups and BindGroupLayouts every frame.\n\nconst quadMesh1 = new QuadMesh();\nconst quadMesh2 = new QuadMesh();\nclass GaussianBlurNode extends TempNode {\n  constructor(textureNode) {\n    let sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    super('vec4');\n    this.textureNode = textureNode;\n    this.sigma = sigma;\n    this.directionNode = vec2(1);\n    this._invSize = uniform(new Vector2());\n    this._passDirection = uniform(new Vector2());\n    this._horizontalRT = new RenderTarget();\n    this._horizontalRT.texture.name = 'GaussianBlurNode.horizontal';\n    this._verticalRT = new RenderTarget();\n    this._verticalRT.texture.name = 'GaussianBlurNode.vertical';\n    this._textureNode = texturePass(this, this._verticalRT.texture);\n    this.updateBeforeType = NodeUpdateType.RENDER;\n    this.resolution = new Vector2(1, 1);\n  }\n  setSize(width, height) {\n    width = Math.max(Math.round(width * this.resolution.x), 1);\n    height = Math.max(Math.round(height * this.resolution.y), 1);\n    this._invSize.value.set(1 / width, 1 / height);\n    this._horizontalRT.setSize(width, height);\n    this._verticalRT.setSize(width, height);\n  }\n  updateBefore(frame) {\n    const {\n      renderer\n    } = frame;\n    const textureNode = this.textureNode;\n    const map = textureNode.value;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentTexture = textureNode.value;\n    quadMesh1.material = this._material;\n    quadMesh2.material = this._material;\n    this.setSize(map.image.width, map.image.height);\n    const textureType = map.type;\n    this._horizontalRT.texture.type = textureType;\n    this._verticalRT.texture.type = textureType;\n\n    // horizontal\n\n    renderer.setRenderTarget(this._horizontalRT);\n    this._passDirection.value.set(1, 0);\n    quadMesh1.render(renderer);\n\n    // vertical\n\n    textureNode.value = this._horizontalRT.texture;\n    renderer.setRenderTarget(this._verticalRT);\n    this._passDirection.value.set(0, 1);\n    quadMesh2.render(renderer);\n\n    // restore\n\n    renderer.setRenderTarget(currentRenderTarget);\n    textureNode.value = currentTexture;\n  }\n  getTextureNode() {\n    return this._textureNode;\n  }\n  setup(builder) {\n    const textureNode = this.textureNode;\n    if (textureNode.isTextureNode !== true) {\n      console.error('GaussianBlurNode requires a TextureNode.');\n      return vec4();\n    }\n\n    //\n\n    const uvNode = textureNode.uvNode || uv();\n    const sampleTexture = uv => textureNode.cache().context({\n      getUV: () => uv,\n      forceUVContext: true\n    });\n    const blur = tslFn(() => {\n      const kernelSize = 3 + 2 * this.sigma;\n      const gaussianCoefficients = this._getCoefficients(kernelSize);\n      const invSize = this._invSize;\n      const direction = vec2(this.directionNode).mul(this._passDirection);\n      const weightSum = float(gaussianCoefficients[0]).toVar();\n      const diffuseSum = vec4(sampleTexture(uvNode).mul(weightSum)).toVar();\n      for (let i = 1; i < kernelSize; i++) {\n        const x = float(i);\n        const w = float(gaussianCoefficients[i]);\n        const uvOffset = vec2(direction.mul(invSize.mul(x))).toVar();\n        const sample1 = vec4(sampleTexture(uvNode.add(uvOffset)));\n        const sample2 = vec4(sampleTexture(uvNode.sub(uvOffset)));\n        diffuseSum.addAssign(sample1.add(sample2).mul(w));\n        weightSum.addAssign(mul(2.0, w));\n      }\n      return diffuseSum.div(weightSum);\n    });\n\n    //\n\n    const material = this._material || (this._material = builder.createNodeMaterial());\n    material.fragmentNode = blur();\n\n    //\n\n    const properties = builder.getNodeProperties(this);\n    properties.textureNode = textureNode;\n\n    //\n\n    return this._textureNode;\n  }\n  _getCoefficients(kernelRadius) {\n    const coefficients = [];\n    for (let i = 0; i < kernelRadius; i++) {\n      coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);\n    }\n    return coefficients;\n  }\n}\nexport const gaussianBlur = (node, sigma) => nodeObject(new GaussianBlurNode(nodeObject(node), sigma));\naddNodeElement('gaussianBlur', gaussianBlur);\nexport default GaussianBlurNode;","map":{"version":3,"names":["TempNode","nodeObject","addNodeElement","tslFn","float","vec2","vec4","NodeUpdateType","mul","uv","texturePass","uniform","Vector2","RenderTarget","QuadMesh","quadMesh1","quadMesh2","GaussianBlurNode","constructor","textureNode","sigma","arguments","length","undefined","directionNode","_invSize","_passDirection","_horizontalRT","texture","name","_verticalRT","_textureNode","updateBeforeType","RENDER","resolution","setSize","width","height","Math","max","round","x","y","value","set","updateBefore","frame","renderer","map","currentRenderTarget","getRenderTarget","currentTexture","material","_material","image","textureType","type","setRenderTarget","render","getTextureNode","setup","builder","isTextureNode","console","error","uvNode","sampleTexture","cache","context","getUV","forceUVContext","blur","kernelSize","gaussianCoefficients","_getCoefficients","invSize","direction","weightSum","toVar","diffuseSum","i","w","uvOffset","sample1","add","sample2","sub","addAssign","div","createNodeMaterial","fragmentNode","properties","getNodeProperties","kernelRadius","coefficients","push","exp","gaussianBlur","node"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/GaussianBlurNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { nodeObject, addNodeElement, tslFn, float, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { mul } from '../math/OperatorNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { texturePass } from './PassNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { Vector2, RenderTarget } from 'three';\nimport QuadMesh from '../../objects/QuadMesh.js';\n\n// WebGPU: The use of a single QuadMesh for both gaussian blur passes results in a single RenderObject with a SampledTexture binding that\n// alternates between source textures and triggers creation of new BindGroups and BindGroupLayouts every frame.\n\nconst quadMesh1 = new QuadMesh();\nconst quadMesh2 = new QuadMesh();\n\nclass GaussianBlurNode extends TempNode {\n\n\tconstructor( textureNode, sigma = 2 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\tthis.textureNode = textureNode;\n\t\tthis.sigma = sigma;\n\n\t\tthis.directionNode = vec2( 1 );\n\n\t\tthis._invSize = uniform( new Vector2() );\n\t\tthis._passDirection = uniform( new Vector2() );\n\n\t\tthis._horizontalRT = new RenderTarget();\n\t\tthis._horizontalRT.texture.name = 'GaussianBlurNode.horizontal';\n\t\tthis._verticalRT = new RenderTarget();\n\t\tthis._verticalRT.texture.name = 'GaussianBlurNode.vertical';\n\n\t\tthis._textureNode = texturePass( this, this._verticalRT.texture );\n\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\tthis.resolution = new Vector2( 1, 1 );\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\twidth = Math.max( Math.round( width * this.resolution.x ), 1 );\n\t\theight = Math.max( Math.round( height * this.resolution.y ), 1 );\n\n\t\tthis._invSize.value.set( 1 / width, 1 / height );\n\t\tthis._horizontalRT.setSize( width, height );\n\t\tthis._verticalRT.setSize( width, height );\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst textureNode = this.textureNode;\n\t\tconst map = textureNode.value;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentTexture = textureNode.value;\n\n\t\tquadMesh1.material = this._material;\n\t\tquadMesh2.material = this._material;\n\n\t\tthis.setSize( map.image.width, map.image.height );\n\n\t\tconst textureType = map.type;\n\n\t\tthis._horizontalRT.texture.type = textureType;\n\t\tthis._verticalRT.texture.type = textureType;\n\n\t\t// horizontal\n\n\t\trenderer.setRenderTarget( this._horizontalRT );\n\n\t\tthis._passDirection.value.set( 1, 0 );\n\n\t\tquadMesh1.render( renderer );\n\n\t\t// vertical\n\n\t\ttextureNode.value = this._horizontalRT.texture;\n\t\trenderer.setRenderTarget( this._verticalRT );\n\n\t\tthis._passDirection.value.set( 0, 1 );\n\n\t\tquadMesh2.render( renderer );\n\n\t\t// restore\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\ttextureNode.value = currentTexture;\n\n\t}\n\n\tgetTextureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst textureNode = this.textureNode;\n\n\t\tif ( textureNode.isTextureNode !== true ) {\n\n\t\t\tconsole.error( 'GaussianBlurNode requires a TextureNode.' );\n\n\t\t\treturn vec4();\n\n\t\t}\n\n\t\t//\n\n\t\tconst uvNode = textureNode.uvNode || uv();\n\n\t\tconst sampleTexture = ( uv ) => textureNode.cache().context( { getUV: () => uv, forceUVContext: true } );\n\n\t\tconst blur = tslFn( () => {\n\n\t\t\tconst kernelSize = 3 + ( 2 * this.sigma );\n\t\t\tconst gaussianCoefficients = this._getCoefficients( kernelSize );\n\n\t\t\tconst invSize = this._invSize;\n\t\t\tconst direction = vec2( this.directionNode ).mul( this._passDirection );\n\n\t\t\tconst weightSum = float( gaussianCoefficients[ 0 ] ).toVar();\n\t\t\tconst diffuseSum = vec4( sampleTexture( uvNode ).mul( weightSum ) ).toVar();\n\n\t\t\tfor ( let i = 1; i < kernelSize; i ++ ) {\n\n\t\t\t\tconst x = float( i );\n\t\t\t\tconst w = float( gaussianCoefficients[ i ] );\n\n\t\t\t\tconst uvOffset = vec2( direction.mul( invSize.mul( x ) ) ).toVar();\n\n\t\t\t\tconst sample1 = vec4( sampleTexture( uvNode.add( uvOffset ) ) );\n\t\t\t\tconst sample2 = vec4( sampleTexture( uvNode.sub( uvOffset ) ) );\n\n\t\t\t\tdiffuseSum.addAssign( sample1.add( sample2 ).mul( w ) );\n\t\t\t\tweightSum.addAssign( mul( 2.0, w ) );\n\n\t\t\t}\n\n\t\t\treturn diffuseSum.div( weightSum );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst material = this._material || ( this._material = builder.createNodeMaterial() );\n\t\tmaterial.fragmentNode = blur();\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.textureNode = textureNode;\n\n\t\t//\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t_getCoefficients( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );\n\n\t\t}\n\n\t\treturn coefficients;\n\n\t}\n\n}\n\nexport const gaussianBlur = ( node, sigma ) => nodeObject( new GaussianBlurNode( nodeObject( node ), sigma ) );\n\naddNodeElement( 'gaussianBlur', gaussianBlur );\n\nexport default GaussianBlurNode;\n\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,qBAAqB;AAC1C,SAASC,UAAU,EAAEC,cAAc,EAAEC,KAAK,EAAEC,KAAK,EAAEC,IAAI,EAAEC,IAAI,QAAQ,6BAA6B;AAClG,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,GAAG,QAAQ,yBAAyB;AAC7C,SAASC,EAAE,QAAQ,wBAAwB;AAC3C,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,OAAO,EAAEC,YAAY,QAAQ,OAAO;AAC7C,OAAOC,QAAQ,MAAM,2BAA2B;;AAEhD;AACA;;AAEA,MAAMC,SAAS,GAAG,IAAID,QAAQ,CAAC,CAAC;AAChC,MAAME,SAAS,GAAG,IAAIF,QAAQ,CAAC,CAAC;AAEhC,MAAMG,gBAAgB,SAASjB,QAAQ,CAAC;EAEvCkB,WAAWA,CAAEC,WAAW,EAAc;IAAA,IAAZC,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAElC,KAAK,CAAE,MAAO,CAAC;IAEf,IAAI,CAACF,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAElB,IAAI,CAACI,aAAa,GAAGnB,IAAI,CAAE,CAAE,CAAC;IAE9B,IAAI,CAACoB,QAAQ,GAAGd,OAAO,CAAE,IAAIC,OAAO,CAAC,CAAE,CAAC;IACxC,IAAI,CAACc,cAAc,GAAGf,OAAO,CAAE,IAAIC,OAAO,CAAC,CAAE,CAAC;IAE9C,IAAI,CAACe,aAAa,GAAG,IAAId,YAAY,CAAC,CAAC;IACvC,IAAI,CAACc,aAAa,CAACC,OAAO,CAACC,IAAI,GAAG,6BAA6B;IAC/D,IAAI,CAACC,WAAW,GAAG,IAAIjB,YAAY,CAAC,CAAC;IACrC,IAAI,CAACiB,WAAW,CAACF,OAAO,CAACC,IAAI,GAAG,2BAA2B;IAE3D,IAAI,CAACE,YAAY,GAAGrB,WAAW,CAAE,IAAI,EAAE,IAAI,CAACoB,WAAW,CAACF,OAAQ,CAAC;IAEjE,IAAI,CAACI,gBAAgB,GAAGzB,cAAc,CAAC0B,MAAM;IAE7C,IAAI,CAACC,UAAU,GAAG,IAAItB,OAAO,CAAE,CAAC,EAAE,CAAE,CAAC;EAEtC;EAEAuB,OAAOA,CAAEC,KAAK,EAAEC,MAAM,EAAG;IAExBD,KAAK,GAAGE,IAAI,CAACC,GAAG,CAAED,IAAI,CAACE,KAAK,CAAEJ,KAAK,GAAG,IAAI,CAACF,UAAU,CAACO,CAAE,CAAC,EAAE,CAAE,CAAC;IAC9DJ,MAAM,GAAGC,IAAI,CAACC,GAAG,CAAED,IAAI,CAACE,KAAK,CAAEH,MAAM,GAAG,IAAI,CAACH,UAAU,CAACQ,CAAE,CAAC,EAAE,CAAE,CAAC;IAEhE,IAAI,CAACjB,QAAQ,CAACkB,KAAK,CAACC,GAAG,CAAE,CAAC,GAAGR,KAAK,EAAE,CAAC,GAAGC,MAAO,CAAC;IAChD,IAAI,CAACV,aAAa,CAACQ,OAAO,CAAEC,KAAK,EAAEC,MAAO,CAAC;IAC3C,IAAI,CAACP,WAAW,CAACK,OAAO,CAAEC,KAAK,EAAEC,MAAO,CAAC;EAE1C;EAEAQ,YAAYA,CAAEC,KAAK,EAAG;IAErB,MAAM;MAAEC;IAAS,CAAC,GAAGD,KAAK;IAE1B,MAAM3B,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAM6B,GAAG,GAAG7B,WAAW,CAACwB,KAAK;IAE7B,MAAMM,mBAAmB,GAAGF,QAAQ,CAACG,eAAe,CAAC,CAAC;IACtD,MAAMC,cAAc,GAAGhC,WAAW,CAACwB,KAAK;IAExC5B,SAAS,CAACqC,QAAQ,GAAG,IAAI,CAACC,SAAS;IACnCrC,SAAS,CAACoC,QAAQ,GAAG,IAAI,CAACC,SAAS;IAEnC,IAAI,CAAClB,OAAO,CAAEa,GAAG,CAACM,KAAK,CAAClB,KAAK,EAAEY,GAAG,CAACM,KAAK,CAACjB,MAAO,CAAC;IAEjD,MAAMkB,WAAW,GAAGP,GAAG,CAACQ,IAAI;IAE5B,IAAI,CAAC7B,aAAa,CAACC,OAAO,CAAC4B,IAAI,GAAGD,WAAW;IAC7C,IAAI,CAACzB,WAAW,CAACF,OAAO,CAAC4B,IAAI,GAAGD,WAAW;;IAE3C;;IAEAR,QAAQ,CAACU,eAAe,CAAE,IAAI,CAAC9B,aAAc,CAAC;IAE9C,IAAI,CAACD,cAAc,CAACiB,KAAK,CAACC,GAAG,CAAE,CAAC,EAAE,CAAE,CAAC;IAErC7B,SAAS,CAAC2C,MAAM,CAAEX,QAAS,CAAC;;IAE5B;;IAEA5B,WAAW,CAACwB,KAAK,GAAG,IAAI,CAAChB,aAAa,CAACC,OAAO;IAC9CmB,QAAQ,CAACU,eAAe,CAAE,IAAI,CAAC3B,WAAY,CAAC;IAE5C,IAAI,CAACJ,cAAc,CAACiB,KAAK,CAACC,GAAG,CAAE,CAAC,EAAE,CAAE,CAAC;IAErC5B,SAAS,CAAC0C,MAAM,CAAEX,QAAS,CAAC;;IAE5B;;IAEAA,QAAQ,CAACU,eAAe,CAAER,mBAAoB,CAAC;IAC/C9B,WAAW,CAACwB,KAAK,GAAGQ,cAAc;EAEnC;EAEAQ,cAAcA,CAAA,EAAG;IAEhB,OAAO,IAAI,CAAC5B,YAAY;EAEzB;EAEA6B,KAAKA,CAAEC,OAAO,EAAG;IAEhB,MAAM1C,WAAW,GAAG,IAAI,CAACA,WAAW;IAEpC,IAAKA,WAAW,CAAC2C,aAAa,KAAK,IAAI,EAAG;MAEzCC,OAAO,CAACC,KAAK,CAAE,0CAA2C,CAAC;MAE3D,OAAO1D,IAAI,CAAC,CAAC;IAEd;;IAEA;;IAEA,MAAM2D,MAAM,GAAG9C,WAAW,CAAC8C,MAAM,IAAIxD,EAAE,CAAC,CAAC;IAEzC,MAAMyD,aAAa,GAAKzD,EAAE,IAAMU,WAAW,CAACgD,KAAK,CAAC,CAAC,CAACC,OAAO,CAAE;MAAEC,KAAK,EAAEA,CAAA,KAAM5D,EAAE;MAAE6D,cAAc,EAAE;IAAK,CAAE,CAAC;IAExG,MAAMC,IAAI,GAAGpE,KAAK,CAAE,MAAM;MAEzB,MAAMqE,UAAU,GAAG,CAAC,GAAK,CAAC,GAAG,IAAI,CAACpD,KAAO;MACzC,MAAMqD,oBAAoB,GAAG,IAAI,CAACC,gBAAgB,CAAEF,UAAW,CAAC;MAEhE,MAAMG,OAAO,GAAG,IAAI,CAAClD,QAAQ;MAC7B,MAAMmD,SAAS,GAAGvE,IAAI,CAAE,IAAI,CAACmB,aAAc,CAAC,CAAChB,GAAG,CAAE,IAAI,CAACkB,cAAe,CAAC;MAEvE,MAAMmD,SAAS,GAAGzE,KAAK,CAAEqE,oBAAoB,CAAE,CAAC,CAAG,CAAC,CAACK,KAAK,CAAC,CAAC;MAC5D,MAAMC,UAAU,GAAGzE,IAAI,CAAE4D,aAAa,CAAED,MAAO,CAAC,CAACzD,GAAG,CAAEqE,SAAU,CAAE,CAAC,CAACC,KAAK,CAAC,CAAC;MAE3E,KAAM,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,UAAU,EAAEQ,CAAC,EAAG,EAAG;QAEvC,MAAMvC,CAAC,GAAGrC,KAAK,CAAE4E,CAAE,CAAC;QACpB,MAAMC,CAAC,GAAG7E,KAAK,CAAEqE,oBAAoB,CAAEO,CAAC,CAAG,CAAC;QAE5C,MAAME,QAAQ,GAAG7E,IAAI,CAAEuE,SAAS,CAACpE,GAAG,CAAEmE,OAAO,CAACnE,GAAG,CAAEiC,CAAE,CAAE,CAAE,CAAC,CAACqC,KAAK,CAAC,CAAC;QAElE,MAAMK,OAAO,GAAG7E,IAAI,CAAE4D,aAAa,CAAED,MAAM,CAACmB,GAAG,CAAEF,QAAS,CAAE,CAAE,CAAC;QAC/D,MAAMG,OAAO,GAAG/E,IAAI,CAAE4D,aAAa,CAAED,MAAM,CAACqB,GAAG,CAAEJ,QAAS,CAAE,CAAE,CAAC;QAE/DH,UAAU,CAACQ,SAAS,CAAEJ,OAAO,CAACC,GAAG,CAAEC,OAAQ,CAAC,CAAC7E,GAAG,CAAEyE,CAAE,CAAE,CAAC;QACvDJ,SAAS,CAACU,SAAS,CAAE/E,GAAG,CAAE,GAAG,EAAEyE,CAAE,CAAE,CAAC;MAErC;MAEA,OAAOF,UAAU,CAACS,GAAG,CAAEX,SAAU,CAAC;IAEnC,CAAE,CAAC;;IAEH;;IAEA,MAAMzB,QAAQ,GAAG,IAAI,CAACC,SAAS,KAAM,IAAI,CAACA,SAAS,GAAGQ,OAAO,CAAC4B,kBAAkB,CAAC,CAAC,CAAE;IACpFrC,QAAQ,CAACsC,YAAY,GAAGnB,IAAI,CAAC,CAAC;;IAE9B;;IAEA,MAAMoB,UAAU,GAAG9B,OAAO,CAAC+B,iBAAiB,CAAE,IAAK,CAAC;IACpDD,UAAU,CAACxE,WAAW,GAAGA,WAAW;;IAEpC;;IAEA,OAAO,IAAI,CAACY,YAAY;EAEzB;EAEA2C,gBAAgBA,CAAEmB,YAAY,EAAG;IAEhC,MAAMC,YAAY,GAAG,EAAE;IAEvB,KAAM,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,YAAY,EAAEb,CAAC,EAAG,EAAG;MAEzCc,YAAY,CAACC,IAAI,CAAE,OAAO,GAAGzD,IAAI,CAAC0D,GAAG,CAAE,CAAE,GAAG,GAAGhB,CAAC,GAAGA,CAAC,IAAKa,YAAY,GAAGA,YAAY,CAAG,CAAC,GAAGA,YAAa,CAAC;IAE1G;IAEA,OAAOC,YAAY;EAEpB;AAED;AAEA,OAAO,MAAMG,YAAY,GAAGA,CAAEC,IAAI,EAAE9E,KAAK,KAAMnB,UAAU,CAAE,IAAIgB,gBAAgB,CAAEhB,UAAU,CAAEiG,IAAK,CAAC,EAAE9E,KAAM,CAAE,CAAC;AAE9GlB,cAAc,CAAE,cAAc,EAAE+F,YAAa,CAAC;AAE9C,eAAehF,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}