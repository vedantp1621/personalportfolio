{"ast":null,"code":"import Node, { addNodeClass } from './Node.js';\nimport { cond } from '../math/CondNode.js';\nimport { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\nclass StackNode extends Node {\n  constructor() {\n    let parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.nodes = [];\n    this.outputNode = null;\n    this.parent = parent;\n    this._currentCond = null;\n    this.isStackNode = true;\n  }\n  getNodeType(builder) {\n    return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';\n  }\n  add(node) {\n    this.nodes.push(node);\n    return this;\n  }\n  if(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    this._currentCond = cond(boolNode, methodNode);\n    return this.add(this._currentCond);\n  }\n  elseif(boolNode, method) {\n    const methodNode = new ShaderNode(method);\n    const ifNode = cond(boolNode, methodNode);\n    this._currentCond.elseNode = ifNode;\n    this._currentCond = ifNode;\n    return this;\n  }\n  else(method) {\n    this._currentCond.elseNode = new ShaderNode(method);\n    return this;\n  }\n  build(builder) {\n    const previousStack = getCurrentStack();\n    setCurrentStack(this);\n    for (const node of this.nodes) {\n      node.build(builder, 'void');\n    }\n    setCurrentStack(previousStack);\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);\n  }\n}\nexport default StackNode;\nexport const stack = nodeProxy(StackNode);\naddNodeClass('StackNode', StackNode);","map":{"version":3,"names":["Node","addNodeClass","cond","ShaderNode","nodeProxy","getCurrentStack","setCurrentStack","StackNode","constructor","parent","arguments","length","undefined","nodes","outputNode","_currentCond","isStackNode","getNodeType","builder","add","node","push","if","boolNode","method","methodNode","elseif","ifNode","elseNode","else","build","previousStack","_len","params","Array","_key","stack"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/core/StackNode.js"],"sourcesContent":["import Node, { addNodeClass } from './Node.js';\nimport { cond } from '../math/CondNode.js';\nimport { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';\n\nclass StackNode extends Node {\n\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\tthis.nodes = [];\n\t\tthis.outputNode = null;\n\n\t\tthis.parent = parent;\n\n\t\tthis._currentCond = null;\n\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tadd( node ) {\n\n\t\tthis.nodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\tif( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = cond( boolNode, methodNode );\n\n\t\treturn this.add( this._currentCond );\n\n\t}\n\n\telseif( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = cond( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\telse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousStack = getCurrentStack();\n\n\t\tsetCurrentStack( this );\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tnode.build( builder, 'void' );\n\n\t\t}\n\n\t\tsetCurrentStack( previousStack );\n\n\t\treturn this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t}\n\n}\n\nexport default StackNode;\n\nexport const stack = nodeProxy( StackNode );\n\naddNodeClass( 'StackNode', StackNode );\n"],"mappings":"AAAA,OAAOA,IAAI,IAAIC,YAAY,QAAQ,WAAW;AAC9C,SAASC,IAAI,QAAQ,qBAAqB;AAC1C,SAASC,UAAU,EAAEC,SAAS,EAAEC,eAAe,EAAEC,eAAe,QAAQ,6BAA6B;AAErG,MAAMC,SAAS,SAASP,IAAI,CAAC;EAE5BQ,WAAWA,CAAA,EAAkB;IAAA,IAAhBC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAEzB,KAAK,CAAC,CAAC;IAEP,IAAI,CAACG,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,UAAU,GAAG,IAAI;IAEtB,IAAI,CAACL,MAAM,GAAGA,MAAM;IAEpB,IAAI,CAACM,YAAY,GAAG,IAAI;IAExB,IAAI,CAACC,WAAW,GAAG,IAAI;EAExB;EAEAC,WAAWA,CAAEC,OAAO,EAAG;IAEtB,OAAO,IAAI,CAACJ,UAAU,GAAG,IAAI,CAACA,UAAU,CAACG,WAAW,CAAEC,OAAQ,CAAC,GAAG,MAAM;EAEzE;EAEAC,GAAGA,CAAEC,IAAI,EAAG;IAEX,IAAI,CAACP,KAAK,CAACQ,IAAI,CAAED,IAAK,CAAC;IAEvB,OAAO,IAAI;EAEZ;EAEAE,EAAEA,CAAEC,QAAQ,EAAEC,MAAM,EAAG;IAEtB,MAAMC,UAAU,GAAG,IAAItB,UAAU,CAAEqB,MAAO,CAAC;IAC3C,IAAI,CAACT,YAAY,GAAGb,IAAI,CAAEqB,QAAQ,EAAEE,UAAW,CAAC;IAEhD,OAAO,IAAI,CAACN,GAAG,CAAE,IAAI,CAACJ,YAAa,CAAC;EAErC;EAEAW,MAAMA,CAAEH,QAAQ,EAAEC,MAAM,EAAG;IAE1B,MAAMC,UAAU,GAAG,IAAItB,UAAU,CAAEqB,MAAO,CAAC;IAC3C,MAAMG,MAAM,GAAGzB,IAAI,CAAEqB,QAAQ,EAAEE,UAAW,CAAC;IAE3C,IAAI,CAACV,YAAY,CAACa,QAAQ,GAAGD,MAAM;IACnC,IAAI,CAACZ,YAAY,GAAGY,MAAM;IAE1B,OAAO,IAAI;EAEZ;EAEAE,IAAIA,CAAEL,MAAM,EAAG;IAEd,IAAI,CAACT,YAAY,CAACa,QAAQ,GAAG,IAAIzB,UAAU,CAAEqB,MAAO,CAAC;IAErD,OAAO,IAAI;EAEZ;EAEAM,KAAKA,CAAEZ,OAAO,EAAc;IAE3B,MAAMa,aAAa,GAAG1B,eAAe,CAAC,CAAC;IAEvCC,eAAe,CAAE,IAAK,CAAC;IAEvB,KAAM,MAAMc,IAAI,IAAI,IAAI,CAACP,KAAK,EAAG;MAEhCO,IAAI,CAACU,KAAK,CAAEZ,OAAO,EAAE,MAAO,CAAC;IAE9B;IAEAZ,eAAe,CAAEyB,aAAc,CAAC;IAAC,SAAAC,IAAA,GAAAtB,SAAA,CAAAC,MAAA,EAZfsB,MAAM,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAANF,MAAM,CAAAE,IAAA,QAAAzB,SAAA,CAAAyB,IAAA;IAAA;IAcxB,OAAO,IAAI,CAACrB,UAAU,GAAG,IAAI,CAACA,UAAU,CAACgB,KAAK,CAAEZ,OAAO,EAAE,GAAGe,MAAO,CAAC,GAAG,KAAK,CAACH,KAAK,CAAEZ,OAAO,EAAE,GAAGe,MAAO,CAAC;EAEzG;AAED;AAEA,eAAe1B,SAAS;AAExB,OAAO,MAAM6B,KAAK,GAAGhC,SAAS,CAAEG,SAAU,CAAC;AAE3CN,YAAY,CAAE,WAAW,EAAEM,SAAU,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}