{"ast":null,"code":"import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor, materialPointWidth } from '../accessors/MaterialNode.js'; // or should this be a property, instead?\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { smoothstep } from '../math/MathNode.js';\nimport { tslFn, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { PointsMaterial } from 'three';\nconst defaultValues = new PointsMaterial();\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.normals = false;\n    this.lights = false;\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.pointWidth = 1;\n    this.pointColorNode = null;\n    this.setDefaultValues(defaultValues);\n    this.setupShaders();\n    this.setValues(params);\n  }\n  setupShaders() {\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    this.vertexNode = tslFn(() => {\n      //vUv = uv;\n      varying(vec2(), 'vUv').assign(uv()); // @TODO: Analyze other way to do this\n\n      const instancePosition = attribute('instancePosition');\n\n      // camera space\n      const mvPos = property('vec4', 'mvPos');\n      mvPos.assign(modelViewMatrix.mul(vec4(instancePosition, 1.0)));\n      const aspect = viewport.z.div(viewport.w);\n\n      // clip space\n      const clipPos = cameraProjectionMatrix.mul(mvPos);\n\n      // offset in ndc space\n      const offset = property('vec2', 'offset');\n      offset.assign(positionGeometry.xy);\n      offset.assign(offset.mul(materialPointWidth));\n      offset.assign(offset.div(viewport.z));\n      offset.y.assign(offset.y.mul(aspect));\n\n      // back to clip space\n      offset.assign(offset.mul(clipPos.w));\n\n      //clipPos.xy += offset;\n      clipPos.assign(clipPos.add(vec4(offset, 0, 0)));\n      return clipPos;\n\n      //vec4 mvPosition = mvPos; // this was used for somethihng...\n    })();\n\n    this.fragmentNode = tslFn(() => {\n      const vUv = varying(vec2(), 'vUv');\n\n      // force assignment into correct place in flow\n      const alpha = property('float', 'alpha');\n      alpha.assign(1);\n      const a = vUv.x;\n      const b = vUv.y;\n      const len2 = a.mul(a).add(b.mul(b));\n      if (useAlphaToCoverage) {\n        // force assignment out of following 'if' statement - to avoid uniform control flow errors\n        const dlen = property('float', 'dlen');\n        dlen.assign(len2.fwidth());\n        alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n      } else {\n        len2.greaterThan(1.0).discard();\n      }\n      let pointColorNode;\n      if (this.pointColorNode) {\n        pointColorNode = this.pointColorNode;\n      } else {\n        if (useColor) {\n          const instanceColor = attribute('instanceColor');\n          pointColorNode = instanceColor.mul(materialColor);\n        } else {\n          pointColorNode = materialColor;\n        }\n      }\n      return vec4(pointColorNode, alpha);\n    })();\n    this.needsUpdate = true;\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.setupShaders();\n    }\n  }\n}\nexport default InstancedPointsNodeMaterial;\naddNodeMaterial('InstancedPointsNodeMaterial', InstancedPointsNodeMaterial);","map":{"version":3,"names":["NodeMaterial","addNodeMaterial","varying","property","attribute","cameraProjectionMatrix","materialColor","materialPointWidth","modelViewMatrix","positionGeometry","smoothstep","tslFn","vec2","vec4","uv","viewport","PointsMaterial","defaultValues","InstancedPointsNodeMaterial","constructor","params","arguments","length","undefined","normals","lights","useAlphaToCoverage","useColor","vertexColors","pointWidth","pointColorNode","setDefaultValues","setupShaders","setValues","alphaToCoverage","vertexNode","assign","instancePosition","mvPos","mul","aspect","z","div","w","clipPos","offset","xy","y","add","fragmentNode","vUv","alpha","a","x","b","len2","dlen","fwidth","oneMinus","greaterThan","discard","instanceColor","needsUpdate","value"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/materials/InstancedPointsNodeMaterial.js"],"sourcesContent":["import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor, materialPointWidth } from '../accessors/MaterialNode.js'; // or should this be a property, instead?\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { smoothstep } from '../math/MathNode.js';\nimport { tslFn, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { viewport } from '../display/ViewportNode.js';\n\nimport { PointsMaterial } from 'three';\n\nconst defaultValues = new PointsMaterial();\n\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.normals = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.useAlphaToCoverage = true;\n\n\t\tthis.useColor = params.vertexColors;\n\n\t\tthis.pointWidth = 1;\n\n\t\tthis.pointColorNode = null;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setupShaders();\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetupShaders() {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\n\t\tthis.vertexNode = tslFn( () => {\n\n\t\t\t//vUv = uv;\n\t\t\tvarying( vec2(), 'vUv' ).assign( uv() ); // @TODO: Analyze other way to do this\n\n\t\t\tconst instancePosition = attribute( 'instancePosition' );\n\n\t\t\t// camera space\n\t\t\tconst mvPos = property( 'vec4', 'mvPos' );\n\t\t\tmvPos.assign( modelViewMatrix.mul( vec4( instancePosition, 1.0 ) ) );\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// clip space\n\t\t\tconst clipPos = cameraProjectionMatrix.mul( mvPos );\n\n\t\t\t// offset in ndc space\n\t\t\tconst offset = property( 'vec2', 'offset' );\n\t\t\toffset.assign( positionGeometry.xy );\n\t\t\toffset.assign( offset.mul( materialPointWidth ) );\n\t\t\toffset.assign( offset.div( viewport.z ) );\n\t\t\toffset.y.assign( offset.y.mul( aspect ) );\n\n\t\t\t// back to clip space\n\t\t\toffset.assign( offset.mul( clipPos.w ) );\n\n\t\t\t//clipPos.xy += offset;\n\t\t\tclipPos.assign( clipPos.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\treturn clipPos;\n\n\t\t\t//vec4 mvPosition = mvPos; // this was used for somethihng...\n\n\t\t} )();\n\n\t\tthis.fragmentNode = tslFn( () => {\n\n\t\t\tconst vUv = varying( vec2(), 'vUv' );\n\n\t\t\t// force assignment into correct place in flow\n\t\t\tconst alpha = property( 'float', 'alpha' );\n\t\t\talpha.assign( 1 );\n\n\t\t\tconst a = vUv.x;\n\t\t\tconst b = vUv.y;\n\n\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t// force assignment out of following 'if' statement - to avoid uniform control flow errors\n\t\t\t\tconst dlen = property( 'float', 'dlen' );\n\t\t\t\tdlen.assign( len2.fwidth() );\n\n\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t} else {\n\n\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t}\n\n\t\t\tlet pointColorNode;\n\n\t\t\tif ( this.pointColorNode ) {\n\n\t\t\t\tpointColorNode = this.pointColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColor = attribute( 'instanceColor' );\n\n\t\t\t\t\tpointColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpointColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( pointColorNode, alpha );\n\n\t\t} )();\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n}\n\nexport default InstancedPointsNodeMaterial;\n\naddNodeMaterial( 'InstancedPointsNodeMaterial', InstancedPointsNodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}