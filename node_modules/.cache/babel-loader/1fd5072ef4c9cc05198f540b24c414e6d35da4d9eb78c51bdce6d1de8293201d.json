{"ast":null,"code":"import _classCallCheck from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/vedant/Documents/GitHub/vedantpPersWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor, materialPointWidth } from '../accessors/MaterialNode.js'; // or should this be a property, instead?\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { smoothstep } from '../math/MathNode.js';\nimport { tslFn, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { PointsMaterial } from 'three';\nvar defaultValues = new PointsMaterial();\nvar InstancedPointsNodeMaterial = /*#__PURE__*/function (_NodeMaterial) {\n  _inherits(InstancedPointsNodeMaterial, _NodeMaterial);\n  var _super = _createSuper(InstancedPointsNodeMaterial);\n  function InstancedPointsNodeMaterial() {\n    var _this;\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, InstancedPointsNodeMaterial);\n    _this = _super.call(this);\n    _this.normals = false;\n    _this.lights = false;\n    _this.useAlphaToCoverage = true;\n    _this.useColor = params.vertexColors;\n    _this.pointWidth = 1;\n    _this.pointColorNode = null;\n    _this.setDefaultValues(defaultValues);\n    _this.setupShaders();\n    _this.setValues(params);\n    return _this;\n  }\n  _createClass(InstancedPointsNodeMaterial, [{\n    key: \"setupShaders\",\n    value: function setupShaders() {\n      var _this2 = this;\n      var useAlphaToCoverage = this.alphaToCoverage;\n      var useColor = this.useColor;\n      this.vertexNode = tslFn(function () {\n        //vUv = uv;\n        varying(vec2(), 'vUv').assign(uv()); // @TODO: Analyze other way to do this\n\n        var instancePosition = attribute('instancePosition');\n\n        // camera space\n        var mvPos = property('vec4', 'mvPos');\n        mvPos.assign(modelViewMatrix.mul(vec4(instancePosition, 1.0)));\n        var aspect = viewport.z.div(viewport.w);\n\n        // clip space\n        var clipPos = cameraProjectionMatrix.mul(mvPos);\n\n        // offset in ndc space\n        var offset = property('vec2', 'offset');\n        offset.assign(positionGeometry.xy);\n        offset.assign(offset.mul(materialPointWidth));\n        offset.assign(offset.div(viewport.z));\n        offset.y.assign(offset.y.mul(aspect));\n\n        // back to clip space\n        offset.assign(offset.mul(clipPos.w));\n\n        //clipPos.xy += offset;\n        clipPos.assign(clipPos.add(vec4(offset, 0, 0)));\n        return clipPos;\n\n        //vec4 mvPosition = mvPos; // this was used for somethihng...\n      })();\n\n      this.fragmentNode = tslFn(function () {\n        var vUv = varying(vec2(), 'vUv');\n\n        // force assignment into correct place in flow\n        var alpha = property('float', 'alpha');\n        alpha.assign(1);\n        var a = vUv.x;\n        var b = vUv.y;\n        var len2 = a.mul(a).add(b.mul(b));\n        if (useAlphaToCoverage) {\n          // force assignment out of following 'if' statement - to avoid uniform control flow errors\n          var dlen = property('float', 'dlen');\n          dlen.assign(len2.fwidth());\n          alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n        } else {\n          len2.greaterThan(1.0).discard();\n        }\n        var pointColorNode;\n        if (_this2.pointColorNode) {\n          pointColorNode = _this2.pointColorNode;\n        } else {\n          if (useColor) {\n            var instanceColor = attribute('instanceColor');\n            pointColorNode = instanceColor.mul(materialColor);\n          } else {\n            pointColorNode = materialColor;\n          }\n        }\n        return vec4(pointColorNode, alpha);\n      })();\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"alphaToCoverage\",\n    get: function get() {\n      return this.useAlphaToCoverage;\n    },\n    set: function set(value) {\n      if (this.useAlphaToCoverage !== value) {\n        this.useAlphaToCoverage = value;\n        this.setupShaders();\n      }\n    }\n  }]);\n  return InstancedPointsNodeMaterial;\n}(NodeMaterial);\nexport default InstancedPointsNodeMaterial;\naddNodeMaterial('InstancedPointsNodeMaterial', InstancedPointsNodeMaterial);","map":{"version":3,"names":["NodeMaterial","addNodeMaterial","varying","property","attribute","cameraProjectionMatrix","materialColor","materialPointWidth","modelViewMatrix","positionGeometry","smoothstep","tslFn","vec2","vec4","uv","viewport","PointsMaterial","defaultValues","InstancedPointsNodeMaterial","_NodeMaterial","_inherits","_super","_createSuper","_this","params","arguments","length","undefined","_classCallCheck","call","normals","lights","useAlphaToCoverage","useColor","vertexColors","pointWidth","pointColorNode","setDefaultValues","setupShaders","setValues","_createClass","key","value","_this2","alphaToCoverage","vertexNode","assign","instancePosition","mvPos","mul","aspect","z","div","w","clipPos","offset","xy","y","add","fragmentNode","vUv","alpha","a","x","b","len2","dlen","fwidth","oneMinus","greaterThan","discard","instanceColor","needsUpdate","get","set"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/materials/InstancedPointsNodeMaterial.js"],"sourcesContent":["import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor, materialPointWidth } from '../accessors/MaterialNode.js'; // or should this be a property, instead?\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { smoothstep } from '../math/MathNode.js';\nimport { tslFn, vec2, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { viewport } from '../display/ViewportNode.js';\n\nimport { PointsMaterial } from 'three';\n\nconst defaultValues = new PointsMaterial();\n\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.normals = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.useAlphaToCoverage = true;\n\n\t\tthis.useColor = params.vertexColors;\n\n\t\tthis.pointWidth = 1;\n\n\t\tthis.pointColorNode = null;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.setupShaders();\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetupShaders() {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\n\t\tthis.vertexNode = tslFn( () => {\n\n\t\t\t//vUv = uv;\n\t\t\tvarying( vec2(), 'vUv' ).assign( uv() ); // @TODO: Analyze other way to do this\n\n\t\t\tconst instancePosition = attribute( 'instancePosition' );\n\n\t\t\t// camera space\n\t\t\tconst mvPos = property( 'vec4', 'mvPos' );\n\t\t\tmvPos.assign( modelViewMatrix.mul( vec4( instancePosition, 1.0 ) ) );\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// clip space\n\t\t\tconst clipPos = cameraProjectionMatrix.mul( mvPos );\n\n\t\t\t// offset in ndc space\n\t\t\tconst offset = property( 'vec2', 'offset' );\n\t\t\toffset.assign( positionGeometry.xy );\n\t\t\toffset.assign( offset.mul( materialPointWidth ) );\n\t\t\toffset.assign( offset.div( viewport.z ) );\n\t\t\toffset.y.assign( offset.y.mul( aspect ) );\n\n\t\t\t// back to clip space\n\t\t\toffset.assign( offset.mul( clipPos.w ) );\n\n\t\t\t//clipPos.xy += offset;\n\t\t\tclipPos.assign( clipPos.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\treturn clipPos;\n\n\t\t\t//vec4 mvPosition = mvPos; // this was used for somethihng...\n\n\t\t} )();\n\n\t\tthis.fragmentNode = tslFn( () => {\n\n\t\t\tconst vUv = varying( vec2(), 'vUv' );\n\n\t\t\t// force assignment into correct place in flow\n\t\t\tconst alpha = property( 'float', 'alpha' );\n\t\t\talpha.assign( 1 );\n\n\t\t\tconst a = vUv.x;\n\t\t\tconst b = vUv.y;\n\n\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t// force assignment out of following 'if' statement - to avoid uniform control flow errors\n\t\t\t\tconst dlen = property( 'float', 'dlen' );\n\t\t\t\tdlen.assign( len2.fwidth() );\n\n\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t} else {\n\n\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t}\n\n\t\t\tlet pointColorNode;\n\n\t\t\tif ( this.pointColorNode ) {\n\n\t\t\t\tpointColorNode = this.pointColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColor = attribute( 'instanceColor' );\n\n\t\t\t\t\tpointColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpointColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( pointColorNode, alpha );\n\n\t\t} )();\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n}\n\nexport default InstancedPointsNodeMaterial;\n\naddNodeMaterial( 'InstancedPointsNodeMaterial', InstancedPointsNodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}