{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { getValueType } from '../core/NodeUtils.js';\nimport { buffer } from '../accessors/BufferNode.js';\n//import { bufferAttribute } from '../accessors/BufferAttributeNode.js';\nimport { instanceIndex } from '../core/IndexNode.js';\nimport { nodeProxy, float } from '../shadernode/ShaderNode.js';\nimport { Vector4, MathUtils } from 'three';\nlet min = null;\nlet max = null;\nclass RangeNode extends Node {\n  constructor() {\n    let minNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : float();\n    let maxNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : float();\n    super();\n    this.minNode = minNode;\n    this.maxNode = maxNode;\n  }\n  getVectorLength(builder) {\n    const minLength = builder.getTypeLength(getValueType(this.minNode.value));\n    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));\n    return minLength > maxLength ? minLength : maxLength;\n  }\n  getNodeType(builder) {\n    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength(builder)) : 'float';\n  }\n  setup(builder) {\n    const object = builder.object;\n    let output = null;\n    if (object.isInstancedMesh === true) {\n      const minValue = this.minNode.value;\n      const maxValue = this.maxNode.value;\n      const minLength = builder.getTypeLength(getValueType(minValue));\n      const maxLength = builder.getTypeLength(getValueType(maxValue));\n      min = min || new Vector4();\n      max = max || new Vector4();\n      min.setScalar(0);\n      max.setScalar(0);\n      if (minLength === 1) min.setScalar(minValue);else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b);else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);\n      if (maxLength === 1) max.setScalar(maxValue);else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b);else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);\n      const stride = 4;\n      const length = stride * object.count;\n      const array = new Float32Array(length);\n      for (let i = 0; i < length; i++) {\n        const index = i % stride;\n        const minElementValue = min.getComponent(index);\n        const maxElementValue = max.getComponent(index);\n        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());\n      }\n      const nodeType = this.getNodeType(builder);\n      output = buffer(array, 'vec4', object.count).element(instanceIndex).convert(nodeType);\n      //output = bufferAttribute( array, 'vec4', 4, 0 ).convert( nodeType );\n    } else {\n      output = float(0);\n    }\n    return output;\n  }\n}\nexport default RangeNode;\nexport const range = nodeProxy(RangeNode);\naddNodeClass('RangeNode', RangeNode);","map":{"version":3,"names":["Node","addNodeClass","getValueType","buffer","instanceIndex","nodeProxy","float","Vector4","MathUtils","min","max","RangeNode","constructor","minNode","arguments","length","undefined","maxNode","getVectorLength","builder","minLength","getTypeLength","value","maxLength","getNodeType","object","isInstancedMesh","getTypeFromLength","setup","output","minValue","maxValue","setScalar","isColor","set","r","g","b","x","y","z","w","stride","count","array","Float32Array","i","index","minElementValue","getComponent","maxElementValue","lerp","Math","random","nodeType","element","convert","range"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/geometry/RangeNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { getValueType } from '../core/NodeUtils.js';\nimport { buffer } from '../accessors/BufferNode.js';\n//import { bufferAttribute } from '../accessors/BufferAttributeNode.js';\nimport { instanceIndex } from '../core/IndexNode.js';\nimport { nodeProxy, float } from '../shadernode/ShaderNode.js';\n\nimport { Vector4, MathUtils } from 'three';\n\nlet min = null;\nlet max = null;\n\nclass RangeNode extends Node {\n\n\tconstructor( minNode = float(), maxNode = float() ) {\n\n\t\tsuper();\n\n\t\tthis.minNode = minNode;\n\t\tthis.maxNode = maxNode;\n\n\t}\n\n\tgetVectorLength( builder ) {\n\n\t\tconst minLength = builder.getTypeLength( getValueType( this.minNode.value ) );\n\t\tconst maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );\n\n\t\treturn minLength > maxLength ? minLength : maxLength;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.object.isInstancedMesh === true ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\tlet output = null;\n\n\t\tif ( object.isInstancedMesh === true ) {\n\n\t\t\tconst minValue = this.minNode.value;\n\t\t\tconst maxValue = this.maxNode.value;\n\n\t\t\tconst minLength = builder.getTypeLength( getValueType( minValue ) );\n\t\t\tconst maxLength = builder.getTypeLength( getValueType( maxValue ) );\n\n\t\t\tmin = min || new Vector4();\n\t\t\tmax = max || new Vector4();\n\n\t\t\tmin.setScalar( 0 );\n\t\t\tmax.setScalar( 0 );\n\n\t\t\tif ( minLength === 1 ) min.setScalar( minValue );\n\t\t\telse if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b );\n\t\t\telse min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );\n\n\t\t\tif ( maxLength === 1 ) max.setScalar( maxValue );\n\t\t\telse if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b );\n\t\t\telse max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );\n\n\t\t\tconst stride = 4;\n\n\t\t\tconst length = stride * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst index = i % stride;\n\n\t\t\t\tconst minElementValue = min.getComponent( index );\n\t\t\t\tconst maxElementValue = max.getComponent( index );\n\n\t\t\t\tarray[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );\n\n\t\t\t}\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\toutput = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );\n\t\t\t//output = bufferAttribute( array, 'vec4', 4, 0 ).convert( nodeType );\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nexport default RangeNode;\n\nexport const range = nodeProxy( RangeNode );\n\naddNodeClass( 'RangeNode', RangeNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}