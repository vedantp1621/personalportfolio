{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { dot, mix } from '../math/MathNode.js';\nimport { add } from '../math/OperatorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec3 } from '../shadernode/ShaderNode.js';\nconst saturationNode = tslFn(_ref => {\n  let {\n    color,\n    adjustment\n  } = _ref;\n  return adjustment.mix(luminance(color.rgb), color.rgb);\n});\nconst vibranceNode = tslFn(_ref2 => {\n  let {\n    color,\n    adjustment\n  } = _ref2;\n  const average = add(color.r, color.g, color.b).div(3.0);\n  const mx = color.r.max(color.g.max(color.b));\n  const amt = mx.sub(average).mul(adjustment).mul(-3.0);\n  return mix(color.rgb, mx, amt);\n});\nconst hueNode = tslFn(_ref3 => {\n  let {\n    color,\n    adjustment\n  } = _ref3;\n  const k = vec3(0.57735, 0.57735, 0.57735);\n  const cosAngle = adjustment.cos();\n  return vec3(color.rgb.mul(cosAngle).add(k.cross(color.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color.rgb).mul(cosAngle.oneMinus())))));\n});\nclass ColorAdjustmentNode extends TempNode {\n  constructor(method, colorNode) {\n    let adjustmentNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : float(1);\n    super('vec3');\n    this.method = method;\n    this.colorNode = colorNode;\n    this.adjustmentNode = adjustmentNode;\n  }\n  setup() {\n    const {\n      method,\n      colorNode,\n      adjustmentNode\n    } = this;\n    const callParams = {\n      color: colorNode,\n      adjustment: adjustmentNode\n    };\n    let outputNode = null;\n    if (method === ColorAdjustmentNode.SATURATION) {\n      outputNode = saturationNode(callParams);\n    } else if (method === ColorAdjustmentNode.VIBRANCE) {\n      outputNode = vibranceNode(callParams);\n    } else if (method === ColorAdjustmentNode.HUE) {\n      outputNode = hueNode(callParams);\n    } else {\n      console.error(`${this.type}: Method \"${this.method}\" not supported!`);\n    }\n    return outputNode;\n  }\n}\nColorAdjustmentNode.SATURATION = 'saturation';\nColorAdjustmentNode.VIBRANCE = 'vibrance';\nColorAdjustmentNode.HUE = 'hue';\nexport default ColorAdjustmentNode;\nexport const saturation = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.SATURATION);\nexport const vibrance = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE);\nexport const hue = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.HUE);\nexport const lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);\nexport const luminance = function (color) {\n  let luma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lumaCoeffs;\n  return dot(color, luma);\n};\nexport const threshold = (color, threshold) => mix(vec3(0.0), color, luminance(color).sub(threshold).max(0));\naddNodeElement('saturation', saturation);\naddNodeElement('vibrance', vibrance);\naddNodeElement('hue', hue);\naddNodeElement('threshold', threshold);\naddNodeClass('ColorAdjustmentNode', ColorAdjustmentNode);","map":{"version":3,"names":["TempNode","dot","mix","add","addNodeClass","addNodeElement","tslFn","nodeProxy","float","vec3","saturationNode","_ref","color","adjustment","luminance","rgb","vibranceNode","_ref2","average","r","g","b","div","mx","max","amt","sub","mul","hueNode","_ref3","k","cosAngle","cos","cross","sin","oneMinus","ColorAdjustmentNode","constructor","method","colorNode","adjustmentNode","arguments","length","undefined","setup","callParams","outputNode","SATURATION","VIBRANCE","HUE","console","error","type","saturation","vibrance","hue","lumaCoeffs","luma","threshold"],"sources":["/Users/vedant/node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js"],"sourcesContent":["import TempNode from '../core/TempNode.js';\nimport { dot, mix } from '../math/MathNode.js';\nimport { add } from '../math/OperatorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, tslFn, nodeProxy, float, vec3 } from '../shadernode/ShaderNode.js';\n\nconst saturationNode = tslFn( ( { color, adjustment } ) => {\n\n\treturn adjustment.mix( luminance( color.rgb ), color.rgb );\n\n} );\n\nconst vibranceNode = tslFn( ( { color, adjustment } ) => {\n\n\tconst average = add( color.r, color.g, color.b ).div( 3.0 );\n\n\tconst mx = color.r.max( color.g.max( color.b ) );\n\tconst amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );\n\n\treturn mix( color.rgb, mx, amt );\n\n} );\n\nconst hueNode = tslFn( ( { color, adjustment } ) => {\n\n\tconst k = vec3( 0.57735, 0.57735, 0.57735 );\n\n\tconst cosAngle = adjustment.cos();\n\n\treturn vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );\n\n} );\n\nclass ColorAdjustmentNode extends TempNode {\n\n\tconstructor( method, colorNode, adjustmentNode = float( 1 ) ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.method = method;\n\n\t\tthis.colorNode = colorNode;\n\t\tthis.adjustmentNode = adjustmentNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { method, colorNode, adjustmentNode } = this;\n\n\t\tconst callParams = { color: colorNode, adjustment: adjustmentNode };\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === ColorAdjustmentNode.SATURATION ) {\n\n\t\t\toutputNode = saturationNode( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.VIBRANCE ) {\n\n\t\t\toutputNode = vibranceNode( callParams );\n\n\t\t} else if ( method === ColorAdjustmentNode.HUE ) {\n\n\t\t\toutputNode = hueNode( callParams );\n\n\t\t} else {\n\n\t\t\tconsole.error( `${ this.type }: Method \"${ this.method }\" not supported!` );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\nColorAdjustmentNode.SATURATION = 'saturation';\nColorAdjustmentNode.VIBRANCE = 'vibrance';\nColorAdjustmentNode.HUE = 'hue';\n\nexport default ColorAdjustmentNode;\n\nexport const saturation = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.SATURATION );\nexport const vibrance = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE );\nexport const hue = nodeProxy( ColorAdjustmentNode, ColorAdjustmentNode.HUE );\n\nexport const lumaCoeffs = vec3( 0.2125, 0.7154, 0.0721 );\nexport const luminance = ( color, luma = lumaCoeffs ) => dot( color, luma );\n\nexport const threshold = ( color, threshold ) => mix( vec3( 0.0 ), color, luminance( color ).sub( threshold ).max( 0 ) );\n\naddNodeElement( 'saturation', saturation );\naddNodeElement( 'vibrance', vibrance );\naddNodeElement( 'hue', hue );\naddNodeElement( 'threshold', threshold );\n\naddNodeClass( 'ColorAdjustmentNode', ColorAdjustmentNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}